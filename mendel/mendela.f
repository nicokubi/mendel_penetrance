C###############################################################################
C   This is a modified version of the MENDEL program, originally written by
C   Kenneth Lange, 1984.
C
C   It was modified by Andrew Lee, the University of Cambridge, July 2012.
C
C   =============
C   Description :
C   =============
C
C   1) The subroutine MULSUM has been replaced with an overloaded version.
C      This uses the BLAS subroutines where appropriate, and defaults to
C      the original MULSUM for unknown cases.
C
C   2) The inner 'LIKE' loop has been discarded, so that the correct value
C      of like is passed to APEN.
C
C
C   =============
C   Compilation :
C   =============
C
C   You will need to supply user subroutines.
C   To compile use the command
C   $ <compiler> <flags> mendelt.f <user subroutines>.f -o <executable>
C
C   e.g
C   $ gfortran -O3 mendelt.f boadicea.f -o boadicea.exe
C
C
C
C   =========
C   CVS LOG :
C   =========
C   $Log: mendelt.f,v $
C   Revision 1.5  2012-08-20 13:14:48  andrewl
C
C   20/08/2012 Andrew Lee
C              1) The inner 'LIKE' loop has been removed, to allow the correct
C                 caching of variables in APEN.
C
C              2) The code has been debugged and compared against the original
C                 Mendel for a number of user subroutines, for both caching
C                 and non-caching and BLAS and non-BLAS. It has been tested
C                 with both f77 (Sun/Oracle) and gfortran (GNU).
C
C   Revision 1.4  2012-08-10 13:21:48  andrewl
C
C   10/08/2012 Andrew Lee
C              In the subroutine fun, the two nested loops (over 'LIKE')
C              have been replaced by one single loop. The inner loop ( in
C              PANDP, TRAN, MULSUM, ASUM, APACK) have been removed. This
C              ensures that the correct value of LIKE gets passed to APEN.
C
C   Revision 1.3  2012-08-01 14:33:10  andrewl
C
C   01/08/2012 Andrew Lee
C              Corrected a small mistake in RESCALE and RESCALE_2 that was
C              causing an infinity/NaN.
C              I had been using:
C              TMP = 1.D0 / AHI
C              ARRAY = ARRAY * TMP
C              I have changed it to
C              ARRAY = ARRAY / AHI
C              This will be slighly slower, but should be more robust.
C
C   Revision 1.2  2012-07-30 14:51:17  andrewl
C
C   30/07/2012 Andrew Lee
C              Replace the subroutine MULSUM with a version that uses BLAS.
C
C
C
C###############################################################################
C       COPYRIGHT 1984 BY KENNETH LANGE, AND 2012 ANDREW LEE.
C       DO NOT EDIT, COPY OR DISTRIBUTE WITHOUT EXPRESS PERMISSION OF THE ALL AUTHORS
C###############################################################################


      SUBROUTINE MENDEL(EXTRA,RARRAY,IARRAY,CARRAY,LNAME,LARRAY,ABSENT
     :,CONV,DP,XXRATE,XYRATE,COND,LENC,LENI,LENL,LENR,MXITER,MXLOCI
     :,MXSTEP,MXTWIN,NCNSTR,NCONV,NEXTRA,NPAR,NPOINT,NVAR,BASE,BATFIL
     :,LOCFIL,MUTLOC,OUTFIL,PEDFIL,TITLE,TRAVEL,XXSIGN,XYSIGN,ASYCV
     :,ECHO,LUMP,ORDERD,PMODE,STAND)
C
C     THIS SUBROUTINE IS THE REAL MAIN ROUTINE.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION EXTRA(NEXTRA),RARRAY(LENR)
      INTEGER IARRAY(LENI),COND,PARSIZ,PROBLM,UNIT1,UNIT2,UNIT3,UNIT4

      CHARACTER*8 CARRAY(LENC),LNAME(MXLOCI),BASE,BATFIL*40,LINE*78
     :,LOCFIL*40,MUTLOC,OUTFIL*40,PEDFIL*40,TITLE*40,TRAVEL,XXSIGN
     :,XYSIGN
      LOGICAL LARRAY(LENL),ASYCV,BATCH,ECHO,FULL,LUMP,LUMPED,ORDERD
     :,PMODE,STAND
      COMMON /SECRET/ PARSIZ,LUMPED
      DATA UNIT1,UNIT2,UNIT3,UNIT4/1,2,3,4/
C
      LUMPED=LUMP
      BATCH=BATFIL.NE.' '
C
C     WRITE OUT THE LOGO.
C
      IF (.NOT.BATCH) THEN
      CALL CLEAR(LINE)
      CALL LOGO(BATFIL,LINE,BATCH)
      END IF
C
      IF (BATCH) OPEN(UNIT=UNIT4,FILE=BATFIL,STATUS='OLD',ERR=1000)
C
C     CALL INPUT TO LET THE USER DEFINE A SEQUENCE OF PROBLEMS
C     AND TO READ IN THE LOCUS AND PEDIGREE DATA.
C
      CALL INPUT(EXTRA,RARRAY,IARRAY,CARRAY,LNAME,LARRAY,ABSENT
     :,XXRATE,XYRATE,COND,LENC,LENI,LENL,LENR,MAXPEO,MXITER,MXLOCI
     :,MXTWIN,NALTOT,NCNSTR,NCVAR,NEXTRA,NPAR,NPED,NPHSET,NPOINT,NPPEND
     :,NVAR,PROBLM,UNIT1,UNIT2,UNIT3,UNIT4,BASE,LINE,LOCFIL,MUTLOC
     :,OUTFIL,PEDFIL,TITLE,TRAVEL,XXSIGN,XYSIGN,ASYCV,BATCH,ECHO,ORDERD
     :,STAND)
C
C     SET START POINTS FOR ARRAYS TO BE CARVED OUT OF CARRAY, IARRARY,
C     AND LARRAY.  STOP IF THERE IS INSUFFICIENT SPACE.
C
      K2=MXLOCI+1
      IF (MXLOCI+NCVAR.GT.LENC) CALL ASTOP(UNIT3,'C','MENDEL')
      N2=MXLOCI+1
      N3=NCVAR+N2
      IF (MXLOCI+NCVAR+MXLOCI.GT.LENI) CALL ASTOP(UNIT3,'I','MENDEL')
      L2=MXLOCI+1
      L3=NCVAR+L2
      IF (MXLOCI+NCVAR+MXLOCI.GT.LENL) CALL ASTOP(UNIT3,'L','MENDEL')
      IF (NEXTRA.GT.LENR) CALL ASTOP(UNIT3,'R','MENDEL')
C
C     DO EACH USER DEFINED PROBLEM.
C
      DO 10 IPROB=1,PROBLM
C
C     RETRIEVE THE PROBLEM DEFINITION, THE LOCUS DATA, AND THE
C     PEDIGREE DATA.  REMEMBER TO REWIND THE FIRST SCRATCH UNIT.
C
      REWIND(UNIT1)
      CALL GETDAT(EXTRA,RARRAY,IARRAY,IARRAY(N2),IARRAY(N3),LNAME
     1,CARRAY,CARRAY(K2),LARRAY,LARRAY(L3),LARRAY(L2),XXRATE,XYRATE
     2,COND,IPROB,LENR,MAXALL,MAXPAR,MAXPEO,MAXPH,MAXTAB,MAXV,MAXVAR
     3,MCNSTR,MUTATE,MXITER,MXLOCI,NALTOT,NCNSTR,NCVAR,NEXTRA,NLOCI
     4,NPAR,NPOINT,NVAR,PROBLM,UNIT1,UNIT3,BASE,MUTLOC,TITLE,TRAVEL
     5,ASYCV,STAND)
      IF (LUMP) MAXALL=MAXALL+1
C
C     WRITE THE MENU OF PROBLEM CHOICES FOR THE CURRENT PROBLEM.
C
      WRITE(UNIT3,20)
 20   FORMAT(' ')
      FULL=IPROB.EQ.1
      CALL MENU(EXTRA,LNAME,XXRATE,XYRATE,COND,UNIT3,MXITER,MXLOCI
     1,NCNSTR,NEXTRA,NLOCI,NPAR,NPOINT,NVAR,IPROB,BASE,LINE,LOCFIL
     2,MUTLOC,OUTFIL,PEDFIL,TITLE,TRAVEL,XXSIGN,XYSIGN,ASYCV,ECHO
     3,FULL,STAND)
      IF (NLOCI.GT.5) THEN
      WRITE(UNIT3,20)
      LINE=' COMPLETE LIST OF LOCI IN PROBLEM:'
      WRITE(UNIT3,30) LINE
 30   FORMAT(A)
      DO 40 I=1,NLOCI,8
      K=3
      LINE=' '
      DO 50 J=I,MIN(I+7,NLOCI)
      LINE(K:K+7)=LNAME(J)
 50   K=K+9
 40   WRITE(UNIT3,30) LINE
      WRITE(UNIT3,20)
      END IF
C
C     CALL PREINF TO ORCHESTRATE THE INFERENCING AND THE COMPUTATION
C     OF THE INSTRUCTION VECTORS.  REMEMBER TO REWIND THE SECOND
C     SCRATCH UNIT.
C
      REWIND(UNIT2)
C
C     SET START POINTS FOR ARRAYS TO BE CARVED OUT OF RARRAY.
C
      MXWORK=MAX(MAXTAB,2*NPAR+1,NPOINT)
      M2=MAXALL*NLOCI+1
      M3=MAXPAR*MCNSTR+M2
      M4=MCNSTR+M3
      M5=MAXPAR+M4
      M6=MAXPAR+M5
      M7=MAXPAR+M6
      M8=MAXPAR*NPOINT+M7
      M9=MAXPAR*MAXPAR+M8
      M10=MAXPAR+M9
      M11=MAXPAR+M10
      M12=MAXPAR+M11
      M13=MAXPAR+M12
      PARSIZ=MAX(2*NPAR+1,NPOINT)
      M14=MAXPAR*PARSIZ+M13
      M15=MAXTAB*MAXTAB+M14
      M16=MAXV+M15
      MAXA=LENR-M16+1
*       write(*,*) maxa,lenr,m16
      LENRR=LENR-MAXALL*NLOCI
C
C     SET START POINTS FOR ARRAYS TO BE CARVED OUT OF IARRAY.
C
      N4=MAXPEO*NLOCI+N3
      N5=MAXPEO*NLOCI+N4
      N6=MAXPEO+N5
      N7=MAXPEO+N6
      N8=MAXPEO+N7
      N9=MAXPH+N8
      N10=NPHSET+N9
      N11=NPPEND+N10
      LENII=LENI-N11+1
      IF (LENII.LE.0) CALL ASTOP(UNIT3,'I','MENDEL')
C
      CALL PREINF(RARRAY,RARRAY(M2),IARRAY(N6),IARRAY(N11),IARRAY
     1,IARRAY(N7),IARRAY(N2),IARRAY(N3),IARRAY(N4),IARRAY(N5)
     2,IARRAY(N8),IARRAY(N9),IARRAY(N10),LNAME,LARRAY,LARRAY(L2)
     3,LENII,LENRR,MAXA,MAXALL,MAXGL,MAXI,MAXLST,MAXPEO,MAXPH
     4,MAXSIZ,MXWORK,NCVAR,NLOCI,NPED,NPHSET,NPPEND,NVAR,UNIT1
     5,UNIT2,UNIT3,LUMP,ORDERD,PMODE)
C
C     SET START POINTS FOR ARRAYS TO CARVED OUT OF IARRAY.
C
      MAXIW=MAX(3*MAXLST,4*MAXSIZ)
      N4=MAXPEO+N3
      N5=MAXGL+N4
      N6=MAXPEO*NLOCI+N5
      N8=MAXPEO+N6
      N9=MAXI+N8
      N11=MAXIW+N9
      N12=MAXPEO*NLOCI+N11
      N13=MAXPEO+N12
      N14=MAXPAR+N13
      IF (N13+MAXPEO-1.GT.LENI) CALL ASTOP(UNIT3,'I','MENDEL')
      IF (MAXPAR.GT.LENC) CALL ASTOP(UNIT3,'C','MENDEL')
C
C     NOW SET THE START POINTS FOR WORK1 AND WORK2.  THESE DEPEND ON
C     MXNGEN, THE MAXIMUM NUMBER OF GENOTYPES AT ANY LOCUS FOR ANY
C     PERSON.  MXWORK=MAX(MXNGEN,MXWORK) IS RETURNED FROM PREINF.
C     MAXA IS THE MAXIMUM SIZE NEEDED FOR THE BIG ARRAY.  THIS IS ALSO
C     RETURNED FROM PREINF.  CHECK THAT THERE IS ENOUGH SPACE TO
C     ACCOMODATE WORK1, WORK2, AND ARRAY.
C
      M17=MXWORK+M16
      M18=MXWORK+M17
*       write(*,*) lenr,m18,maxa,m16,m17,mxwork
      IF (LENR-M18+1.LT.MAX(7,MAXA)) then
*       write(*,*) 'Error0 ',lenr,m18,maxa
       CALL ASTOP(UNIT3,'R','MENDEL')
      endif
      MAXA=LENR-M18+1
C
C     INSERT INTO RARRAY THE CONSTANTS ABSENT, CONV, DP, XXRATE,
C     XYRATE, AND COND.  THIS IS NECESSARY BECAUSE SOME PC COMPILERS
C     CHOKE WHEN A SUBROUTINE HAS MORE THAN 63 ARGUMENTS.  IN
C     SUBROUTINE SEARCH THESE CONSTANTS WILL BE THE FIRST ENTRIES IN
C     ARRAY.
C
      RARRAY(M18)=ABSENT
      RARRAY(M18+1)=CONV
      RARRAY(M18+2)=DP
      RARRAY(M18+3)=XXRATE
      RARRAY(M18+4)=XYRATE
      RARRAY(M18+5)=DBLE(COND)
C
C     CALL SEARCH TO COMPUTE LOGLIKELIHOODS OVER A GRID OR TO
C     MAXIMIZE THE LOGLIKELIHOOD WITH RESPECT TO THE PARAMETERS.
C
 10   CALL SEARCH(RARRAY,RARRAY(M18),RARRAY(M2),RARRAY(M3),RARRAY(M4)
     1,RARRAY(M5),RARRAY(M6),EXTRA,RARRAY(M7),RARRAY(M8),RARRAY(M9)
     2,RARRAY(M10),RARRAY(M11),RARRAY(M12),RARRAY(M13),RARRAY(M14)
     3,RARRAY(M15),RARRAY(M16),RARRAY(M17),IARRAY(N4),IARRAY(N5)
     4,IARRAY(N6),IARRAY(N8),IARRAY(N9),IARRAY(N11),IARRAY(N12)
     5,IARRAY(N13),IARRAY(N14),CARRAY,LARRAY(L2),MAXA,MAXALL,MAXGL
     6,MAXI,MAXIW,MAXLST,MAXPAR,MAXPEO,MAXTAB,MAXV,MAXVAR,MCNSTR,MUTATE
     7,MXITER,MXSTEP,MXWORK,NCNSTR,NCONV,NEXTRA,NLOCI,NPAR,NPED,NPOINT
     8,NVAR,IPROB,UNIT2,UNIT3,BASE,TRAVEL,ASYCV,PMODE,STAND)
      CLOSE(UNIT1)
      CLOSE(UNIT2)
      CLOSE(UNIT3)
      CLOSE(UNIT4)
      RETURN

 1000 WRITE(UNIT3,'(/A)') '   BATCH FILE FOR MENDEL CANNOT BE OPENED.'
      END

      SUBROUTINE GETDAT(EXTRA,RARRAY,LCVAR,NALL,NTEMP,LNAME,LTEMP
     1,NAME,MENDEL,MTEMP,XLINK,XXRATE,XYRATE,COND,IPROB,LENR,MAXALL
     2,MAXPAR,MAXPEO,MAXPH,MAXTAB,MAXV,MAXVAR,MCNSTR,MUTATE,MXITER
     3,MXLOCI,NALTOT,NCNSTR,NCVAR,NEXTRA,NLOCI,NPAR,NPOINT,NVAR
     4,PROBLM,UNIT1,UNIT3,BASE,MUTLOC,TITLE,TRAVEL,ASYCV,STAND)
C
C     THIS SUBROUTINE READS IN FROM A SCRATCH UNIT THE PROBLEM
C     CHOICES FOR THE CURRENT PROBLEM AND A DESCRIPTION OF EACH
C     RELEVANT LOCUS.  TO AVOID HAVING A SEPARATE SCRATCH UNIT
C     FOR PROBLEM CHOICES IT IS NECESSARY TO READ THE INFORMATION
C     FOR ALL PROBLEMS AT EACH PARTICULAR PROBLEM.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION EXTRA(NEXTRA),RARRAY(LENR)
      INTEGER LCVAR(MXLOCI),NALL(NCVAR),NTEMP(MXLOCI),COND,PROBLM
     1,UNIT1,UNIT3
      CHARACTER*8 LNAME(MXLOCI),LTEMP(MXLOCI),NAME(NCVAR),BASE,BTEMP
     1,MUTLOC,MUTEMP,TITLE*40,TITEMP*40,TRAVEL,TRTEMP
      LOGICAL MENDEL(MXLOCI),MTEMP(MXLOCI),XLINK(NCVAR),ASYCV,ATEMP
     1,STAND,STTEMP
C
C     READ THE PROBLEM CHOICES, BUT RETAIN ONLY THOSE FOR THE CURRENT
C     PROBLEM.
C
      MUTLOC=' '
      MUTATE=0
      DO 10 I=1,PROBLM
      READ(UNIT1) TITEMP,I2,LTEMP,MUTEMP
      READ(UNIT1) XX,XY,I3,BTEMP,STTEMP,TRTEMP
      READ(UNIT1) I4,I5,I6,ATEMP,I7
      CALL RSCRAT(RARRAY,NEXTRA,UNIT1,.FALSE.)
      IF (I.EQ.IPROB) THEN
      TITLE=TITEMP
      NLOCI=I2
      DO 20 J=1,NLOCI
      LNAME(J)=LTEMP(J)
      IF (MUTEMP.EQ.LNAME(J).OR.MUTEMP.EQ.'ALL_LOCI') THEN
      MUTLOC=MUTEMP
      MUTATE=J
      MENDEL(J)=.FALSE.
      ELSE
      MENDEL(J)=.TRUE.
      END IF
 20   CONTINUE
      XXRATE=XX
      XYRATE=XY
      COND=I3
      BASE=BTEMP
      STAND=STTEMP
      TRAVEL=TRTEMP
      NPOINT=I4
      NPAR=I5
      NCNSTR=I6
      ASYCV=ATEMP
      MXITER=I7
      DO 30 J=1,NEXTRA
 30   EXTRA(J)=RARRAY(J)
      END IF
 10   CONTINUE
C
C     FOR EACH LOCUS IN THE LOCUS FILE, READ ITS NAME, AUTOSOMAL VERSUS
C     X-LINKED STATUS, AND ITS NUMBER OF ALLELES.
C
      READ(UNIT1) NAME
      READ(UNIT1) XLINK
      CALL ISCRAT(NALL,NCVAR,UNIT1,.FALSE.)
C
C     IDENTIFY WHICH LOCI ARE ACTUALLY IN THE PROBLEM.  STORE THIS
C     INFORMATION IN LCVAR.  FOR EACH SUCH LOCUS RETAIN ITS NUMBER
C     OF ALLELES AND AUTOSOMAL VERSUS X-LINKED STATUS.  ALSO COMPUTE
C     THE MAXIMUM NUMBER OF ALLELES AT ANY LOCUS.
C
      MAXALL=1
      DO 40 LOCUS=1,NLOCI
      NMATCH=0
      DO 50 I=1,NCVAR
      IF (LNAME(LOCUS).EQ.NAME(I)) THEN
      NMATCH=NMATCH+1
      MAXALL=MAX(MAXALL,NALL(I))
      LCVAR(LOCUS)=I
      NTEMP(LOCUS)=NALL(I)
      MTEMP(LOCUS)=XLINK(I)
      END IF
 50   CONTINUE
      IF (NMATCH.EQ.0.OR.NMATCH.GE.2) THEN
      WRITE(UNIT3,60) IPROB,LNAME(LOCUS)
 60   FORMAT(' *** ERROR *** IN PROBLEM',I3,'.  LOCUS ',A8,' IS NOT IN'
     1,' THE LOCUS FILE OR IS PRESENT THERE MULTIPLE TIMES.')
      CALL EXIT( 1 )

      END IF
 40   CONTINUE
C
C     NOW READ THE ALLELE FREQUENCIES.  SHIFT THE ALLELE FREQENCIES
C     RELEVANT TO THE CURRENT PROBLEM SO THEY CAN ULTIMATELY BE STORED
C     IN A TWO DIMENSIONAL ARRAY.
C
      CALL RSCRAT(RARRAY,NALTOT,UNIT1,.FALSE.)
      M=MAX(NALTOT,MAXALL*NLOCI)
      IF (M+M.GT.LENR) CALL ASTOP(UNIT3,'R','GETDAT')
      DO 70 LOCUS=1,NLOCI
      N=0
      L=LCVAR(LOCUS)
      DO 80 I=1,L-1
 80   N=N+NALL(I)
      NA=NALL(L)
      DO 90 J=1,NA
 90   RARRAY(M+(J-1)*NLOCI+LOCUS)=RARRAY(N+J)
 70   CONTINUE
C
C     STORE THE NUMBER OF ALLELES AND AUTOSOMAL VERSUS X-LINKED
C     STATUS IN NALL AND XLINK.
C
      DO 100 LOCUS=1,NLOCI
      NALL(LOCUS)=NTEMP(LOCUS)
 100  XLINK(LOCUS)=MTEMP(LOCUS)
C
C     NOW SHIFT THE ALLELE FREQUENCIES BACK SO THAT THE FIRST
C     BLOCK OF RARRAY CONTAINS ALLFRQ(NLOCI,MAXALL) WITH THE
C     FREQUENCIES ACCESSIBLE IN THE CORRECT ORDER.
C
      DO 110 LOCUS=1,NLOCI
      NA=NALL(LOCUS)
      DO 110 J=1,NA
 110  RARRAY((J-1)*NLOCI+LOCUS)=RARRAY(M+(J-1)*NLOCI+LOCUS)
C
C     TAKE THIS OPPORTUNITY TO SET SEVERAL ARRAY SIZES.
C
      MAXPAR=MAX(NPAR,1)
      MAXPH=MAXPEO*NCVAR
      MAXTAB=NCNSTR+NPAR+1
      MAXV=MAX(MAXPEO*NVAR,1)
      MAXVAR=MAX(NVAR,1)
      MCNSTR=MAX(NCNSTR,1)
      IF (TRAVEL(1:1).EQ.'S') NPOINT=1
      END

      SUBROUTINE ASTOP(LOUT,C,WHERE)
C
C     THIS SUBROUTINE STOPS THE PROGRAM BECAUSE OF INSUFFICIENT SPACE.
C
      CHARACTER C,NAME*7,WHERE*6
C
      NAME='  ARRAY'
      NAME(2:2)=C
      WRITE(LOUT,10) WHERE,NAME
 10   FORMAT(' *** ERROR *** THE PROGRAM HAS STOPPED IN SUBROUTINE '
     1,A6,' BECAUSE',A7,' IS TOO SMALL.')
      CALL EXIT( 2 )
      END

      SUBROUTINE ISCRAT(STUFF,LEN,SCRAT,RITE)
C
C     THIS SUBROUTINE PASSES THE ARRAY STUFF TO SUBROUTINE
C     SCRATI IN CONVENIENTLY SIZED BLOCKS.  ON AN IBM PC THESE
C     BLOCKS HAVE 512 INTEGER*2 ENTRIES.  FOR INTEGER*4 IT WOULD
C     BE 256 ENTRIES.
C
      INTEGER STUFF(LEN),SCRAT
      LOGICAL RITE
C
      DO 10 M=1,LEN,256
      N=MIN(LEN-M+1,256)
 10   CALL SCRATI(STUFF(M),N,SCRAT,RITE)
      END

      SUBROUTINE SCRATI(STUFF,LEN,SCRAT,RITE)
C
C     THIS SUBROUTINE WRITES OR READS THE INTEGER ARRAY
C     STUFF ON OR FROM SCRATCH UNIT SCRAT.
C
      INTEGER STUFF(LEN),SCRAT
      LOGICAL RITE
C
      IF (RITE) THEN
      WRITE(SCRAT) STUFF
      ELSE
      READ(SCRAT) STUFF
      END IF
      END

      SUBROUTINE RSCRAT(STUFF,LEN,SCRAT,RITE)
C
C     THIS SUBROUTINE PASSES THE ARRAY STUFF TO SUBROUTINE
C     SCRATR IN CONVENIENTLY SIZED BLOCKS.  ON AN IBM PC THESE
C     BLOCKS HAVE 128 REAL*8 ENTRIES.
C
      DOUBLE PRECISION STUFF(LEN)
      INTEGER SCRAT
      LOGICAL RITE
C
      DO 10 M=1,LEN,128
      N=MIN(LEN-M+1,128)
 10   CALL SCRATR(STUFF(M),N,SCRAT,RITE)
      END

      SUBROUTINE SCRATR(STUFF,LEN,SCRAT,RITE)
C
C     THIS SUBROUTINE WRITES OR READS THE DOUBLE PRECISION
C     ARRAY STUFF ON OR FROM SCRATCH UNIT SCRAT.
C
      DOUBLE PRECISION STUFF(LEN)
      INTEGER SCRAT
      LOGICAL RITE
C
      IF (RITE) THEN
      WRITE(SCRAT) STUFF
      ELSE
      READ(SCRAT) STUFF
      END IF
      END

      SUBROUTINE LOGO(BATFIL,LINE,BATCH)
C
C     THIS SUBROUTINE WRITES A LOGO FOR MENDEL.
C
      CHARACTER ANSWER*8,BATFIL*40,LINE*78
      LOGICAL BATCH
C
      LINE=' '
      LINE(15:)='        WELCOME TO MENDEL, VERSION 3.3.        '
      WRITE(*,'(/A)') LINE
      LINE(15:)='PROGRAMMED BY KENNETH LANGE AND MICHAEL BOEHNKE'
      WRITE(*,'(/A)') LINE
      LINE(15:)='    (c) COPYRIGHT KENNETH LANGE, 1985-1993     '
      WRITE(*,'(/A)') LINE
 10   WRITE(*,20)
 20   FORMAT(///////
     :,'   DO YOU WISH TO CHANGE TO BATCH MODE? [YES/NO]: ',$)
CB      READ(*,'(A)',ERR=10) ANSWER
      ANSWER="NO"
      CALL MBLANK(ANSWER)
      IF (ANSWER(1:1).EQ.'Y'.OR.ANSWER(1:1).EQ.'y') THEN
      WRITE(*,30)
 30   FORMAT(/,'   ENTER NAME OF BATCH FILE: ',$)
      READ(*,'(A)') BATFIL
      BATCH=.TRUE.
      END IF
      END

      SUBROUTINE INPUT(EXTRA,RARRAY,IARRAY,CARRAY,LNAME,LARRAY,ABSENT
     :,XXRATE,XYRATE,COND,LENC,LENI,LENL,LENR,MAXPEO,MXITER,MXLOCI
     :,MXTWIN,NALTOT,NCNSTR,NCVAR,NEXTRA,NPAR,NPED,NPHSET,NPOINT,NPPEND
     :,NVAR,PROBLM,UNIT1,UNIT2,UNIT3,UNIT4,BASE,LINE1,LOCFIL,MUTLOC
     :,OUTFIL,PEDFIL,TITLE,TRAVEL,XXSIGN,XYSIGN,ASYCV,BATCH,ECHO,ORDERD
     :,STAND)
C
C     THIS SUBROUTINE CONTROLS PROBLEM SELECTION AND THE READING
C     OF THE LOCUS AND PEDIGREE FILES.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION EXTRA(NEXTRA),RARRAY(LENR)
      INTEGER IARRAY(LENI),COND,PROBLM,UNIT1,UNIT2,UNIT3,UNIT4
      CHARACTER*8 CARRAY(LENC),LNAME(MXLOCI),BASE,LINE1*78,LINE2*78
     1,LOCFIL*40,MUTLOC,OUTFIL*40,PEDFIL*40,TITLE*40,TRAVEL,XXSIGN
     2,XYSIGN
      LOGICAL LARRAY(LENL),ASYCV,BATCH,ECHO,ORDERD,STAND
C
C     COMPUTE THE NUMBER OF LOCI FOR THE FIRST PROBLEM.
C
      NLOCI=0
      DO 10 LOCUS=1,MXLOCI
      CALL UPCASE(LNAME(LOCUS))
      CALL MBLANK(LNAME(LOCUS))
 10   IF (LNAME(LOCUS).NE.' ') NLOCI=NLOCI+1
C
C     OPEN A SCRATCH FILE TO RECORD THE PROBLEM CHOICES.  THEN
C     CALL CHOICE TO LET THE USER CHOOSE.
C
      OPEN(UNIT1,STATUS='SCRATCH',FORM='UNFORMATTED')
      CALL CHOICE(EXTRA,LNAME,XXRATE,XYRATE,COND,MXITER,MXLOCI
     :,NCNSTR,NEXTRA,NLOCI,NPAR,NPOINT,NVAR,PROBLM,UNIT1,UNIT4,BASE
     :,LINE1,LOCFIL,MUTLOC,OUTFIL,PEDFIL,TITLE,TRAVEL,XXSIGN,XYSIGN
     :,ASYCV,BATCH,ECHO,STAND)
C
C     OPEN THE OUTPUT AND LOCUS FILES.  THEN CALL LFILE1 TO READ THE
C     LOCUS FILE AND CHECK IT FOR ERRORS.
C
      OPEN(UNIT3,FILE=OUTFIL,STATUS='UNKNOWN')
      OPEN(UNIT2,FILE=LOCFIL,STATUS='OLD',ERR=20)
      REWIND(UNIT2)
      GO TO 30
 20   WRITE(UNIT3,40)
 40   FORMAT(/,' *** ERROR *** THE PROGRAM HAS STOPPED BECAUSE'
     1,'OF A FAILURE TO OPEN THE LOCUS FILE.')
      CALL EXIT( 3 )

C
 30   CALL LFILE1(RARRAY,IARRAY,CARRAY,LARRAY,LENC,LENI,LENL
     1,LENR,NALTOT,NCVAR,NPHSET,NPPEND,UNIT1,UNIT2,UNIT3,ECHO,ORDERD)
C
C     CLOSE THE LOCUS FILE AND OPEN THE PEDIGREE FILE.  THEN
C     CALL PREPED TO READ THE PEDIGREE FILE AND CHECK FOR ERRORS.
C
      CLOSE(UNIT2)
      OPEN(UNIT2,FILE=PEDFIL,STATUS='OLD',ERR=50)
      REWIND(UNIT2)
      GO TO 60
C
 50   WRITE(UNIT3,70)

 70   FORMAT(/,' *** ERROR *** THE PROGRAM HAS STOPPED BECAUSE'
     1,' OF A FAILURE TO OPEN THE PEDIGREE FILE.')
      CALL EXIT( 4 )
C
 60   K2=NALTOT+1
      K3=NCVAR+K2
      K4=NPPEND+K3
      N2=NCVAR+1
      N3=NCVAR+N2
      CALL PREPED(RARRAY,IARRAY(N3),IARRAY,IARRAY(N2),CARRAY
     1,CARRAY(K4),CARRAY(K2),CARRAY(K3),ABSENT,LENC,LENI,LENR
     2,MAXPEO,MXTWIN,NALTOT,NCVAR,NPED,NPPEND,NVAR,UNIT1,UNIT2
     3,UNIT3,LINE1,LINE2,XYSIGN,XXSIGN,ECHO,ORDERD)
C
C     OPEN THE SECOND SCRATCH FILE.  THIS WILL HOLD THE INFORMATION
C     NECESSARY TO COMPUTE THE LIKELIHOODS FOR EACH PEDIGREE.  THE
C     FIRST SCRATCH FILE WILL BE READ TO DEFINE A PROBLEM.  THE
C     SECOND SCRATCH FILE WILL BE READ MUTIPLE TIMES PER PROBLEM.
C
      CLOSE(UNIT2)
      OPEN(UNIT2,STATUS='SCRATCH',FORM='UNFORMATTED')
      END

      SUBROUTINE CHOICE(EXTRA,LNAME,XXRATE,XYRATE,COND,MXITER,MXLOCI
     :,NCNSTR,NEXTRA,NLOCI,NPAR,NPOINT,NVAR,PROBLM,UNIT1,UNIT4,BASE
     :,LINE,LOCFIL,MUTLOC,OUTFIL,PEDFIL,TITLE,TRAVEL,XXSIGN,XYSIGN
     :,ASYCV,BATCH,ECHO,STAND)
C
C     THIS SUBROUTINE ALLOWS THE USER TO CHANGE THE DEFAULT DATA INPUT
C     AND MODEL CHOICES.  AFTER EACH PROBLEM HAS BEEN DEFINED, THE
C     CHOICES ARE WRITTEN TO A SCRATCH FILE.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION EXTRA(NEXTRA)
      INTEGER COND,PROBLM,UNIT1,UNIT4
      CHARACTER*8 LNAME(MXLOCI),ANSWER,BASE,LINE*78,LOCFIL*40
     :,MUTLOC,OUTFIL*40,PEDFIL*40,TITLE*40,TRAVEL,XXSIGN,XYSIGN
      LOGICAL ASYCV,BATCH,ECHO,FULL,STAND
C
C     PROBLM KEEPS TRACK OF THE PROBLEM NUMBER.  FULL DETERMINES WHAT
C     PART OF THE MENU IS WRITTEN.
C
      PROBLM=1
C
C     CLEAR THE SCREEN AND PRINT THE MENU.
C
 1000 IF (.NOT.BATCH) THEN
      CALL CLEAR(LINE)
      FULL=PROBLM.EQ.1
      CALL MENU(EXTRA,LNAME,XXRATE,XYRATE,COND,-1,MXITER,MXLOCI
     1,NCNSTR,NEXTRA,NLOCI,NPAR,NPOINT,NVAR,PROBLM,BASE,LINE,LOCFIL
     2,MUTLOC,OUTFIL,PEDFIL,TITLE,TRAVEL,XXSIGN,XYSIGN,ASYCV,ECHO
     3,FULL,STAND)
      END IF
 510  FORMAT(A)
      LINE=' 21 ACCEPT PROBLEM'
      IF (.NOT.BATCH) WRITE(*,510) LINE
      IF (.NOT.BATCH) WRITE(*,520)
 520  FORMAT(/,' CHOOSE AN ITEM [1,...,21]: ',$)
C
C     LET THE USER CHOOSE AN ITEM AND CHANGE IT.
C
CB    IF (.NOT.BATCH) READ(*,530,ERR=1000) ITEM
      ITEM=21
      IF (BATCH) READ(UNIT4,530,ERR=1000) ITEM
 530  FORMAT(I6)
      IF (ITEM.LT.1.OR.ITEM.GT.21) GO TO 1000
      GO TO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
     1,21),ITEM
 1    IF (.NOT.BATCH) WRITE(*,540)
 540  FORMAT(' NEW VALUE: ',$)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) TITLE
      IF (BATCH) READ(UNIT4,510,ERR=1000) TITLE
      GO TO 1000
 2    IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) LOCFIL
      IF (BATCH) READ(UNIT4,510,ERR=1000) LOCFIL
      GO TO 1000
 3    IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) PEDFIL
      IF (BATCH) READ(UNIT4,510,ERR=1000) PEDFIL
      GO TO 1000
 4    IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) OUTFIL
      IF (BATCH) READ(UNIT4,510,ERR=1000) OUTFIL
      GO TO 1000
 5    ECHO=.NOT.ECHO
      GO TO 1000
 6    IF (.NOT.BATCH) WRITE(*,550)
 550  FORMAT(' FEMALE SYMBOL: ',$)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) XXSIGN
      IF (BATCH) READ(UNIT4,510,ERR=1000) XXSIGN
      IF (.NOT.BATCH) WRITE(*,560)
 560  FORMAT(' MALE SYMBOL: ',$)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) XYSIGN
      IF (BATCH) READ(UNIT4,510,ERR=1000) XYSIGN
      GO TO 1000
 7    IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,530,ERR=1000) NVAR
      IF (BATCH) READ(UNIT4,530,ERR=1000) NVAR
      GO TO 1000
 8    DO 30 I=1,NEXTRA
      IF (.NOT.BATCH) WRITE(*,570) I
 570  FORMAT(' NEW VALUE FOR CONSTANT NUMBER',I3,': ',$)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) ANSWER
      IF (BATCH) READ(UNIT4,510,ERR=1000) ANSWER
      CALL MBLANK(ANSWER)
      IF (ANSWER(1:1).EQ.' ') GO TO 1000
      CALL VERIFY(ANSWER,'0123456789 ',K)
      L=INDEX(ANSWER,' ')
      IF (K.EQ.0.AND.L.NE.0) ANSWER(L:L)='.'
 30   READ(ANSWER,'(F8.0)') EXTRA(I)
      GO TO 1000
 9    NLOCI=0
      DO 40 I=1,MXLOCI
      IF (.NOT.BATCH) WRITE(*,580) I
 580  FORMAT(' NAME OF LOCUS ',I2,': ',$)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) LNAME(I)
      IF (BATCH) READ(UNIT4,510,ERR=1000) LNAME(I)
      CALL UPCASE(LNAME(I))
      CALL MBLANK(LNAME(I))
      IF (LNAME(I)(1:1).EQ.' ') GO TO 1000
 40   NLOCI=NLOCI+1
      GO TO 1000
 10   IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,510,ERR=1000) MUTLOC
      IF (BATCH) READ(UNIT4,510,ERR=1000) MUTLOC
      CALL UPCASE(MUTLOC)
      CALL MBLANK(MUTLOC)
      GO TO 1000
 11   IF (.NOT.BATCH) WRITE(*,590)
 590  FORMAT(' FEMALE MUTATION RATE: ',$)
      IF (.NOT.BATCH) READ(*,600,ERR=1000) XXRATE
      IF (BATCH) READ(UNIT4,600,ERR=1000) XXRATE
 600  FORMAT(D15.8)
      IF (.NOT.BATCH) WRITE(*,610)
 610  FORMAT(' MALE MUTATION RATE: ',$)
      IF (.NOT.BATCH) READ(*,600,ERR=1000) XYRATE
      IF (BATCH) READ(UNIT4,600,ERR=1000) XYRATE
      GO TO 1000
 12   IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,530,ERR=1000) COND
      IF (BATCH) READ(UNIT4,530,ERR=1000) COND
      GO TO 1000
 13   CALL MBLANK(BASE)
      IF (BASE.EQ.'E'.OR.BASE.EQ.'e') THEN
      BASE='10'
      ELSE
      BASE='E'
      END IF
      GO TO 1000
 14   STAND=.NOT.STAND
      GO TO 1000
 15   CALL MBLANK(TRAVEL)
      CALL UPCASE(TRAVEL)
      IF (TRAVEL.EQ.'GRID') THEN
      TRAVEL='SEARCH'
      ELSE
      TRAVEL='GRID'
      END IF
      GO TO 1000
 16   IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,530,ERR=1000) NPOINT
      IF (BATCH) READ(UNIT4,530,ERR=1000) NPOINT
      GO TO 1000
 17   IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,530,ERR=1000) NPAR
      IF (BATCH) READ(UNIT4,530,ERR=1000) NPAR
      GO TO 1000
 18   IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,530,ERR=1000) NCNSTR
      IF (BATCH) READ(UNIT4,530,ERR=1000) NCNSTR
      GO TO 1000
 19   ASYCV=.NOT.ASYCV
      GO TO 1000
 20   IF (.NOT.BATCH) WRITE(*,540)
      IF (.NOT.BATCH) READ(*,530,ERR=1000) MXITER
      IF (BATCH) READ(UNIT4,530,ERR=1000) MXITER
      GO TO 1000
C
C     WRITE CHOICES ON THE SCRATCH FILE AFTER MAKING SURE THEY
C     ARE WITHIN THE PROPER BOUNDS.
C
 21   CALL MBLANK(BASE)
      IF (BASE.NE.'E'.AND.BASE.NE.'e') BASE='10'
      CALL MBLANK(TRAVEL)
      IF (TRAVEL(1:1).NE.'G'.AND.TRAVEL(1:1).NE.'g') THEN
      TRAVEL='SEARCH'
      ELSE
      TRAVEL='GRID'
      END IF
      NVAR=MAX(NVAR,0)
      NLOCI=MAX(NLOCI,1)
      NPOINT=MAX(NPOINT,1)
      NPAR=MAX(NPAR,0)
      NCNSTR=MAX(NCNSTR,0)
      MXITER=MAX(MXITER,1)
      WRITE(UNIT1) TITLE,NLOCI,LNAME,MUTLOC
      WRITE(UNIT1) XXRATE,XYRATE,COND,BASE,STAND,TRAVEL
      WRITE(UNIT1) NPOINT,NPAR,NCNSTR,ASYCV,MXITER
      CALL RSCRAT(EXTRA,NEXTRA,UNIT1,.TRUE.)
C
C     CHECK IF THE USER WANTS TO DEFINE ANOTHER PROBLEM.
C
 50   IF (.NOT.BATCH) WRITE(*,620)
 620  FORMAT(' ANOTHER PROBLEM [YES/NO]: ',$)
CB    IF (.NOT.BATCH) READ(*,510,ERR=50) ANSWER
      ANSWER="NO"
      IF (BATCH) READ(UNIT4,510,ERR=50) ANSWER
      CALL MBLANK(ANSWER)
      IF (ANSWER(1:1).EQ.'Y'.OR.ANSWER(1:1).EQ.'y') THEN
      PROBLM=PROBLM+1
      GO TO 1000
      END IF
      END

      SUBROUTINE MENU(EXTRA,LNAME,XXRATE,XYRATE,COND,LOUT,MXITER
     :,MXLOCI,NCNSTR,NEXTRA,NLOCI,NPAR,NPOINT,NVAR,PROBLM,BASE,LINE
     :,LOCFIL,MUTLOC,OUTFIL,PEDFIL,TITLE,TRAVEL,XXSIGN,XYSIGN,ASYCV
     ;,ECHO,FULL,STAND)
C
C     THIS SUBROUTINE WRITES A MENU SPECIFYING DATA INPUT AND MODEL
C     CHOICES.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION EXTRA(NEXTRA)
      INTEGER COND,PROBLM
      CHARACTER*8 LNAME(MXLOCI),BASE,LINE*78,LOCFIL*40,MUTLOC
     :,OUTFIL*40,PEDFIL*40,TEMP,TITLE*40,TRAVEL,XXSIGN,XYSIGN
      LOGICAL ASYCV,ECHO,FULL,STAND
      PARAMETER(M=40)
C
      LINE='  0 PROBLEM NUMBER'
      WRITE(TEMP,'(I6)') PROBLM
      CALL MBLANK(TEMP)
      LINE(M:)=TEMP
      CALL RITE(LOUT,LINE)
      LINE='  1 TITLE'
      LINE(M:)=TITLE
      CALL RITE(LOUT,LINE)
      IF (FULL) THEN
      LINE='  2 LOCUS FILE'
      LINE(M:)=LOCFIL
      CALL RITE(LOUT,LINE)
      LINE='  3 PEDIGREE FILE'
      LINE(M:)=PEDFIL
      CALL RITE(LOUT,LINE)
      LINE='  4 OUTPUT FILE'
      LINE(M:)=OUTFIL
      CALL RITE(LOUT,LINE)
      LINE='  5 ECHO LOCUS AND PEDIGREE FILES'
      CALL YESNO(M,LINE,ECHO)
      CALL RITE(LOUT,LINE)
      LINE='  6 FEMALE AND MALE SYMBOLS'
      CALL MBLANK(XXSIGN)
      CALL MBLANK(XYSIGN)
      LINE(M:M+7)=XXSIGN
      LINE(M+8:)=XYSIGN
      CALL RITE(LOUT,LINE)
      LINE='  7 NUMBER OF QUANTITATIVE VARIABLES'
      WRITE(TEMP,'(I6)') NVAR
      CALL MBLANK(TEMP)
      LINE(M:)=TEMP
      CALL RITE(LOUT,LINE)
      END IF
      K=M
      LINE='  8 EXTRA CONSTANTS FOR PROBLEM'
      DO 10 I=1,MIN(NEXTRA,5)
      WRITE(TEMP,'(G8.2E1)') EXTRA(I)
      CALL MBLANK(TEMP)
      LINE(K:K+7)=TEMP
 10   K=K+8
      CALL RITE(LOUT,LINE)
      K=M
      LINE='  9 NAMES OF LOCI IN PROBLEM'
      DO 20 I=1,MIN(NLOCI,5)
      LINE(K:K+7)=LNAME(I)
 20   K=K+8
      CALL RITE(LOUT,LINE)
      LINE=' 10 NAME OF MUTABLE LOCUS IN PROBLEM'
      CALL UPCASE(MUTLOC)
      CALL MBLANK(MUTLOC)
      LINE(M:)=MUTLOC
      CALL RITE(LOUT,LINE)
      IF (MUTLOC(1:1).NE.' ') THEN
      LINE=' 11 FEMALE AND MALE MUTATION RATES'
      WRITE(TEMP,'(D8.2)') XXRATE
      CALL MBLANK(TEMP)
      LINE(M:M+7)=TEMP
      LINE(M+8:M+9)='  '
      WRITE(TEMP,'(D8.2)') XYRATE
      CALL MBLANK(TEMP)
      LINE(M+10:)=TEMP
      CALL RITE(LOUT,LINE)
      END IF
      LINE=' 12 PEDIGREE TO CONDITION ON'
      WRITE(TEMP,'(I6)') COND
      CALL MBLANK(TEMP)
      LINE(M:)=TEMP
      CALL RITE(LOUT,LINE)
      LINE=' 13 BASE FOR LOGLIKELIHOODS'
      CALL UPCASE(BASE)
      CALL MBLANK(BASE)
      LINE(M:)=BASE
      CALL RITE(LOUT,LINE)
      LINE=' 14 STANDARDIZE LOGLIKELIHOODS'
      CALL YESNO(M,LINE,STAND)
      CALL RITE(LOUT,LINE)
      LINE=' 15 GRID OR SEARCH OPTION'
      CALL MBLANK(TRAVEL)
      LINE(M:)=TRAVEL
      CALL RITE(LOUT,LINE)
      IF (TRAVEL.EQ.'GRID') THEN
      LINE=' 16 NUMBER OF GRID POINTS'
      WRITE(TEMP,'(I6)') NPOINT
      CALL MBLANK(TEMP)
      LINE(M:)=TEMP
      CALL RITE(LOUT,LINE)
      END IF
      LINE=' 17 NUMBER OF PARAMETERS'
      WRITE(TEMP,'(I6)') NPAR
      CALL MBLANK(TEMP)
      LINE(M:)=TEMP
      CALL RITE(LOUT,LINE)
      IF (TRAVEL.EQ.'SEARCH') THEN
      LINE=' 18 NUMBER OF CONSTRAINTS'
      WRITE(TEMP,'(I6)') NCNSTR
      CALL MBLANK(TEMP)
      LINE(M:)=TEMP
      CALL RITE(LOUT,LINE)
      LINE=' 19 ASYMPTOTIC STANDARD ERRORS'
      CALL YESNO(M,LINE,ASYCV)
      CALL RITE(LOUT,LINE)
      LINE=' 20 MAXIMUM NUMBER OF ITERATIONS'
      WRITE(TEMP,'(I6)') MXITER
      CALL MBLANK(TEMP)
      LINE(M:)=TEMP
      CALL RITE(LOUT,LINE)
      END IF
      END

      SUBROUTINE UPCASE(STRING)
C
C     THIS SUBROUTINE CONVERTS LOWER CASE LETTERS INTO UPPER CASE
C     LETTERS.
C
      CHARACTER STRING*(*)
C
      M=ICHAR('a')
      N=ICHAR('A')
      DO 10 I=1,LEN(STRING)
      J=ICHAR(STRING(I:I))-M
 10   IF (J.GE.0.AND.J.LE.25) STRING(I:I)=CHAR(N+J)
      END

      SUBROUTINE VERIFY(TEXT,STRING,N)
C
C     THIS SUBROUTINE VERIFIES THAT TEXT CONSISTS OF ONLY CHARACTERS
C     FROM STRING.
C
      INTEGER N
      CHARACTER STRING*(*),TEXT*(*)
C
      N=0
      DO 10 I=1,LEN(TEXT)
      IF (INDEX(STRING,TEXT(I:I)).EQ.0) THEN
      N=I
      RETURN
      END IF
 10   CONTINUE
      END

      SUBROUTINE MBLANK(STRING)
C
C     THIS SUBROUTINE MOVES ALL BLANKS IN A CHARACTER STRING TO
C     THE RIGHT END OF THE STRING.
C
      CHARACTER C*1,STRING*(*)
C
      I=1
      DO 10 J=1,LEN(STRING)
      IF (STRING(J:J).NE.' ') THEN
      C=STRING(I:I)
      STRING(I:I)=STRING(J:J)
      STRING(J:J)=C
      I=I+1
      END IF
 10   CONTINUE
      END

      SUBROUTINE CLEAR(ASCII)
C
C     THIS SUBROUTINE CLEARS AN ANSI DRIVEN SCREEN.
C
      CHARACTER*7 ASCII
C
      ASCII(1:1)=CHAR(27)
      ASCII(2:2)=CHAR(91)
      ASCII(3:3)=CHAR(50)
      ASCII(4:4)=CHAR(74)
      ASCII(5:5)=CHAR(27)
      ASCII(6:6)=CHAR(91)
      ASCII(7:7)=CHAR(72)
      WRITE(*,*) ASCII
      END

      SUBROUTINE YESNO(M,LINE,DECIDE)
C
C     THIS SUBROUTINE INSERTS A 'YES' OR 'NO' INTO THE GIVEN LINE.
C
      CHARACTER LINE*(*)
      LOGICAL DECIDE
C
      IF (DECIDE) THEN
      LINE(M:)='YES'
      ELSE
      LINE(M:)='NO'
      END IF
      END

      SUBROUTINE RITE(LOUT,LINE)
C
C     THIS SUBROUTINE WRITES OUT A LINE.
C
      CHARACTER LINE*78
C
      IF (LOUT.GE.0) THEN
      WRITE(LOUT,'(A)') LINE
      ELSE
      WRITE(*,'(A)') LINE
      END IF
      END

      SUBROUTINE LFILE1(RARRAY,IARRAY,CARRAY,LARRAY,LENC,LENI,LENL
     1,LENR,NALTOT,NCVAR,NPHSET,NPPEND,UNIT1,UNIT2,UNIT3,ECHO,ORDERD)
C
C     THIS SUBROUTINE READS THE LOCUS FILE TO COMPUTE SOME ARRAY
C     SIZES AND TO DETECT SOME ERRORS.  IT THEN CALLS LFILE2 FOR A
C     SECOND PASS THROUGH THE FILE.  ON THE SECOND PASS, FURTHER
C     ERRORS ARE DETECTED AND THE DATA ARE WRITTEN TO A SCRATCH FILE.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION RARRAY(LENR)
      INTEGER IARRAY(LENI),UNIT1,UNIT2,UNIT3
      CHARACTER*8 CARRAY(LENC),ALLELE,CHROMO,GTYPE*17,NAME,PHENO
      LOGICAL LARRAY(LENL),ECHO,ORDERD
C
      MNALL=1
      NALTOT=0
      NCVAR=0
      NPHSET=0
      NPPEND=1
C
C     READ IN THE LOCUS NAME, WHETHER IT IS X-LINKED, AND HOW MANY
C     ALLELES AND PHENOTYPES IT HAS.
C
 130  READ(UNIT2,10,ERR=20,END=30) NAME,CHROMO,NALL,NPTYPE
 10   FORMAT(2A8,2I2)
      NCVAR=NCVAR+1
      IF (ECHO) THEN
      CALL UPCASE(NAME)
      CALL MBLANK(NAME)
      CALL MBLANK(CHROMO)
      WRITE(UNIT3,40) NAME,CHROMO,NALL,NPTYPE
 40   FORMAT(/,' LOCUS ',A8,1X,A8,1X,I3,' ALLELES ',I3,' PHENOTYPES'
     1,/,' ALLELE NAMES AND FREQUENCIES')
      END IF
      MNALL=MIN(MNALL,NALL)
      NALTOT=NALTOT+NALL
      NPPEND=NPPEND+NPTYPE
C
C     FOR EACH ALLELE READ A SYMBOL AND POPULATION FREQUENCY.
C
      DO 50 N=1,NALL
      READ(UNIT2,60,ERR=20,END=20) ALLELE,ALLFRQ
 60   FORMAT(A8,F8.5)
      IF (ECHO) THEN
      CALL MBLANK(ALLELE)
      WRITE(NAME,'(F8.5)') ALLFRQ
      CALL MBLANK(NAME)
      WRITE(UNIT3,70) ALLELE,NAME
 70   FORMAT(6X,A8,4X,A8)
      END IF
 50   CONTINUE
C
C     FOR EACH PHENOTYPE READ A SYMBOL AND THE NUMBER OF CONSTITUENT
C     GENOTYPES.
C
      IF (ECHO.AND.NPTYPE.GT.0) WRITE(UNIT3,75)
 75   FORMAT(' PHENOTYPES')
      DO 80 N=1,NPTYPE
      READ(UNIT2,90,ERR=20,END=20) PHENO,NSET
 90   FORMAT(A8,I2)
      IF (ECHO) THEN
      CALL MBLANK(PHENO)
      IF (NSET.GT.1) THEN
      WRITE(UNIT3,100) PHENO,NSET
 100  FORMAT(6X,A8,1X,I2,' GENOTYPES')
      ELSE
      WRITE(UNIT3,105) PHENO,NSET
 105  FORMAT(6X,A8,1X,I2,' GENOTYPE')
      END IF
      END IF
      NPHSET=NPHSET+NSET
C
C     READ THE GENOTYPE SYMBOLS.  THESE WILL BE PAIRS OF ALLELE SYMBOLS
C     SEPARARTED BY A SLASH.
C
      DO 80 M=1,NSET
      READ(UNIT2,110,ERR=20,END=20) GTYPE
 110  FORMAT(A17)
 80   IF (ECHO) WRITE(UNIT3,120) GTYPE
 120  FORMAT(8X,A17)
      GO TO 130
 20   WRITE(UNIT3,140) NCVAR
 140  FORMAT(' *** ERROR *** ERROR ENCOUNTERED IN READING LOCUS'
     1,I3,' OF THE LOCUS FILE.')
      CALL EXIT( 5 )
C
C     PREPARE FOR THE SECOND PASS THROUGH THE FILE.  SET START
C     POINTS FOR CARVING UP RARRAY, IARRAY, AND CARRAY.  CHECK THAT
C     THERE IS ADEQUATE SPACE.
C
 30   NPHSET=MAX(NPHSET,1)
      REWIND(UNIT2)
      IF (NALTOT.GT.LENR) CALL ASTOP(UNIT3,'R','LFILE1')
      N2=NCVAR+1
      N3=NCVAR+N2
      N4=NPHSET+N3
      IF (N4+NPPEND-1.GT.LENI) CALL ASTOP(UNIT3,'I','LFILE1')
      K2=NALTOT+1
      K3=NCVAR+K2
      IF (K3+NPPEND-1.GT.LENC) CALL ASTOP(UNIT3,'C','LFILE1')
      IF (NCVAR.GT.LENL) CALL ASTOP(UNIT3,'L','LFILE1')
      IF (NCVAR.EQ.0.OR.MNALL.LE.0) THEN
      WRITE(UNIT3,150)
 150  FORMAT(' *** ERROR *** THE LOCUS FILE MUST CONTAIN AT LEAST ONE'
     1,' LOCUS AND ONE ALLELE PER LOCUS.')
      CALL EXIT( 6 )

      END IF
      CALL LFILE2(RARRAY,IARRAY,IARRAY(N2),IARRAY(N3),IARRAY(N4)
     1,CARRAY,CARRAY(K2),CARRAY(K3),LARRAY,NALTOT,NCVAR,NPHSET
     2,NPPEND,UNIT1,UNIT2,UNIT3,CHROMO,GTYPE,PHENO,ORDERD)
      END

      SUBROUTINE LFILE2(ALLFRQ,NALL,NPTYPE,PHLIST,PPOINT,ALLELE
     1,NAME,PTYPE,XLINK,NALTOT,NCVAR,NPHSET,NPPEND,UNIT1,UNIT2
     2,UNIT3,CHROMO,GTYPE,PHENO,ORDERD)
C
C     THIS SUBROUTINE MAKES THE SECOND PASS THROUGH THE LOCUS FILE.
C     IT CHECKS THAT EACH LOCUS IS EITHER AUTOSOMAL OR XLINKED,
C     THAT ALLELE FREQUENCIES ARE IN THE INTERVAL [0.,1.], AND
C     THAT EACH GENOTYPE SYMBOL CORRESPONDS TO A PAIR OF PERMISSABLE
C     ALLELES.  IT THEN WRITES THE SUMMARIZED DATA ON A SCRATCH FILE.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ALLFRQ(NALTOT)
      INTEGER NALL(NCVAR),NPTYPE(NCVAR),PHLIST(NPHSET)
     1,PPOINT(NPPEND),UNIT1,UNIT2,UNIT3
      CHARACTER*8 ALLELE(NALTOT),NAME(NCVAR),PTYPE(NPPEND),CHROMO
     2,GTYPE*17,PHENO
      LOGICAL XLINK(NCVAR),ORDERD
C
      IERROR=0
      J=0
      K=0
      L=0
      DO 20 I=1,NCVAR
      READ(UNIT2,10,END=20) NAME(I),CHROMO,NALL(I),NPTYPE(I)
 10   FORMAT(2A8,2I2)
      CALL MBLANK(CHROMO)
      IF (CHROMO(1:1).EQ.'A'.OR.CHROMO(1:1).EQ.'a') THEN
      XLINK(I)=.FALSE.
      ELSE IF (CHROMO(1:1).EQ.'X'.OR.CHROMO(1:1).EQ.'x') THEN
      XLINK(I)=.TRUE.
      ELSE
      WRITE(UNIT3,30) NAME(I)
 30   FORMAT(' *** ERROR *** IS LOCUS ',A8,' X-LINKED OR AUTOSOMAL?')
      CALL EXIT( 7 )

      END IF
      CALL UPCASE(NAME(I))
      CALL MBLANK(NAME(I))
      SUM=0.D0
      JSTART=J+1
      DO 40 N=1,NALL(I)
      J=J+1
      READ(UNIT2,50) ALLELE(J),ALLFRQ(J)
 50   FORMAT(A8,F8.5)
      IF (ALLFRQ(J).LE.0.D0.OR.ALLFRQ(J).GT.1.D0) THEN
      WRITE(UNIT3,60) ALLELE(J),NAME(I)
 60   FORMAT(' *** ERROR *** THE FREQUENCY OF ALLELE ',A8,' OF'
     1,' LOCUS ',A8,' IS OUTSIDE THE RANGE 0.0 TO 1.0.')
      CALL EXIT( 8 )

      END IF
      SUM=SUM+ALLFRQ(J)
 40   CALL MBLANK(ALLELE(J))
      IF (ABS(SUM-1.0D0).GT.1.0D-4) WRITE(UNIT3,70) NAME(I),SUM
 70   FORMAT(' *** WARNING *** THE SUM OF THE ALLELE FREQUENCIES'
     1,' FOR LOCUS ',A8,/,' IS',F8.5,'.')
      DO 80 N=1,NPTYPE(I)
      READ(UNIT2,90) PHENO,NSET
 90   FORMAT(A8,I2)
      CALL MBLANK(PHENO)
      K=K+1
      PTYPE(K)=PHENO
      PPOINT(K)=L+1
      LSTART=L+1
      DO 80 M=1,NSET
      READ(UNIT2,100) GTYPE
 100  FORMAT(A17)
      L=L+1
      CALL GETGEN(ALLELE(JSTART),IERROR,NALL(I),PHLIST(L),GTYPE,ORDERD)
      IF (IERROR.EQ.1) THEN
      WRITE(UNIT3,110) GTYPE,PHENO,NAME(I)
 110  FORMAT(' *** ERROR *** NO MATCH TO ALLELES FOR GENOTYPE ',A17
     1,' OF PHENOTYPE ',A8,' OF LOCUS ',A8,'.')
      CALL EXIT( 9 )

      END IF
      DO 120 LL=LSTART,L-1
      IF (PHLIST(LL).EQ.PHLIST(L)) THEN
      WRITE(UNIT3,130) GTYPE,PHENO,NAME(I)
 130  FORMAT(' *** ERROR *** GENOTYPE ',A17,' OF PHENOTYPE ',A8
     :,' OF LOCUS ',A8,' IS REDUNDANT.')
      CALL EXIT( 10 )

      END IF
 120  CONTINUE
 80   CONTINUE
 20   CONTINUE
      PPOINT(K+1)=L+1
C
C     WRITE NAME, XLINK, NALL, ALLFRQ, PHLIST, AND PPOINT ON A SCRATCH
C     FILE.
C
      WRITE(UNIT1) NAME
      WRITE(UNIT1) XLINK
      CALL ISCRAT(NALL,NCVAR,UNIT1,.TRUE.)
      CALL RSCRAT(ALLFRQ,NALTOT,UNIT1,.TRUE.)
      CALL ISCRAT(PHLIST,NPHSET,UNIT1,.TRUE.)
      CALL ISCRAT(PPOINT,NPPEND,UNIT1,.TRUE.)
      END

      SUBROUTINE GETGEN(ALLELE,IERROR,NALL,PHLIST,GTYPE,ORDERD)
C
C     THIS SUBROUTINE CONVERTS A CHARACTER GENOTYPE INTO A
C     NUMERICAL GENOTYPE.
C
      INTEGER KALL(2),PHLIST
      CHARACTER*8 ALLELE(NALL),C(2),GTYPE*(*)
      LOGICAL ORDERD
C
C     LOCATE THE SEPARATING SLASH.
C
      I=INDEX(GTYPE,'/')
      LGTYPE=LEN(GTYPE)
      IF (I.EQ.0.OR.I.EQ.LGTYPE) GO TO 10
      C(1)=GTYPE(MAX(I-8,1):I-1)
      C(2)=GTYPE(I+1:MIN(I+8,LGTYPE))
C
C     IDENTIFY THE TWO ALLELES.
C
      DO 20 I=1,2
      CALL MBLANK(C(I))
      DO 30 J=1,NALL
      IF (C(I).EQ.ALLELE(J)) THEN
      KALL(I)=J
      GO TO 20
      END IF
 30   CONTINUE
      GO TO 10
 20   CONTINUE
C
C     CONVERT THE GENOTYPE SYMBOL INTO A NUMBER CODE.
C
      IF (ORDERD) THEN
      PHLIST=(KALL(1)-1)*NALL+KALL(2)
      ELSE
      PHLIST=(MIN(KALL(1),KALL(2))-1)*NALL+MAX(KALL(1),KALL(2))
      END IF
      RETURN
 10   IERROR=1
      END

      SUBROUTINE PREPED(RARRAY,IARRAY,NALL,NPTYPE,ALLELE,CARRAY
     1,NAME,PTYPE,ABSENT,LENC,LENI,LENR,MAXPEO,MXTWIN,NALTOT,NCVAR
     2,NPED,NPPEND,NVAR,UNIT1,UNIT2,UNIT3,FRMT1,FRMT2,XYSIGN
     3,XXSIGN,ECHO,ORDERD)
C
C     THIS SUBROUTINE CONTROLS THE READING OF THE PEDIGREE DATA
C     FROM THE PEDIGREE INPUT FILE.  ONCE THE DATA IS READ AND
C     CHECKED, IT IS WRITTEN ON A SCRATCH FILE.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION RARRAY(LENR)
      INTEGER IARRAY(LENI),NALL(NCVAR),NPTYPE(NCVAR),UNIT1,UNIT2
     1,UNIT3
      CHARACTER*8 ALLELE(NALTOT),CARRAY(LENC),NAME(NCVAR)
     1,PTYPE(NPPEND),FRMT1*78,FRMT2*78,IDFAM,XYSIGN,XXSIGN
      LOGICAL ECHO,ORDERD,QUIT
C
C     FORMAT STATEMENTS FOR OUTPUT OF DATA AND ERROR MESSAGES.
C
 510  FORMAT(A)
 520  FORMAT(/,' FORMATS FOR INPUT OF PEDIGREE DATA:',2(/,' ',A))
 530  FORMAT(' *** ERROR *** THE PROGRAM CANNOT READ THE PEDIGREE'
     1,' RECORD FOR PEDIGREE NUMBER',I4,'.')
 540  FORMAT(' *** ERROR *** PEDIGREE NUMBER',I4,' HAS',I6,' PEOPLE.'
     1,'  THE MINIMUM NUMBER IS 1.')
 550  FORMAT(/,' PEDIGREE',I4,' HAS',I4,' PEOPLE AND PEDIGREE ID ',A8)
 560  FORMAT(/,'      ID       PARENT   IDS      SEX      TWIN'
     1,(T51,3(1X,A8),:))
 570  FORMAT(/,' PEDIGREE',I4,' HAS PEDIGREE ID ',A8)
 580  FORMAT(/,' TOTALS:  PEDIGREES   PEOPLE  FEMALES    MALES  MZTWINS'
     1,' FOUNDERS'
     1,/,13X,I5,5(4X,I5))
 590  FORMAT(/,' THE PROGRAM HAS STOPPED BECAUSE OF ERRORS IN THE'
     1,' PEDIGREE FILE. THESE ARE NOTED ABOVE.')
C
C     INITIALIZE SOME VARIABLES.  STOP IF CARRAY IS TOO SMALL.
C
      MAXPEO=1
      NCVAR5=NCVAR+5
      NDATA=NCVAR5+NVAR
      NPED=0
      NUMPEO=0
      NMALES=0
      NTWINS=0
      NFOUND=0
      QUIT=.FALSE.
      IF (NALTOT+NDATA+NCVAR+NPPEND.GT.LENC)
     1CALL ASTOP(UNIT3,'C','PREPED')
C
C     READ THE PEDIGREE FILE FORMATS.  ECHO THEM IF DESIRED.
C
      READ(UNIT2,510) FRMT1
      READ(UNIT2,510) FRMT2
      IF (ECHO) WRITE(UNIT3,520) FRMT1,FRMT2
C
C     READ THE PEDIGREE DATA FAMILY BY FAMILY.  CHECK FOR ERRORS AND
C     AND AN END OF FILE INDICATOR.
C
 40   READ(UNIT2,FRMT1,ERR=10,END=20) NPTOT,IDFAM
      GO TO 30
 10   NPED=NPED+1
      WRITE(UNIT3,530) NPED
      CALL EXIT( 11 )

 30   NPED=NPED+1
      NUMPEO=NUMPEO+NPTOT
C
C     CHECK THAT THE NUMBER OF PEOPLE IN EACH PEDIGREE IS IN BOUNDS.
C     ECHO THE PEDIGREE DATA IF NECESSARY.
C
      IF (NPTOT.LE.0) THEN
      WRITE(UNIT3,540) NPED,NPTOT
      CALL EXIT( 12 )

      END IF
      IF (ECHO) THEN
      WRITE(UNIT3,550) NPED,NPTOT,IDFAM
      DO 50 I=1,NVAR
      WRITE(CARRAY(I),'(I5)') I
 50   CARRAY(I)(1:3)='VAR'
      WRITE(UNIT3,560) (NAME(I),I=1,NCVAR),(CARRAY(I),I=1,NVAR)
      END IF
C
C     SET START POINTS FOR ARRAYS TO BE CARVED OUT OF RARRAY.
C
      MAXPEO=MAX(MAXPEO,NPTOT)
      MAXPH=NCVAR*NPTOT
      MAXV=MAX(NVAR*NPTOT,1)
      M2=MXTWIN+1
      M3=2*NPTOT+M2
      M4=NPTOT+M3
      M5=NPTOT+M4
      IF (M5+MAXV-1.GT.LENR) CALL ASTOP(UNIT3,'R','PREPED')
C
C     SET START POINTS FOR ARRAYS TO BE CARVED OUT OF IARRAY.
C
      N2=NPTOT+1
      N3=NPTOT+N2
      N4=NPTOT+N3
      N5=NPTOT+N4
      N6=MXTWIN+N5
      N7=NPTOT+N6
      N8=NPTOT+N7
      N9=MAXPH+N8
      IF (2*NCVAR+N9+MXTWIN-1.GT.LENI) CALL ASTOP(UNIT3,'I','PREPED')
C
C     CALL PINPUT TO READ AND CHECK THE DATA ON EACH INDIVIDUAL
C     IN THE PEDIGREE.
C
      IERROR=0
      CALL PINPUT(RARRAY,RARRAY(M2),RARRAY(M3),RARRAY(M4),RARRAY(M5)
     1,IARRAY,IARRAY(N2),IARRAY(N3),IARRAY(N4),NALL,NPTYPE,IARRAY(N5)
     2,IARRAY(N6),IARRAY(N7),IARRAY(N8),IARRAY(N9),ALLELE,CARRAY,NAME
     3,PTYPE,ABSENT,IERROR,NPED,MXTWIN,MAXPH,MAXV,NALTOT,NCVAR,NCVAR5
     4,NDATA,NFOUND,NMALES,NPPEND,NPTOT,NTWINS,NVAR,UNIT1,UNIT2,UNIT3
     5,FRMT2,IDFAM,XYSIGN,XXSIGN,ECHO,ORDERD)
      IF (.NOT.ECHO.AND.IERROR.NE.0.AND.IDFAM.NE.' ')
     :WRITE(UNIT3,570) NPED,IDFAM

      IF (IERROR.GE.2) CALL EXIT( 13 )

      IF (IERROR.NE.0) QUIT=.TRUE.
      GO TO 40
 20   WRITE(UNIT3,580) NPED,NUMPEO,NUMPEO-NMALES,NMALES,NTWINS,NFOUND
      IF (QUIT) THEN
      WRITE(UNIT3,590)
      CALL EXIT( 14 )

      END IF
      END

      SUBROUTINE PINPUT(GRLIST,PARENT,PERID,RDUMMY,VAR,FATHER,GROUP
     1,IDUMMY,MOTHER,NALL,NPTYPE,NTL,PERM,PERSON,PHEN,PTL,ALLELE
     2,CARRAY,NAME,PTYPE,ABSENT,IERROR,IPED,MXTWIN,MAXPH,MAXV
     3,NALTOT,NCVAR,NCVAR5,NDATA,NFOUND,NMALES,NPPEND,NPTOT,NTWINS
     4,NVAR,UNIT1,UNIT2,UNIT3,FRMT2,IDFAM,XYSIGN,XXSIGN,ECHO,ORDERD)
C
C     THIS SUBROUTINE INPUTS THE PEDIGREE DATA AND ATTEMPTS TO
C     DETECT ERRORS.  NOTE THAT MAXPH SHOULD BE NCVAR*NPTOT AND
C     THAT MAXV SHOULD BE MAX(NVAR*NPTOT,1).
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION GRLIST(MXTWIN),PARENT(2,NPTOT),PERID(NPTOT)
     1,RDUMMY(NPTOT),VAR(MAXV)
      INTEGER FATHER(NPTOT),GROUP(NPTOT),IDUMMY(NPTOT),MOTHER(NPTOT)
     1,NALL(NCVAR),NPTYPE(NCVAR),NTL(MXTWIN),PERM(NPTOT)
     2,PERSON(NPTOT),PHEN(MAXPH),PTL(MXTWIN),UNIT1,UNIT2,UNIT3
      CHARACTER*8 ALLELE(NALTOT),CARRAY(NDATA),IDFAM,NAME(NCVAR)
     1,PTYPE(NPPEND),BLANK8,CTYPE,FRMT2*78,XYSIGN,XXSIGN
      LOGICAL ECHO,ORDERD
C
C     FORMAT STATEMENTS FOR OUTPUT OF DATA AND ERROR MESSAGES.
C


 500  FORMAT(1X,I3,1X,5(1X,A8),(T51,3(1X,A8),:))
 510  FORMAT(' *** ERROR *** PERSON NUMBER',I4,' IN PEDIGREE NUMBER'
     1,I4,' HAS A BLANK PERSON ID.')
 520  FORMAT(' *** ERROR *** PERSON NUMBER',I4,' IN PEDIGREE NUMBER'
     1,I4,' HAS THE SAME PERSON ID AS ONE OF HIS/HER PARENTS.')
 530  FORMAT(' *** ERROR *** PERSON NUMBER',I4,' IN PEDIGREE NUMBER'
     1,I4,' HAS AN ILLEGAL SEX CODE.')
 540  FORMAT(' *** ERROR *** PERSON NUMBER',I4,' IN PEDIGREE NUMBER'
     1,I4,' HAS ONLY ONE PARENT SPECIFIED.')
 550  FORMAT(' *** ERROR *** MZ TWINS NUMBERED',I4,' AND',I4
     1,' IN PEDIGREE NUMBER',I4,' HAVE DIFFERENT PARENTS.')
 560  FORMAT(' *** ERROR *** MZ TWINS NUMBERED',I4,' AND',I4
     1,' IN PEDIGREE NUMBER',I4,' ARE OF OPPOSITE SEX.')
 570  FORMAT(' *** ERROR *** PEDIGREE NUMBER',I4,' EXCEEDS THE MAXIMUM'
     1,' OF',I3,' FOR TOTAL MZ TWIN SETS.')
 580  FORMAT(' *** ERROR *** PERSON NUMBER',I4,' IN PEDIGREE NUMBER'
     1,I4,' HAS AN ILLEGAL PHENOTYPE AT LOCUS ',A8,'.')
 590  FORMAT(' *** ERROR *** PERSON NUMBER',I4,' IN PEDIGREE NUMBER'
     1,I4,' IS AN MZ TWIN WITH NO IDENTICAL SIBS.')
 600  FORMAT(' *** WARNING *** PERSON NUMBER',I4,' IN PEDIGREE NUMBER'
     1,I4,' IS AN MZ TWIN WITH MORE THAN ONE IDENTICAL SIB.')
 610  FORMAT(' *** ERROR *** PERSON NUMBER',I4,' IN PEDIGREE NUMBER'
     1,I4,' HAS PARENTS OF THE SAME SEX.')
 620  FORMAT(' *** ERROR *** PARENT NUMBER',I2,' OF PERSON NUMBER'
     1,I4,' IN PEDIGREE NUMBER ',I4,' IS NOT IN THE PEDIGREE.')
 630  FORMAT(' *** ERROR *** PERSONS NUMBERED',I4,' AND',I4,' IN'
     1,' PEDIGREE NUMBER',I4,' HAVE THE SAME ID.')
 640  FORMAT(' *** ERROR *** MZ TWINS NUMBERED',I4,' AND',I4
     1,' IN PEDIGREE NUMBER',I4,' HAVE CONFLICTING PHENOTYPES'
     2,' AT LOCUS ',A8,'.')
 650  FORMAT(' *** ERROR *** SOMEONE NEAR PERSON NUMBER',I4,' IN'
     1,' PEDIGREE NUMBER',I4,' IS HIS/HER OWN ANCESTOR.')
 660  FORMAT(' *** ERROR *** END OF FILE OR ERROR ENCOUNTERED WHILE'
     1,' INPUTTING PERSON NUMBER',I4,' OF PEDIGREE NUMBER',I4,'.')
C
C     FOR EACH PERSON IN THE PEDIGREE, INPUT THE PERSONAL DATA AND
C     CHECK FOR IRREGULARITIES.
C
      BLANK8='        '
      READ(BLANK8,'(A8)') BR8
      LGR=0
      DO 10 I=1,NPTOT
      PERSON(I)=I
      READ (UNIT2,FRMT2,ERR=1000,END=1000) (CARRAY(J),J=1,NDATA)
C
C     MOVE ALL BLANKS TO THE RIGHT IN CHARACTER STRINGS.
C
      DO 20 J=1,NDATA
 20   CALL MBLANK(CARRAY(J))
C
C     ECHO THE DATA IF DESIRED.
C
      IF (ECHO) THEN
      WRITE(UNIT3,500) I,(CARRAY(J),J=1,NDATA)
      END IF
C
C     CONVERT CHARACTER DATA TO DOUBLE PRECISION DATA.  NOTE THE
C     ORDER IN WHICH VARIABLES ARE PROCESSED.
C
      READ(CARRAY(1),'(A8)') PERID(I)
      READ(CARRAY(2),'(A8)') PARENT(1,I)
      READ(CARRAY(3),'(A8)') PARENT(2,I)
      READ(CARRAY(5),'(A8)') GRP
C
C     CHECK FOR A BLANK PERSON ID OR A MATCH OF PERSON ID TO A PARENTAL
C     ID.
C
      IF (CARRAY(1).EQ.BLANK8) THEN
      IERROR=1
      WRITE(UNIT3,510) I,IPED
      ELSE IF (CARRAY(1).EQ.CARRAY(2).OR.CARRAY(1).EQ.CARRAY(3)) THEN
      IERROR=1
      WRITE(UNIT3,520) I,IPED
      END IF
C
C     SET THE SEX VARIABLE FOR THIS PERSON AND CHECK FOR AN ILLEGAL SEX
C     CODE.
C
      IF (CARRAY(4).EQ.XYSIGN) THEN
      GROUP(I)=1
      NMALES=NMALES+1
      ELSE IF (CARRAY(4).EQ.XXSIGN) THEN
      GROUP(I)=2
      ELSE
      IERROR=1
      WRITE(UNIT3,530) I,IPED
      END IF
C
C     CHECK FOR ONLY ONE PARENT SPECIFIED.
C
      IF (CARRAY(2).EQ.BLANK8.NEQV.CARRAY(3).EQ.BLANK8) THEN
      IERROR=1
      WRITE(UNIT3,540) I,IPED
      END IF
C
C     UPDATE THE NUMBER OF FOUNDERS.
C
      IF (CARRAY(2).EQ.BLANK8) NFOUND=NFOUND+1
C
C     CHECK WHETHER THIS PERSON IS AN MZ TWIN.
C
      IF (CARRAY(5).NE.BLANK8) THEN
      NTWINS=NTWINS+1
      DO 30 J=1,LGR
      IF (GRP.EQ.GRLIST(J)) THEN
C
C     THE CURRENT TWIN IS A COTWIN.  CHECK THAT SEX AND PARENTS
C     ARE THE SAME AS THOSE OF THE PRIMARY TWIN.
C
      JPTL=PTL(J)
      IF (PARENT(1,I).EQ.PARENT(1,JPTL).AND.PARENT(2,I).EQ.
     1PARENT(2,JPTL)) GO TO 40
      IF (PARENT(1,I).EQ.PARENT(2,JPTL).AND.PARENT(2,I).EQ.
     1PARENT(1,JPTL)) GO TO 40
      IERROR=1
      WRITE(UNIT3,550) JPTL,I,IPED
 40   IF (MOD(GROUP(I),2).NE.MOD(GROUP(JPTL),2)) THEN
      IERROR=1
      WRITE(UNIT3,560) JPTL,I,IPED
      END IF
      GROUP(I)=J*4+GROUP(I)
      NTL(J)=NTL(J)+1
      GO TO 50
      END IF
 30   CONTINUE
C
C     THE CURRENT TWIN IS A PRIMARY TWIN.  UPDATE THE PRIMARY TWIN LIST,
C     OR NOTE IF THE MAXIMUM TWIN COUNT HAS BEEN EXCEEDED.
C
      IF (LGR.LT.MXTWIN) THEN
      LGR=LGR+1
      PTL(LGR)=I
      NTL(LGR)=1
      GRLIST(LGR)=GRP
      GROUP(I)=LGR*4+GROUP(I)
      ELSE
      IERROR=1
      WRITE(UNIT3,570) IPED,MXTWIN
      END IF
      END IF
C
C     CHECK THAT THE CHARACTER PHENOTYPES MATCH THE SPECIFIED LISTS,
C     AND LOAD THEM INTO PHEN.
C
 50   JSTART=1
      KSTART=1
      DO 60 J=1,NCVAR
      IF (J.GT.1) JSTART=JSTART+NALL(J-1)
      KEND=KSTART+NPTYPE(J)-1
      CTYPE=CARRAY(J+5)
      IF (CTYPE.EQ.BLANK8) THEN
      PHEN((J-1)*NPTOT+I)=0
      ELSE
      DO 70 K=KSTART,KEND
      IF (CTYPE.EQ.PTYPE(K)) THEN
      PHEN((J-1)*NPTOT+I)=K
      GO TO 60
      END IF
 70   CONTINUE
      CALL GETGEN(ALLELE(JSTART),IERROR,NALL(J),JPHEN,CTYPE,ORDERD)
      PHEN((J-1)*NPTOT+I)=-JPHEN
      IF (IERROR.EQ.1) WRITE(UNIT3,580) I,IPED,NAME(J)
      END IF
 60   KSTART=KEND+1
C
C     CONVERT THE QUANTITATIVE CHARACTER VARIABLES TO NUMBERS.
C
      DO 80 J=1,NVAR
      IF (CARRAY(NCVAR5+J).EQ.BLANK8) THEN
      VAR((I-1)*NVAR+J)=ABSENT
      ELSE
      CALL VERIFY(CARRAY(NCVAR5+J),'0123456789 ',K)
      L=INDEX(CARRAY(NCVAR5+J),' ')
      IF (K.EQ.0.AND.L.NE.0) CARRAY(NCVAR5+J)(L:L)='.'
      READ(CARRAY(NCVAR5+J),'(F8.0)',ERR=1000) VAR((I-1)*NVAR+J)
      END IF
 80   CONTINUE
 10   CONTINUE
C
C     RECORD THE NUMBER OF PEOPLE LESS THE COTWINS.  NOTE IF ANY
C     PRIMARY TWIN LACKS A COTWIN OR HAS MORE THAN ONE COTWIN.
C
      NPEO=NPTOT
      DO 90 J=1,LGR
      IF (NTL(J).LE.1) THEN
      IERROR=1
      WRITE(UNIT3,590) PTL(J),IPED
      END IF
      IF (NTL(J).GE.3) WRITE(UNIT3,600) PTL(J),IPED
 90   NPEO=NPEO-NTL(J)+1
C
C     RETURN IF THERE HAVE BEEN ANY ERRORS DETECTED SO FAR.
C
      IF (IERROR.NE.0) RETURN
C
C     IF THERE ARE ANY MZ SIBSHIPS IN THE PEDIGREE, MOVE COTWINS
C     TO THE END OF THE PEDIGREE.
C
      IF (NPEO.LT.NPTOT) THEN
      IEND=NPTOT
      DO 100 I=1,NPEO
      IF (GROUP(I)/4.EQ.0) GO TO 100
      DO 110 J=1,LGR
 110  IF (I.EQ.PTL(J)) GO TO 100
C
C     WE HAVE FOUND A COTWIN.  NOW SEE IF THE LOCATION AT THE END
C     OF THE PEDIGREE WHERE HE SHOULD GO IS ALSO OCCUPIED BY A COTWIN.
C     IF SO, THEN MOVE OVER A PLACE.
C
 140  IF (GROUP(IEND)/4.NE.0) THEN
      DO 120 J=1,LGR
      IF (IEND.EQ.PTL(J)) THEN
      PTL(J)=I
      GO TO 130
      END IF
 120  CONTINUE
      IEND=IEND-1
      GO TO 140
      END IF
C
C     SWITCH THE COTWIN INTO THE LOCATION AT THE END OF THE PEDIGREE.
C
 130  RSAVE=PERID(I)
      PERID(I)=PERID(IEND)
      PERID(IEND)=RSAVE
      DO 150 J=1,2
      RSAVE=PARENT(J,I)
      PARENT(J,I)=PARENT(J,IEND)
 150  PARENT(J,IEND)=RSAVE
      ISAVE=PERSON(I)
      PERSON(I)=PERSON(IEND)
      PERSON(IEND)=ISAVE
      ISAVE=GROUP(I)
      GROUP(I)=GROUP(IEND)
      GROUP(IEND)=ISAVE
      DO 160 J=1,NCVAR
      ISAVE=PHEN((J-1)*NPTOT+I)
      PHEN((J-1)*NPTOT+I)=PHEN((J-1)*NPTOT+IEND)
 160  PHEN((J-1)*NPTOT+IEND)=ISAVE
      DO 170 J=1,NVAR
      RSAVE=VAR((I-1)*NVAR+J)
      VAR((I-1)*NVAR+J)=VAR((IEND-1)*NVAR+J)
 170  VAR((IEND-1)*NVAR+J)=RSAVE
 100  CONTINUE
      END IF
C
C     NUMBER THE PEOPLE IN THE PEDIGREE ACCORDING TO THEIR ORDER
C     ON DATA ENTRY.  FATHER STORES THE NUMBER CORRESPONDING TO THE
C     INDIVIDUAL'S FATHER AND SIMILARLY FOR MOTHER.
C
      DO 180 I=1,NPTOT
      FATHER(I)=0
      MOTHER(I)=0
      DO 180 J=1,2
      PAR=PARENT(J,I)
      IF (PAR.NE.BR8) THEN
      DO 190 K=1,NPTOT
      IF (PERID(K).EQ.PAR) THEN
C
C     PARENT J IS IN THE PEDIGREE.
C
      IF (MOD(GROUP(K),2).EQ.1.AND.FATHER(I).EQ.0) THEN
      FATHER(I)=K
      ELSE IF (MOD(GROUP(K),2).EQ.0.AND.MOTHER(I).EQ.0) THEN
      MOTHER(I)=K
      ELSE
C
C     THE PARENTS ARE OF THE SAME SEX.
C
      IERROR=1
      WRITE(UNIT3,610) PERSON(I),IPED
      END IF
      GO TO 180
      END IF
 190  CONTINUE
C
C     PARENT J IS NOT IN THE PEDIGREE.
C
      IERROR=1
      WRITE(UNIT3,620) J,PERSON(I),IPED
      END IF
 180  CONTINUE
C
C     WITH TWINS IN THE PEDIGREE, IT MAY BE NECESSARY TO ALTER
C     PARENT NUMBERS.  IN PARTICULAR, COTWINS WHO ARE PARENTS MUST
C     BE REPLACED BY THEIR CORRESPONDING PRIMARY TWINS.
C
      DO 200 I=1,NPEO
      J=FATHER(I)
      IF (J.EQ.0) GO TO 210
      K=GROUP(J)/4
      IF (K.EQ.0) GO TO 210
      FATHER(I)=PTL(K)
 210  J=MOTHER(I)
      IF (J.EQ.0) GO TO 200
      K=GROUP(J)/4
      IF (K.EQ.0) GO TO 200
      MOTHER(I)=PTL(K)
 200  CONTINUE
C
C     CHECK WHETHER ANY PAIR OF PEOPLE SHARE AN INDIVIDUAL ID.
C
      DO 220 I=1,NPTOT
      PER=PERID(I)
      DO 220 J=I,NPTOT
      IF (PERID(J).EQ.PER.AND.J.NE.I) THEN
      IERROR=1
      WRITE(UNIT3,630) PERSON(I),PERSON(J),IPED
      END IF
 220  CONTINUE
C
C     CHECK WHETHER MZ TWINS HAVE CONFLICTING PHENOTYPES AT ANY LOCUS.
C
      NPEO1=NPEO+1
      IF (NPEO.LT.NPTOT) THEN
      DO 230 I=1,NPEO
      IF (GROUP(I)/4.EQ.0) GO TO 230
      DO 240 J=NPEO1,NPTOT
      IF (GROUP(I)/4.NE.GROUP(J)/4) GO TO 240
      DO 250 K=1,NCVAR
      IF (PHEN((K-1)*NPTOT+I).EQ.PHEN((K-1)*NPTOT+J)) GO TO 250
      IF (PHEN((K-1)*NPTOT+I).EQ.0) THEN
      PHEN((K-1)*NPTOT+I)=PHEN((K-1)*NPTOT+J)
      ELSE IF (PHEN((K-1)*NPTOT+J).NE.0) THEN
      IERROR=1
      WRITE(UNIT3,640) PERSON(I),PERSON(J),IPED,NAME(K)
      END IF
 250  CONTINUE
 240  CONTINUE
 230  CONTINUE
      END IF
C
C     CHECK WHETHER THE PEDIGREE HAS ANY DIRECTED CYCLES OR LOOPS
C     BY CALLING LOOP.  LOOP ALSO PROVIDES A PERMUTATION OF THE
C     PEDIGREE WITH PARENTS BEFORE CHILDREN.  FIRST MAKE SURE THE
C     PERMUTATION IS DEFINED FOR THE COTWINS.
C
      IF (IERROR.NE.0) RETURN
      DO 260 I=NPEO1,NPTOT
 260  PERM(I)=I
      CALL LOOP(FATHER,MOTHER,PERM,IERROR,NPTOT,NPEO)
      IF (IERROR.NE.0) THEN
      WRITE(UNIT3,650) PERSON(IERROR),IPED
      IERROR=1
      RETURN
      END IF
C
C     WRITE THE DATA ON THE SCRATCH FILE IN PERMUTED ORDER.
C
      CALL PERMUT(RDUMMY,VAR,FATHER,GROUP,IDUMMY,MOTHER,PERM
     1,PERSON,PHEN,MAXPH,MAXV,NCVAR,NPEO,NPTOT,NVAR,UNIT1,IDFAM)
      RETURN
 1000 IERROR=2
      WRITE(UNIT3,660) I,IPED
      END

      SUBROUTINE LOOP(FATHER,MOTHER,PERM,IERROR,MAXPEO,NPEO)
C
C     THIS SUBROUTINE DETERMINES WHETHER A PEDIGREE CONTAINS ANY
C     DIRECTED CYCLES.  IF SO, THEN SOMEONE IS HIS OWN ANCESTOR.
C     ON RETURN, IERROR IS 0 IF THERE ARE NO DIRECTED CYCLES.
C     OTHERWISE, IERROR IS THE NUMBER OF SOMEONE WHO IS HIS OWN
C     ANCESTOR.  THE PERMUTATION VECTOR PERM RETURNS WITH A REORDERING
C     OF THE PEDIGREE SO PARENTS PRECEDE THEIR CHILDREN.  FOR
C     ALGORITHMIC DETAILS SEE: E. LAWLER(1976) "COMBINATORIAL
C     OPTIMIZATION AND MATROIDS" HOLT, RINEHART, AND WINSTON, NEW YORK,
C     PAGE 32.  IF I IS A FOUNDER, THEN FATHER(I)=MOTHER(I)=0.
C     OTHERWISE, FATHER(I) IS A NUMBER BETWEEN 1 AND NPEO INDICATING
C     THE FATHER OF I.  DITTO FOR MOTHER.
C
      INTEGER FATHER(MAXPEO),MOTHER(MAXPEO),PERM(MAXPEO)
C
C     PUT ALL FOUNDERS AT THE START OF THE PERMUTATION VECTOR.  FOR
C     EACH REMAINING PERSON, PERM CONTAINS BOTH A CURRENT PERMUTATION
C     LOCATION AND HOW MANY OF HIS PARENTS HAVE BEEN ELIMINATED AS
C     POSSIBLE CANDIDATES FOR A DIRECTED CYCLE.
C
      IERROR=0
      M=1
      N=NPEO
      DO 10 I=1,NPEO
      IF (FATHER(I).EQ.0) THEN
      PERM(M)=I
      M=M+1
      ELSE
      PERM(N)=I+NPEO+NPEO
      N=N-1
      END IF
 10   CONTINUE
C
C     CHECK WHETHER ANYONE HAS BOTH PARENTS ELIMINATED.  SUCH A PERSON
C     CANNOT BELONG TO A DIRECTED CYCLE.  ELIMINATE THIS PERSON AND
C     COMPUTE HIS FINAL PERMUTATION LOCATION.  IF NO SUCH PERSON EXISTS,
C     THEN THE REMAINING PEOPLE ALL BELONG TO DIRECTED CYCLES.
C
      M=1
 50   DO 20 K=M,NPEO
 20   IF (PERM(K).LE.NPEO) GO TO 30
      IERROR=MOD(PERM(M)-1,NPEO)+1
      RETURN
 30   ISAVE=PERM(K)
      PERM(K)=PERM(M)
      PERM(M)=ISAVE
C
C     IF THIS IS THE LAST PERSON WE ARE DONE.
C
      M=M+1
      IF (M.GT.NPEO) RETURN
C
C     FIND THE CHILDRED OF THE ELIMINATED PERSON AND REDUCE THEIR
C     CURRENT PARENT COUNTS BY ONE.
C
      DO 40 I=M,NPEO
      IP=MOD(PERM(I)-1,NPEO)+1
      IF (FATHER(IP).EQ.ISAVE) PERM(I)=PERM(I)-NPEO
 40   IF (MOTHER(IP).EQ.ISAVE) PERM(I)=PERM(I)-NPEO
      GO TO 50
      END

      SUBROUTINE PERMUT(RDUMMY,VAR,FATHER,GROUP,IDUMMY,MOTHER,PERM
     1,PERSON,PHEN,MAXPH,MAXV,NCVAR,NPEO,NPTOT,NVAR,UNIT1,IDFAM)
C
C     THIS SUBROUTINE WRITES THE PEDIGREE DATA ON A SCRATCH FILE
C     IN THE PERMUTED ORDER DETERMINED BY SUBROUTINE LOOP.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION RDUMMY(NPTOT),VAR(MAXV)
      INTEGER FATHER(NPTOT),GROUP(NPTOT),IDUMMY(NPTOT),MOTHER(NPTOT)
     1,PERM(NPTOT),PERSON(NPTOT),PHEN(MAXPH),UNIT1
      CHARACTER*8 IDFAM
C
C     WRITE IN SEQUENCE NPEO, NPTOT, FATHER, MOTHER, PERSON, GROUP,
C     PHEN, AND VAR.
C
      WRITE(UNIT1) IDFAM,NPEO,NPTOT
C
C     FIND FATHERS IN THE PERMUTED ORDER.
C
      DO 10 I=1,NPTOT
      II=PERM(I)
      J=FATHER(II)
      IF (J.EQ.0) THEN
      IDUMMY(I)=0
      ELSE
      DO 20 K=1,NPTOT
      IF (PERM(K).EQ.J) THEN
      IDUMMY(I)=K
      GO TO  10
      END IF
 20   CONTINUE
      END IF
 10   CONTINUE
      CALL ISCRAT(IDUMMY,NPTOT,UNIT1,.TRUE.)
C
C     FIND MOTHERS IN THE PERMUTED ORDER.
C
      DO 30 I=1,NPTOT
      II=PERM(I)
      J=MOTHER(II)
      IF (J.EQ.0) THEN
      IDUMMY(I)=0
      ELSE
      DO 40 K=1,NPTOT
      IF (PERM(K).EQ.J) THEN
      IDUMMY(I)=K
      GO TO 30
      END IF
 40   CONTINUE
      END IF
 30   CONTINUE
      CALL ISCRAT(IDUMMY,NPTOT,UNIT1,.TRUE.)
C
C     WRITE PERSON AND GROUP IN THE PERMUTED ORDER.
C
      DO 50 I=1,NPTOT
      II=PERM(I)
 50   IDUMMY(I)=PERSON(II)
      CALL ISCRAT(IDUMMY,NPTOT,UNIT1,.TRUE.)
      DO 60 I=1,NPTOT
      II=PERM(I)
 60   IDUMMY(I)=GROUP(II)
      CALL ISCRAT(IDUMMY,NPTOT,UNIT1,.TRUE.)
C
C     WRITE PHEN IN THE PERMUTED ORDER.
C
      DO 70 J=1,NCVAR
      ISHIFT=(J-1)*NPTOT
      DO 80 I=1,NPTOT
      II=PERM(I)
 80   IDUMMY(I)=PHEN(ISHIFT+II)
      DO 90 I=1,NPTOT
 90   PHEN(ISHIFT+I)=IDUMMY(I)
 70   CONTINUE
      CALL ISCRAT(PHEN,MAXPH,UNIT1,.TRUE.)
C
C     WRITE VAR IN THE PERMUTED ORDER.
C
      DO 100 J=1,NVAR
      DO 110 I=1,NPTOT
      II=PERM(I)
 110  RDUMMY(I)=VAR((II-1)*NVAR+J)
      DO 120 I=1,NPTOT
 120  VAR((I-1)*NVAR+J)=RDUMMY(I)
 100  CONTINUE
      IF (NVAR.GT.0) CALL RSCRAT(VAR,MAXV,UNIT1,.TRUE.)
      END

      SUBROUTINE PREINF(ALLFRQ,RARRAY,FATHER,IARRAY,LCVAR,MOTHER,NALL
     1,NGEN,NHOM,NJOINT,PHEN,PHLIST,PPOINT,LNAME,MENDEL,XLINK,LENI
     2,LENR,MAXA,MAXALL,MAXGL,MAXI,MAXLST,MAXPEO,MAXPH,MAXSIZ,MXWORK
     3,NCVAR,NLOCI,NPED,NPHSET,NPPEND,NVAR,UNIT1,UNIT2,UNIT3,LUMP
     4,ORDERD,PMODE)
C
C     THIS SUBROUTINE ALLOCATES MORE ARRAY SPACE AND SERVES AS
C     AN INTERFACE TO THE INFERENCING PROCESS AND THE COMPUTATION
C     OF THE INSTRUCTION VECTOR.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ALLFRQ(NLOCI,MAXALL),RARRAY(LENR)
      INTEGER FATHER(MAXPEO),IARRAY(LENI),IERROR(2),LCVAR(NLOCI)
     1,MOTHER(MAXPEO),NALL(NLOCI),NGEN(NLOCI,MAXPEO)
     2,NHOM(NLOCI,MAXPEO),NJOINT(MAXPEO),PHEN(MAXPH),PHLIST(NPHSET)
     3,PPOINT(NPPEND),UNIT1,UNIT2,UNIT3
      CHARACTER*8 LNAME(NLOCI),IDFAM
      LOGICAL MENDEL(NLOCI),XLINK(NLOCI),LUMP,ORDERD,PMODE
C
C     READ IN THE PHENOSET LISTS AND THEIR ASSOCIATED POINTERS.
C
      CALL ISCRAT(PHLIST,NPHSET,UNIT1,.FALSE.)
      CALL ISCRAT(PPOINT,NPPEND,UNIT1,.FALSE.)
C
C     SET START POINTS FOR ARRAYS TO BE CARVED OUT OF IARRAY.
C
      N1=MAXPEO+1
      N2=MAXPEO+N1
      N3=MAXPEO+N2
      N4=MAXPEO*NLOCI+N3
      N5=MAXPEO+N4
      N6=MAXPEO+N5
      N7=MAXALL+N6
      MAXLG=LENI-N7+1
      IF (MAXLG.LE.0) CALL ASTOP(UNIT3,'I','PREINF')
C
C     INITALIZE THE ERROR FLAGS AND THE MEASURES OF LONGEST
C     GENOTYPE LIST AND LONGEST INSTRUCTION VECTOR.
C
      IERROR(1)=0
      IERROR(2)=0
      MAXA=0
      MAXGL=0
      MAXI=0
      MAXLST=0
      MAXSIZ=0
C
C     FOR EACH PEDIGREE DO THE INFERENCING AND SET UP THE
C     INSTRUCTION VECTOR.
C
      DO 10 IPED=1,NPED
*       write(*,*) iped,maxa
      CALL INF(ALLFRQ,RARRAY,IARRAY,FATHER,IARRAY(N7),IARRAY(N2)
     1,IARRAY(N3),IARRAY(N4),IERROR,IARRAY(N1),LCVAR,IARRAY(N6),MOTHER
     2,NALL,NGEN,NHOM,NJOINT,IARRAY(N5),PHEN,PHLIST,PPOINT,LNAME,MENDEL
     3,XLINK,IPED,LG,MAXALL,MAXLG,MAXPEO,MAXPH,LENR,MXWORK,NCVAR,NLOCI
     4,NPEO,NPHSET,NPPEND,NVAR,UNIT1,UNIT2,UNIT3,IDFAM,LUMP,ORDERD
     5,PMODE)
      MAXGL=MAX(MAXGL,LG)
      IF (.NOT.PMODE) THEN
      NODES=NPEO
      ELSE
      NODES=NLOCI*NPEO
      END IF
      K1=NODES+1
      LENII=LENI-NODES
      MAXLA=0
      CALL ORDER(RARRAY,FATHER,IARRAY(K1),MOTHER,NGEN,NHOM,NJOINT
     1,IARRAY,IPED,LENII,LENR,LI,MAXLA,MAXLST,MAXPEO,MAXSIZ,NLOCI
     2,NODES,NPEO,UNIT2,UNIT3,IDFAM,PMODE)
      MAXA=MAX(MAXA,MAXLA-1)
*     write(*,*) maxla
      WRITE(UNIT2) MAXLA-1
 10   MAXI=MAX(MAXI,LI)
      END

      SUBROUTINE INF(ALLFRQ,VAR,FAMILY,FATHER,GLIST,GINFO,GPOINT,GROUP
     1,IERROR,IWORK,LCVAR,LIST,MOTHER,NALL,NGEN,NHOM,NJOINT,PERSON,PHEN
     2,PHLIST,PPOINT,LNAME,MENDEL,XLINK,IPED,LG,MAXALL,MAXGL,MAXPEO
     3,MAXPH,MAXV,MXWORK,NCVAR,NLOCI,NPEO,NPHSET,NPPEND,NVAR,UNIT1
     4,UNIT2,UNIT3,IDFAM,LUMP,ORDERD,PMODE)
C
C     THIS SUBROUTINE READS ONE PEDIGREE FROM A SCRATCH FILE
C     AND THEN CALLS SUBROUTINE INFER TO DO THE GENOTYPE
C     INFERENCING ONE LOCUS AT A TIME.  FINALLY IT WRITES THE
C     INFERENCED PEDIGREE DATA BACK ON A SCRATCH FILE.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ALLFRQ(NLOCI,MAXALL),VAR(MAXV)
      INTEGER FAMILY(MAXPEO),FATHER(MAXPEO),GLIST(MAXGL)
     1,GINFO(MAXPEO),GPOINT(NLOCI,MAXPEO),GROUP(MAXPEO),IERROR(2)
     2,IWORK(MAXPEO),LCVAR(NLOCI),LIST(MAXALL),MOTHER(MAXPEO)
     3,NALL(NLOCI),NGEN(NLOCI,MAXPEO),NHOM(NLOCI,MAXPEO),NJOINT(MAXPEO)
     4,PERSON(MAXPEO),PHEN(MAXPH),PHLIST(NPHSET),PPOINT(NPPEND)
     5,UNIT1,UNIT2,UNIT3
      CHARACTER*8 LNAME(NLOCI),IDFAM
      LOGICAL MENDEL(NLOCI),XLINK(NLOCI),LUMP,ORDERD,PMODE
C
C     READ THE PEDIGREE DATA FROM SCRATCH FILE 1.
C
      READ(UNIT1) IDFAM,NPEO,NPTOT
      CALL ISCRAT(FATHER,NPTOT,UNIT1,.FALSE.)
      CALL ISCRAT(MOTHER,NPTOT,UNIT1,.FALSE.)
      CALL ISCRAT(PERSON,NPTOT,UNIT1,.FALSE.)
      CALL ISCRAT(GROUP,NPTOT,UNIT1,.FALSE.)
      LEN=NCVAR*NPTOT
      CALL ISCRAT(PHEN,LEN,UNIT1,.FALSE.)
      MVAR=NVAR*NPTOT
      IF (MVAR.GT.0) CALL RSCRAT(VAR,MVAR,UNIT1,.FALSE.)
C
C     INITIALIZE THE LOCATION LG IN GLIST AND THE LOCATION K IN
C     GPOINT AND NGEN.  THEN DO THE INFERENCING LOCUS BY LOCUS.
C
      LG=0
      DO 10 LOCUS=1,NLOCI
      L=(LCVAR(LOCUS)-1)*NPTOT+1
      CALL INFER(FAMILY,FATHER,GLIST,GINFO,IWORK,GROUP,IERROR,LIST
     1,MOTHER,NJOINT,PERSON,PHEN(L),PHLIST,PPOINT,LG,MAXALL,MAXGL
     2,MAXPEO,NALL(LOCUS),NLIST,NPEO,NPHSET,NPPEND,LUMP,MENDEL(LOCUS)
     3,ORDERD,XLINK(LOCUS))
      IF (IERROR(1).NE.0) THEN
      WRITE(UNIT3,20) IPED,IDFAM,LNAME(LOCUS),IERROR(1)
 20   FORMAT(/,' *** ERROR *** PEDIGREE NUMBER',I4,' WITH ID ',A8
     1,'HAS AN INCONSISTENCY AT LOCUS ',A8,' NEAR PERSON NUMBER'
     2,I4,'.')
      CALL EXIT( 15 )

      ELSE IF (IERROR(2).NE.0) THEN
      WRITE(UNIT3,30) IPED,IDFAM,LNAME(LOCUS)
 30   FORMAT(/' PEDIGREE NUMBER',I4,' WITH ID ',A8,' EXCEEDS AVAILABLE'
     1,' SPACE AT',/,' LOCUS ',A8,'.')
      CALL ASTOP(UNIT3,'I','   INF')
      END IF
      DO 40 I=1,NPEO
      MXWORK=MAX(MXWORK,NJOINT(I))
      NGEN(LOCUS,I)=NJOINT(I)
 40   GPOINT(LOCUS,I)=IWORK(I)
C
C     FIND THE FREQUENCY OF THE LUMPED ALLELE FOR THIS LOCUS.
C
      IF (LUMP) THEN
      IF (NLIST.LT.NALL(LOCUS)) THEN
      RESIDU=1.0D0
      DO 50 J=1,NLIST-1
 50   RESIDU=RESIDU-ALLFRQ(LOCUS,LIST(J))
      ELSE
      RESIDU=0.D0
      END IF
      WRITE(UNIT2) NALL(LOCUS)+1,RESIDU
      END IF
 10   CONTINUE
C
C     COUNT THE NUMBER OF MULTIPLE LOCUS GENOTYPES AND THE NUMBER
C     OF HOMOZYGOTES AT EACH LOCUS FOR EACH PERSON.
C
      CALL COUNT(GLIST,GPOINT,NGEN,NHOM,NJOINT,MAXGL,MAXPEO,NLOCI
     1,NPEO)
C
C     WRITE OUT THE PERTINENT DATA TO SCRATCH FILE 2.  NOTE THAT
C     GROUP IS CHANGED TO INDICATE WHO IS A FOUNDER.  SINCE THE
C     INSTRUCTION VECTOR WILL CONTAIN THE FATHER AND MOTHER
C     INFORMATION, THIS MAKES IT POSSIBLE TO AVOID WRITING AND
C     READING THE FATHER AND MOTHER VECTORS ON AND FROM A SCRATCH
C     UNIT.
C
      WRITE(UNIT2) IDFAM,NPEO,NPTOT,LG
      IF (.NOT.PMODE) THEN
      DO 60 I=1,NPEO
 60   MXWORK=MAX(MXWORK,NJOINT(I))
      END IF
      DO 70 I=1,NPEO
 70   IF (FATHER(I).EQ.0) GROUP(I)=-GROUP(I)
      CALL ISCRAT(PERSON,NPTOT,UNIT2,.TRUE.)
      CALL ISCRAT(GROUP,NPTOT,UNIT2,.TRUE.)
      CALL ISCRAT(NGEN,NLOCI*NPEO,UNIT2,.TRUE.)
      IF (.NOT.PMODE) CALL ISCRAT(NJOINT,NPEO,UNIT2,.TRUE.)
      CALL ISCRAT(GPOINT,NLOCI*NPEO,UNIT2,.TRUE.)
      CALL ISCRAT(GLIST,LG,UNIT2,.TRUE.)
      IF (MVAR.GT.0) CALL RSCRAT(VAR,MVAR,UNIT2,.TRUE.)
      END

      SUBROUTINE INFER(FAMILY,FATHER,GLIST,GINFO,GPOINT,GROUP
     1,IERROR,LIST,MOTHER,NGEN,PERSON,PHEN,PHLIST,PPOINT,LG,MAXALL
     2,MAXGL,MAXPEO,NALL,NLIST,NPEO,NPHSET,NPPEND,LUMP,MENDEL
     3,ORDERD,XLINK)
C
C     THIS SUBROUTINE ELIMINATES UNNECESSARY GENOTYPES FOR
C     THE PEOPLE IN A PEDIGREE.  IT DOES SO BY THE ALGORITHM
C     OUTLINED IN LANGE AND GORADIA(1987) 'AN ALGORITHM FOR AUTOMATIC
C     GENOTYPE ELIMINATION.'  ON RETURN, GLIST WILL CONTAIN
C     THE POSSIBLE GENOTYPE LISTS FOR EACH PERSON.  GPOINT(I)
C     POINTS TO THE START OF THE LIST FOR I.  NGEN(I) IS THE
C     NUMBER OF GENOTYPES IN THE LIST FOR I.  ON ENTRY, PHEN(I)
C     IS THE PHENOTYPE OF I.  IF PHEN(I) IS LESS THAN 0, THEN
C     ABS(PHEN(I)) PROVIDES THE GENOTYPE OF I.  PHEN(I)=0 WHEN
C     THE PHENOTYPE IS UNOBSERVED.  OTHERWISE, LET K BE PPOINT(PHEN(I))
C     AND L BE PPOINT(PHEN(I)+1).  THEN THE LIST OF GENOTYPES FOR
C     THIS PHENOTYPE IS STORED IN PHLIST(K) TO PHLIST(L-1).
C
      INTEGER FAMILY(MAXPEO),FATHER(MAXPEO),GLIST(MAXGL)
     1,GINFO(MAXPEO),GPOINT(MAXPEO),GROUP(MAXPEO),IERROR(2)
     2,LIST(MAXALL),MOTHER(MAXPEO),NGEN(MAXPEO),PERSON(MAXPEO)
     3,PHEN(MAXPEO),PHLIST(NPHSET),PPOINT(NPPEND),DAD
      LOGICAL INFO,LUMP,MENDEL,ORDERD,REDO,XLINK
C
C     FIND THOSE ALLELES APPEARING IN THE PEDIGREE.
C
      IF (LUMP) THEN
      CALL AMALGM(LIST,PHEN,PHLIST,PPOINT,MAXPEO,NALL,NLIST,NPEO
     :,NPHSET,NPPEND)
      END IF
      IF (LUMP.AND.NLIST.LT.NALL-1) THEN
      NLIST=NLIST+1
      LIST(NLIST)=NALL+1
      ELSE
      NLIST=NALL
      DO 5 J=1,NLIST
 5    LIST(J)=J
      END IF
C
C     REDUCE THE GENOTYPIC SET OF AN INDIVIDUAL BASED ONLY ON HIS
C     PHENOTYPE AND NOT THOSE OF HIS RELATIVES.  IF THE LOCUS IS NOT
C     UNDERGOING REGULAR MENDELIAN SEGRATION, RETURN AT THIS POINT.
C
      DO 10 I=1,NPEO
      GINFO(I)=0
      CALL GSETUP(GLIST,GPOINT,GROUP,LIST,NGEN,PHEN,PHLIST,PPOINT
     1,I,IERROR(2),LG,MAXGL,MAXPEO,NALL,NLIST,NPHSET,NPPEND,ORDERD
     2,XLINK)
      IF (NGEN(I).EQ.0) IERROR(1)=PERSON(I)
 10   IF (IERROR(1).NE.0.OR.IERROR(2).NE.0) RETURN
C
C     FOR A SINGLE LOCUS WITH MUTATION RETURN.
C
      IF (.NOT.MENDEL) RETURN
C
C     MAIN LOOP OF THE SUBROUTINE.  AT EACH ITERATION LOOK
C     AT EVERY NUCLEAR FAMILY.  ATTEMPT TO REDUCE THE GENOTYPIC
C     SET OF EACH MEMBER BY ELIMINATING INCOMPATIBLE GENOTYPES.
C     THE CHILDREN OF ALREADY PROCESSED FAMILIES ARE MARKED BY
C     CHANGING THE SIGN OF THE NUMBER OF THEIR MOTHER.
C
      ITER=0
 60   LAST=ITER
      ITER=ITER+1
      INFO=.FALSE.
      DO 20 I=1,NPEO
      MOM=MOTHER(I)
      IF (MOM.LE.0) GO TO 20
      DAD=FATHER(I)
      FAMILY(1)=MOM
      FAMILY(2)=DAD
      REDO=GINFO(MOM).GE.LAST.OR.GINFO(DAD).GE.LAST
      NFAM=2
C
C     FIND ALL CHILDREN OF THE CURRENT PARENTAL PAIR, AND ADD THEM
C     TO THE NUCLEAR FAMILY.
C
      DO 30 J=1,NPEO
      IF (MOTHER(J).EQ.MOM.AND.FATHER(J).EQ.DAD) THEN
      NFAM=NFAM+1
      FAMILY(NFAM)=J
      MOTHER(J)=-MOTHER(J)
      REDO=REDO.OR.GINFO(J).GE.LAST
      END IF
 30   CONTINUE
C
C     IF NO NEW INFORMATION WAS GARNERED ON ANY FAMILY MEMBER
C     DURING THE PREVIOUS ITERATION, THEN GO ON TO THE NEXT FAMILY.
C
      IF (.NOT.REDO) GO TO 20
C
C     DO THE INFERENCING TO ELIMINATE GENOTYPES.
C
      CALL EXCLUD(FAMILY,GLIST,GPOINT,GROUP,NGEN,DAD,MAXGL,MAXPEO
     1,MOM,NFAM,XLINK)
C
C     REPACK GLIST FOR EACH PERSON IN THE FAMILY.  NOTE IF
C     INFORMATION HAS BEEN GAINED OR IF ANYONE'S GENOTYPE LIST
C     IS NOW EMPTY.
C
      DO 40 J=1,NFAM
      K=FAMILY(J)
      CALL GPACK(GLIST,GPOINT,NGEN,PERSON,K,IERROR(1),LG,LOSS,MAXGL
     1,MAXPEO,NPEO)
      IF (IERROR(1).NE.0) RETURN
      IF (LOSS.GT.0) THEN
      GINFO(K)=ITER
      INFO=.TRUE.
      END IF
 40   CONTINUE
 20   CONTINUE
C
C     RESET THE MOTHER NUMBERS FOR ALL PEDIGREE MEMBERS.
C
      DO 50 J=1,NPEO
 50   MOTHER(J)=-MOTHER(J)
C
C     IF INFORMATION HAS BEEN GAINED ON ANYONE AT THIS
C     ITERATION, GO BACK FOR ANOTHER PASS THROUGH THE PEDIGREE.
C
      IF (INFO) GO TO 60
      END

      SUBROUTINE AMALGM(LIST,PHEN,PHLIST,PPOINT,MAXPEO,NALL,NLIST
     :,NPEO,NPHSET,NPPEND)
C
C     THIS SUBROUTINE DETERMINES WHICH ALLELES AT A LOCUS ARE
C     PRESENT AMONG THOSE PEDIGREE MEMBERS TYPED AT THE LOCUS.
C
      INTEGER GENE(2),LIST(NALL),PHEN(MAXPEO),PHLIST(NPHSET)
     :,PPOINT(NPPEND),RETAIN,SUB
C
C     CHECK WHETHER A PERSON HAS BEEN TYPED.  IF SO DISTINGUISH TWO
C     CASES DEPENDING ON WHETHER HE HAS AN ASSIGNED GENOTYPE OF AN
C     ASSIGNED PHENOTYPE.
C
      NLIST=0
      DO 10 I=1,NPEO
      IF (PHEN(I).NE.0) THEN
      IF (PHEN(I).GT.0) THEN
      K1=PPOINT(PHEN(I))
      K2=PPOINT(PHEN(I)+1)-1
      KG=PHLIST(K1)
      ELSE
      K1=1
      K2=1
      KG=-PHEN(I)
      END IF
C
C     CONSIDER ALL POSSIBLE GENOTYPES KG COMPATIBLE WITH THE OBSERVED
C     GENOTYPE OR PHENOTYPE.
C
      DO 20 K=K1,K2
      IF (K.NE.K1) KG=PHLIST(K)
      GENE(1)=(KG-1)/NALL+1
      GENE(2)=KG-(KG-1)/NALL*NALL
C
C     INSERT THE TWO ALLELES OF EACH GENOTYPE INTO THE LIST OF OBSERVED
C     ALLELES.
C
      DO 30 J=1,2
      DO 40 L=1,NLIST
      IF (GENE(J).LT.LIST(L)) THEN
      GO TO 50
      ELSE IF (GENE(J).EQ.LIST(L)) THEN
      GO TO 30
      END IF
 40   CONTINUE
 50   RETAIN=LIST(L)
      SUB=GENE(J)
      NLIST=NLIST+1
      DO 60 M=L,NLIST
      LIST(M)=SUB
      SUB=RETAIN
 60   IF (M.LT.NLIST) RETAIN=LIST(M+1)
 30   CONTINUE
 20   CONTINUE
      END IF
 10   CONTINUE
      END

      SUBROUTINE GSETUP(GLIST,GPOINT,GROUP,LIST,NGEN,PHEN,PHLIST
     1,PPOINT,I,IERROR,LG,MAXGL,MAXPEO,NALL,NLIST,NPHSET,NPPEND
     2,ORDERD,XLINK)
C
C     THIS SUBROUTINE ADDS THE POSSIBLE GENOTYPES OF I TO THE
C     END OF GLIST.  IT ALSO DEFINES GPOINT(I) AND THE NUMBER
C     OF GENOTYPES NGEN(I).  IF I DOES NOT HAVE AN OBSERVED
C     PHENOTYPE, THEN ALL POSSIBLE GENOTYPES ARE INCLUDED.
C     FOR A MALE AT AN XLINKED LOCUS, THE HEMIZYGOUS GENOTYPES
C     ARE IDENTIFIED WITH THE CORRESPONDING HOMOZYGOUS GENOTYPES
C     OF THE FEMALE.
C
      INTEGER GLIST(MAXGL),GPOINT(MAXPEO),GROUP(MAXPEO),LIST(NLIST)
     1,NGEN(MAXPEO),PHEN(MAXPEO),PHLIST(NPHSET),PPOINT(NPPEND)
      LOGICAL ORDERD,XLINK
C
C     SPECIFY THE LOCATION FOR THE START OF I'S GENOTYPES.
C
      GPOINT(I)=LG+1
C
C     CHECK WHETHER I HAS AN OBSERVED PHENOTYPE.  IF NOT,
C     THEN CREATE ALL POSSIBLE GENOTYPES FOR HIM.
C
      IP=PHEN(I)
      IF (IP.EQ.0) THEN
C
C     I IS MALE AND THIS IS AN X-LINKED LOCUS.  INCLUDE ONLY
C     THE HEMIZYGOUS GENOTYPES.
C
      IF (XLINK.AND.MOD(GROUP(I),2).EQ.1) THEN
      IF (LG+NLIST+NLIST.GT.MAXGL) GO TO 10
      DO 20 K=1,NLIST
 20   CALL PLUGIN(GLIST,LIST(K),LIST(K),LG)
C
C     I IS FEMALE OR THE LOCUS IS AUTOSOMAL.
C
      ELSE
      IF (LG+2*NLIST*NLIST.GT.MAXGL) GO TO 10
      DO 30 K=1,NLIST
      DO 30 L=K,NLIST
      CALL PLUGIN(GLIST,LIST(K),LIST(L),LG)
 30   IF (L.NE.K) CALL PLUGIN(GLIST,LIST(L),LIST(K),LG)
      END IF
C
C     FIND THE LIMITS FOR THE POSSIBLE GENOTYPES OF I.  NOTE
C     THAT PHEN(I) POINTS TO THE POINTER PPOINT, WHICH IN TURN
C     POINTS TO THE LIST PHLIST OF GENOTYPES FOR EACH PHENOTYPE.
C
      ELSE IF (IP.GT.0) THEN
      K1=PPOINT(IP)
      K2=PPOINT(IP+1)-1
      KTOT=K2-K1+1
C
C     LOAD THE POSSIBLE HEMIZYGOUS GENOTYPES IN GLIST IF THE
C     LOCUS IS XLINKED AND I IS MALE.
C
      IF (XLINK.AND.MOD(GROUP(I),2).EQ.1) THEN
      IF (LG+KTOT+KTOT.GT.MAXGL) GO TO 10
      DO 40 K=K1,K2
      KG=PHLIST(K)
      KG1=(KG-1)/NALL+1
      KG2=KG-(KG-1)/NALL*NALL
 40   IF (KG1.EQ.KG2) CALL PLUGIN(GLIST,KG1,KG2,LG)
C
C     LOAD THE POSSIBLE GENOTYPES IN GLIST IF THE LOCUS IS
C     AUTOSOMAL OR I IS FEMALE.
C
      ELSE
      IF (LG+4*KTOT.GT.MAXGL) GO TO 10
      DO 50 K=K1,K2
      KG=PHLIST(K)
      KG1=(KG-1)/NALL+1
      KG2=KG-(KG-1)/NALL*NALL
      CALL PLUGIN(GLIST,KG1,KG2,LG)
 50   IF (KG1.NE.KG2.AND..NOT.ORDERD) CALL PLUGIN(GLIST,KG2,KG1,LG)
      END IF
      ELSE
C
C     THE PHENOTYPE OF I COINCIDES WITH A SINGLE GENOTYPE.
C
      KG=-IP
      KG1=(KG-1)/NALL+1
      KG2=KG-(KG-1)/NALL*NALL
C
C     IF THE LOCUS IS XLINKED AND I IS A MALE, CHECK THAT THE
C     GENOTYPE IS HEMIZYGOUS.
C
      IF (XLINK.AND.MOD(GROUP(I),2).EQ.1) THEN
      IF (LG+2.GT.MAXGL) GO TO 10
      IF (KG1.EQ.KG2) CALL PLUGIN(GLIST,KG1,KG2,LG)
C
C     I IS A FEMALE OR THE LOCUS IS AUTOSOMAL.
C
      ELSE
      IF (LG+4.GT.MAXGL) GO TO 10
      CALL PLUGIN(GLIST,KG1,KG2,LG)
      IF (KG1.NE.KG2.AND..NOT.ORDERD) CALL PLUGIN(GLIST,KG2,KG1,LG)
      END IF
      END IF
C
C     COMPUTE THE NUMBER OF GENOTYPES COMPATIBLE WITH I'S PHENOTYPE.
C
      NGEN(I)=(LG-GPOINT(I)+1)/2
      RETURN
C
C     RETURN WITH AN ERROR MESSAGE IF THERE IS INSUFFICIENT SPACE.
C
 10   IERROR=1
      NGEN(I)=1
      END

      SUBROUTINE PLUGIN(GLIST,GENE1,GENE2,LG)
C
      INTEGER GLIST(*),GENE1,GENE2
C
      LG=LG+1
      GLIST(LG)=GENE1
      LG=LG+1
      GLIST(LG)=GENE2
      END

      SUBROUTINE EXCLUD(FAMILY,GLIST,GPOINT,GROUP,NGEN,DAD,MAXGL
     1,MAXPEO,MOM,NFAM,XLINK)
C
C     THIS SUBROUTINE TAKES A NUCLEAR FAMILY AND SAVES
C     THOSE GENOTYPES WHICH ARE CONSISTENT ACROSS ALL FAMILY
C     MEMBERS.  THE GENOTYPES SAVED WILL BE DENOTED IN GLIST BY
C     BY A POSITIVE NUMBER CODE.
C
      INTEGER FAMILY(MAXPEO),GLIST(MAXGL),GPOINT(MAXPEO)
     1,GROUP(MAXPEO),NGEN(MAXPEO),DAD,GAMETE
      LOGICAL COMPAT,GIRL,XLINK
C
C     TAKE THE NEGATIVES OF THE GENOTYPIC ENTRIES IN GLIST FOR
C     EACH FAMILY MEMBER.
C
      DO 10 I=1,NFAM
      J=FAMILY(I)
      DO 10 K=GPOINT(J),GPOINT(J)+2*NGEN(J)-1
 10   GLIST(K)=-GLIST(K)
C
C     GENERATE ALL POSSIBLE GENOTYPES FOR THE PARENTS.
C
      DO 20 I=GPOINT(MOM),GPOINT(MOM)+2*NGEN(MOM)-1,2
      DO 20 J=GPOINT(DAD),GPOINT(DAD)+2*NGEN(DAD)-1,2
C
C     CHECK WHETHER EACH SIB HAS AT LEAST ONE GENOTYPE COMPATIBLE
C     WITH THE ZYGOTES FORMED FROM THESE GENOTYPES.  IF NOT, GO ON
C     TO THE NEXT PAIR OF PARENTAL GENOTYPES.
C
      DO 30 K=3,NFAM
      L=FAMILY(K)
      GIRL=MOD(GROUP(L),2).EQ.0
      DO 40 M=GPOINT(L),GPOINT(L)+2*NGEN(L)-1,2
      GAMETE=ABS(GLIST(M))
      COMPAT=GAMETE.EQ.ABS(GLIST(I)).OR.GAMETE.EQ.ABS(GLIST(I+1))
      IF (.NOT.COMPAT) GO TO 40
      IF (.NOT.XLINK.OR.GIRL) THEN
      GAMETE=ABS(GLIST(M+1))
      COMPAT=GAMETE.EQ.ABS(GLIST(J)).OR.GAMETE.EQ.ABS(GLIST(J+1))
      ELSE
      COMPAT=.TRUE.
      END IF
      IF (COMPAT) GO TO 30
 40   CONTINUE
      GO TO 20
 30   CONTINUE
C
C     SAVE THE PAIR OF PARENTAL GENOTYPES AND EACH SIB GENOTYPE
C     COMPATIBLE WITH THEM.
C
      GLIST(I)=ABS(GLIST(I))
      GLIST(I+1)=ABS(GLIST(I+1))
      GLIST(J)=ABS(GLIST(J))
      GLIST(J+1)=ABS(GLIST(J+1))
      DO 50 K=3,NFAM
      L=FAMILY(K)
      GIRL=MOD(GROUP(L),2).EQ.0
      DO 60 M=GPOINT(L),GPOINT(L)+2*NGEN(L)-1,2
      GAMETE=ABS(GLIST(M))
      COMPAT=GAMETE.EQ.ABS(GLIST(I)).OR.GAMETE.EQ.ABS(GLIST(I+1))
      IF (.NOT.COMPAT) GO TO 60
      IF (.NOT.XLINK.OR.GIRL) THEN
      GAMETE=ABS(GLIST(M+1))
      COMPAT=GAMETE.EQ.ABS(GLIST(J)).OR.GAMETE.EQ.ABS(GLIST(J+1))
      ELSE
      COMPAT=.TRUE.
      END IF
      IF (COMPAT) THEN
      GLIST(M)=ABS(GLIST(M))
      GLIST(M+1)=ABS(GLIST(M+1))
      END IF
 60   CONTINUE
 50   CONTINUE
 20   CONTINUE
      END

      SUBROUTINE GPACK(GLIST,GPOINT,NGEN,PERSON,I,IERROR,LG,LOSS,MAXGL
     1,MAXPEO,NPEO)
C
C     THIS SUBROUTINE ELIMINATES GENOTYPES IN GLIST CORRESPONDING
C     TO INDIVIDUAL I.  THE GENOTYPES WHICH ARE TO BE DISCARDED ARE
C     DENOTED BY NEGATIVE NUMBERS.  THE BLOCKS OF GLIST TO THE RIGHT
C     OF I ARE THEN REPACKED, AND GPOINT IS RESET FOR THESE BLOCKS.
C
      INTEGER GLIST(MAXGL),GPOINT(MAXPEO),NGEN(MAXPEO),PERSON(MAXPEO)
C
C     REPACK THE BLOCK OF GLIST CORESPONDING TO I.
C
      ISTART=GPOINT(I)
      IEND=ISTART+2*NGEN(I)-1
      L=ISTART
      DO 10 K=ISTART,IEND
      IF (GLIST(K).GT.0) THEN
      GLIST(L)=GLIST(K)
      L=L+1
      END IF
 10   CONTINUE
C
C     COMPUTE THE NUMBER OF LOST GENOTYPES.
C
      LOSS=K-L
      IF (LOSS.GT.0) THEN
      NGEN(I)=NGEN(I)-LOSS/2
C
C     MOVE ALL BLOCKS WHICH LIE TO THE RIGHT OF I.
C
      DO 20 K=IEND+1,LG
      GLIST(L)=GLIST(K)
 20   L=L+1
C
C     RESET GPOINT FOR THE BLOCKS SO MOVED.
C
      DO 30 J=1,NPEO
      JSTART=GPOINT(J)
 30   IF (JSTART.GT.ISTART) GPOINT(J)=JSTART-LOSS
      LG=LG-LOSS
      END IF
      IF (NGEN(I).LE.0) IERROR=PERSON(I)
      END

      SUBROUTINE COUNT(GLIST,GPOINT,NGEN,NHOM,NJOINT,MAXGL,MAXPEO,NLOCI
     1,NPEO)
C
C     THIS SUBROUTINE COUNTS THE NUMBER OF MULTIPLE LOCUS GENOTYPES
C     FOR EACH PERSON.  IT ALSO COUNTS THE NUMBER OF HOMOZYGOUS
C     GENOTYPES AT EACH LOCUS FOR EACH PERSON.  NOTE THAT PATERNAL
C     AND MATERNAL CONTRIBUTIONS ARE DISTINGUISHED.
C
      INTEGER GLIST(MAXGL),GPOINT(NLOCI,MAXPEO),NGEN(NLOCI,MAXPEO)
     1,NHOM(NLOCI,MAXPEO),NJOINT(MAXPEO)
C
      DO 10 I=1,NPEO
      NGENES=1
      DO 20 LOCUS=1,NLOCI
      NGENES=NGENES*NGEN(LOCUS,I)
      NHOMZY=0
      JP=GPOINT(LOCUS,I)
      DO 30 J=1,NGEN(LOCUS,I)
      IF (GLIST(JP).EQ.GLIST(JP+1)) NHOMZY=NHOMZY+1
 30   JP=JP+2
 20   NHOM(LOCUS,I)=NHOMZY
 10   NJOINT(I)=NGENES
      END

      SUBROUTINE ORDER(RARRAY,FATHER,IARRAY,MOTHER,NGEN,NHOM,NJOINT
     1,PERM,IPED,LENI,LENR,LI,MAXLA,MAXLST,MAXPEO,MAXSIZ,NLOCI,NODES
     2,NPEO,UNIT2,UNIT3,PEDID,PMODE)
C
C     THIS SUBROUTINE PREPARES THE GROUND FOR FINDING A BEST OR
C     NEARLY BEST PERMUTATION FOR THE PEOPLE OR LOCUS-PERSON
C     COMBINATIONS FOR THE PEDIGREE.  IT COMPUTES THE NUMBER OF
C     NODES AND NUMBER OF EDGES IN THE ADJACENCY GRAPH.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION RARRAY(LENR)
      INTEGER FATHER(MAXPEO),IARRAY(LENI),MOTHER(MAXPEO)
     1,NGEN(NLOCI,MAXPEO),NHOM(NLOCI,MAXPEO),NJOINT(MAXPEO)
     2,PERM(NODES),UNIT2,UNIT3
      CHARACTER*8 PEDID
      LOGICAL PMODE
C
      M1=NODES+1
      IF (2*NODES.GT.LENR) CALL PSTOP(IPED,UNIT3,'R',PEDID,'ORDER ')
      N1=NODES+1
      N2=NODES+N1
      LENII=LENI-N2+1
      IF (LENII.LE.0) CALL PSTOP(IPED,UNIT3,'I',PEDID,'ORDER ')
      CALL GRAPH(RARRAY,RARRAY(M1),IARRAY,FATHER,MOTHER,IARRAY(N2)
     :,NGEN,NHOM,NJOINT,PERM,IARRAY(N1),IPED,LENII,MAXPEO,NLOCI,NODES
     :,NPEO,UNIT3,PEDID,PMODE)
      CALL SETUP(FATHER,MOTHER,NGEN,NHOM,NJOINT,IARRAY,IPED,LS,MAXPEO
     1,LENI,MAXSIZ,NLOCI,NPEO,NSETS,UNIT3,PEDID,PMODE)
      MAXS=LS
      N1=MAXS+1
      N2=2*NSETS+N1
      N3=2*NSETS+N2
      N4=NODES+N3
      N5=NODES+N4
      LENII=LENI-N5+1
      IF (LENII.LE.0) CALL PSTOP(IPED,UNIT3,'I',PEDID,'ORDER ')
      IF (PMODE) THEN
      CALL INSTRC(IARRAY(N1),IARRAY(N2),IARRAY(N5),PERM,IARRAY
     1,IARRAY(N3),IARRAY(N4),NGEN,IPED,LI,LENR,LENII,MAXLA,MAXLST
     2,MAXS,NODES,NSETS,UNIT2,UNIT3,PEDID)
      ELSE
      CALL INSTRC(IARRAY(N1),IARRAY(N2),IARRAY(N5),PERM,IARRAY
     1,IARRAY(N3),IARRAY(N4),NJOINT,IPED,LI,LENR,LENII,MAXLA,MAXLST
     2,MAXS,NODES,NSETS,UNIT2,UNIT3,PEDID)
      END IF
      END

      SUBROUTINE GRAPH(LNCOST,LNWGHT,AMOUNT,FATHER,MOTHER,NEAR,NGEN
     :,NHOM,NJOINT,PERM,POINT,IPED,LENI,MAXPEO,NLOCI,NODES,NPEO
     :,UNIT3,PEDID,PMODE)
C
C     THIS SUBROUTINE SPECIFIES THE NEIGHBORS FOR EACH NODE OF THE
C     ADJACENCY GRAPH.  THESE ARE STORED AS LISTS IN NEAR, WITH
C     START LOCATIONS RECORDED IN POINT AND NUMBERS OF NEIGHBORS
C     RECORDED IN AMOUNT.  THIS NEIGHBORHOOD STRUCTURE IS THEN PASSED
C     TO GREEDY TO CHOOSE A GOOD REMOVAL PERMUTATION FOR THE NODES.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION LNCOST(NODES),LNWGHT(NODES)
      INTEGER AMOUNT(NODES),FATHER(MAXPEO),MOTHER(MAXPEO),NEAR(LENI)
     :,NGEN(NLOCI,MAXPEO),NHOM(NLOCI,MAXPEO),NJOINT(MAXPEO)
     :,PERM(NODES),POINT(NODES),UNIT3
      CHARACTER*8 PEDID
      LOGICAL CONECT,PMODE,SPLIT
C
      IF (.NOT.PMODE) THEN
C
C     IN NON-PRODUCT MODE, CREATE A LIST OF NEIGHBORS FOR EACH PERSON
C     IN THE PEDIGREE.
C
      NEXT=1
      DO 10 I=1,NPEO
      POINT(I)=NEXT
      NEAR(NEXT)=I
      NEXT=NEXT+1
      ISTART=NEXT
      DO 20 J=1,NPEO
      IF (FATHER(J).EQ.I.OR.MOTHER(J).EQ.I.OR.FATHER(I).EQ.J
     :.OR.MOTHER(I).EQ.J) THEN
      IF (NEXT.GT.LENI) GO TO 1000
      NEAR(NEXT)=J
      NEXT=NEXT+1
      END IF
 20   CONTINUE
 10   AMOUNT(I)=NEXT-ISTART
      ELSE
C
C     IN PRODUCT MODE CONSIDER ALL PAIRS (LOCUSI,I) AND (LOCUSJ,J) OF
C     LOCUS-PERSON COMBINATIONS AND DECIDE IF THEY ARE ADJACENT.  AS A
C     PRELIMINARY LABEL THOSE PEOPLE WHO ARE PARENTS.
C
      DO 30 I=1,NPEO
 30   PERM(I)=I
      DO 40 I=1,NPEO
      J=FATHER(I)
      IF (J.EQ.0) GO TO 40
      PERM(J)=-J
      L=MOTHER(I)
      PERM(L)=-L
 40   CONTINUE
      NEXT=1
      L=0
      DO 50 I=1,NPEO
      DO 60 LOCUSI=1,NLOCI
      L=L+1
      POINT(L)=NEXT
      NEAR(NEXT)=L
      NEXT=NEXT+1
      LSTART=NEXT
      DO 70 J=1,NPEO
      IF (I.EQ.J) THEN
C
C     SUCH A PAIR IS CONNECTED BY AN EDGE IF I=J AND IF: EITHER A)
C     I IS A PARENT AND LOCUSI AND LOCUSJ ARE NOT SPLIT IN I, OR
C     B) LOCUSI AND LOCUSJ ARE NOT SPLIT IN THE FATHER OF I, OR C)
C     THEY ARE NOT SPLIT IN THE MOTHER OF I.
C
      DO 80 LOCUSJ=1,NLOCI
      IF (LOCUSJ.NE.LOCUSI) THEN
      CONECT=.FALSE.
      IF (PERM(I).LT.0)
     :CONECT=.NOT.SPLIT(NHOM,I,LOCUSI,LOCUSJ,NLOCI)
      IF (.NOT.CONECT.AND.FATHER(I).NE.0) THEN
      CONECT=.NOT.SPLIT(NHOM,FATHER(I),LOCUSI,LOCUSJ,NLOCI)
     :.OR..NOT.SPLIT(NHOM,MOTHER(I),LOCUSI,LOCUSJ,NLOCI)
      END IF
      IF (CONECT) THEN
      IF (NEXT.GT.LENI) GO TO 1000
      NEAR(NEXT)=NLOCI*(J-1)+LOCUSJ
      NEXT=NEXT+1
      END IF
      END IF
 80   CONTINUE
C
C     ALTERNATIVELY, THE PAIR IS CONNECTED IF I AND J ARE RELATED
C     AS PARENT AND CHILD AND LOCUSI AND LOCUSJ ARE NOT SPLIT IN
C     THE PARENT.
C
      ELSE IF (FATHER(J).EQ.I) THEN
      DO 90 LOCUSJ=1,NLOCI
      IF (.NOT.SPLIT(NHOM,I,LOCUSI,LOCUSJ,NLOCI)) THEN
      IF (NEXT.GT.LENI) GO TO 1000
      NEAR(NEXT)=NLOCI*(J-1)+LOCUSJ
      NEXT=NEXT+1
      END IF
 90   CONTINUE
      ELSE IF (MOTHER(J).EQ.I) THEN
      DO 100 LOCUSJ=1,NLOCI
      IF (.NOT.SPLIT(NHOM,I,LOCUSI,LOCUSJ,NLOCI)) THEN
      IF (NEXT.GT.LENI) GO TO 1000
      NEAR(NEXT)=NLOCI*(J-1)+LOCUSJ
      NEXT=NEXT+1
      END IF
 100  CONTINUE
      ELSE IF (FATHER(I).EQ.J) THEN
      DO 110 LOCUSJ=1,NLOCI
      IF (.NOT.SPLIT(NHOM,J,LOCUSI,LOCUSJ,NLOCI)) THEN
      IF (NEXT.GT.LENI) GO TO 1000
      NEAR(NEXT)=NLOCI*(J-1)+LOCUSJ
      NEXT=NEXT+1
      END IF
 110  CONTINUE
      ELSE IF (MOTHER(I).EQ.J) THEN
      DO 120 LOCUSJ=1,NLOCI
      IF (.NOT.SPLIT(NHOM,J,LOCUSI,LOCUSJ,NLOCI)) THEN
      IF (NEXT.GT.LENI) GO TO 1000
      NEAR(NEXT)=NLOCI*(J-1)+LOCUSJ
      NEXT=NEXT+1
      END IF
 120  CONTINUE
      END IF
 70   CONTINUE
 60   AMOUNT(L)=NEXT-LSTART
 50   CONTINUE
      END IF
C
C     NOW CALL GREEDY TO FIND A GOOD REMOVAL PERMUTATION.
C
      IF (.NOT.PMODE) THEN
      CALL GREEDY(LNCOST,LNWGHT,AMOUNT,NEAR,PERM,POINT,NJOINT,IPED
     :,LENI,NEXT,NODES,UNIT3,PEDID)
      CALL EVAL(LNCOST,TOTAL,WORST,IPLACE,NODES)
C      PRINT*,'GREEDY COST, WORST, PLACE, PEDIGREE',TOTAL,WORST,IPLACE
C     1,IPED
      ELSE
      CALL GREEDY(LNCOST,LNWGHT,AMOUNT,NEAR,PERM,POINT,NGEN,IPED
     :,LENI,NEXT,NODES,UNIT3,PEDID)
      CALL EVAL(LNCOST,TOTAL,WORST,IPLACE,NODES)
C      PRINT*,'GREEDY COST, WORST, PLACE, PEDIGREE',TOTAL,WORST,IPLACE
C     1,IPED
      END IF
      RETURN
 1000 CALL PSTOP(IPED,UNIT3,'I',PEDID,'GRAPH ')
      END

      SUBROUTINE EVAL(LNCOST,TOTAL,WORST,IPLACE,NODES)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION LNCOST(NODES)
C
      TOTAL=EXP(LNCOST(1))
      WORST=TOTAL
      IPLACE=1
      DO 10 I=2,NODES
      CRIT=EXP(LNCOST(I))
      IF (CRIT.GT.WORST) THEN
      WORST=CRIT
      IPLACE=I
      END IF
 10   TOTAL=TOTAL+CRIT
      END

      FUNCTION SPLIT(NHOM,I,LOCUS1,LOCUS2,NLOCI)
C
C     THIS FUNCTION DECIDES IF TWO LOCI WITHIN A PERSON ARE SPLIT,
C     I.E., SEPARATED BY AN OBLIGATE HETEROZYGOUS LOCUS.
C
      INTEGER NHOM(NLOCI,*),FIRST
      LOGICAL SPLIT
C
      SPLIT=.FALSE.
      FIRST=MIN(LOCUS1,LOCUS2)
      LAST=MAX(LOCUS1,LOCUS2)
      DO 10 LOCUS=FIRST+1,LAST-1
      IF (NHOM(LOCUS,I).EQ.0) THEN
      SPLIT=.TRUE.
      RETURN
      END IF
 10   CONTINUE
      END

      SUBROUTINE GREEDY(LNCOST,LNWGHT,AMOUNT,NEAR,PERM,POINT,WEIGHT
     :,IPED,LENI,NEXT,NODES,UNIT3,PEDID)
C
C     THIS SUBROUTINE SELECTS A GOOD REMOVAL SEQUENCE BY THE GREEDY
C     METHOD.  ON RETURN, PERM WILL CONTAIN THIS SEQUENCE, AND LNCOST
C     WILL CONTAIN THE LOG COSTS FOR ELIMINATING THE VARIOUS NODES.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION LNCOST(NODES),LNWGHT(NODES)
      INTEGER AMOUNT(NODES),NEAR(LENI),PERM(NODES),POINT(NODES)
     :,WEIGHT(NODES),SPACE,UNIT3
      CHARACTER*8 PEDID
C
C     INITIALIZE THE PERMUTATION SEQUENCE AND THE LOG WEIGHTS.  ALSO
C     COMPUTE THE MARGINAL LOG COST FOR REMOVING ANY NODE.
C
      DO 10 I=1,NODES
      LNWGHT(I)=LOG(DBLE(WEIGHT(I)))
 10   PERM(I)=I
      DO 20 I=1,NODES
      SUM=0.0D0
      DO 30 J=POINT(I),POINT(I)+AMOUNT(I)
 30   SUM=SUM+LNWGHT(NEAR(J))
 20   LNCOST(I)=SUM
C
C     SELECT THE NODE HAVING THE SMALLEST LOG COST OF REMOVAL.
C
      DO 40 I=1,NODES
      BEST=LNCOST(PERM(I))
      JBEST=I
      DO 50 J=I+1,NODES
      IF (LNCOST(PERM(J)).LT.BEST) THEN
      BEST=LNCOST(PERM(J))
      JBEST=J
      END IF
 50   CONTINUE
      ISAVE=PERM(I)
      PERM(I)=PERM(JBEST)
      PERM(JBEST)=ISAVE
      IP=PERM(I)
C
C     CHECK TO SEE IF THERE IS SUFFICIENT SPACE TO UPDATE THE NODES
C     CONNECTED TO THE CURRENT NODE IP TO BE REMOVED.
C
      SPACE=0
      DO 60 J=POINT(IP)+1,POINT(IP)+AMOUNT(IP)
 60   SPACE=SPACE+AMOUNT(IP)+AMOUNT(NEAR(J))-1
      IF (NEXT+SPACE.GE.LENI) THEN
      CALL REPACK(AMOUNT,NEAR,POINT,NEXT,NODES)
      IF (NEXT+SPACE.GE.LENI) CALL PSTOP(IPED,UNIT3,'I',PEDID,'GREEDY')
      END IF
C
C     UPDATE THE NEIGHBORS AND LOG COST OF EACH NODE JP CONNECTED TO
C     THE CURRENT NODE IP.
C
      DO 70 J=POINT(IP)+1,POINT(IP)+AMOUNT(IP)
      JP=NEAR(J)
      NEAR(NEXT)=JP
      CALL JOIN(NEAR(POINT(IP)+1),NEAR(POINT(JP)+1),NEAR(NEXT+1)
     :,N,AMOUNT(IP),AMOUNT(JP),AMOUNT(IP)+AMOUNT(JP))
      K=NEXT
      SUM=LNWGHT(JP)
      DO 80 L=NEXT+1,NEXT+N
      IF (NEAR(L).NE.IP.AND.NEAR(L).NE.JP) THEN
      K=K+1
      NEAR(K)=NEAR(L)
      SUM=SUM+LNWGHT(NEAR(K))
      END IF
 80   CONTINUE
      LNCOST(JP)=SUM
C
C     DELETE THE FORMER REGION IN NEAR FOR THE NEIGHBOR JP OF IP.
C     RESET THE POINTER AND NUMBER OF NEIGHBORS FOR JP.
C
      DO 90 L=POINT(JP),POINT(JP)+AMOUNT(JP)
 90   NEAR(L)=0
      AMOUNT(JP)=N-2
      POINT(JP)=NEXT
 70   NEXT=K+1
C
C     DELETE THE REGION IN NEAR OF IP.
C
      DO 100 L=POINT(IP),POINT(IP)+AMOUNT(IP)
 100  NEAR(L)=0
 40   CONTINUE
      END

      SUBROUTINE REPACK(AMOUNT,NEAR,POINT,NEXT,NODES)
C
C     THIS SUBROUTINE REPACKS THE LIST OF NEIGHBORS FOR THE
C     CURRENTLY AVAILABLE NODES.  POINT(J) IS THE START LOCATION
C     IN NEAR FOR THE NEIGHBORS OF J.  J IS STORED IN NEAR AT
C     THIS LOCATION, AND AMOUNT(J) GIVES THE NUMBER OF NEIGHBORS
C     OF J.  ENTRIES OF NEAR TO BE DISCARDED ARE FLAGGED AS O'S
C     OR NEGATIVE NUMBERS.
C
      INTEGER AMOUNT(NODES),NEAR(*),POINT(NODES)
C
      I=1
      KEEP=0
      DO 10 J=1,NEXT-1
      IF (NEAR(J).GT.0) THEN
      IF (KEEP.EQ.0) THEN
      KEEP=AMOUNT(NEAR(J))
      POINT(NEAR(J))=I
      ELSE
      KEEP=KEEP-1
      END IF
      NEAR(I)=NEAR(J)
      I=I+1
      END IF
 10   CONTINUE
      NEXT=I
      END

      SUBROUTINE SETUP(FATHER,MOTHER,NGEN,NHOM,NJOINT,SETS,IPED,LS
     1,MAXPEO,MAXS,MAXSIZ,NLOCI,NPEO,NSETS,UNIT3,PEDID,PMODE)
C
C     THIS SUBROUTINE SETS UP THE INITIAL SETS FOR A PEDIGREE.  THE
C     FIRST ELEMENT IN A BLOCK FROM SETS IS THE NUMBER OF PEOPLE IN
C     THE BLOCK.  THE SECOND ELEMENT DETERMINES A POINTER ENTRY IN
C     APOINT.  IF SPACE IN THE BIG ARRAY HAS NOT YET BEEN ALLOCATED
C     FOR THE CURRENT BLOCK, THEN THE SECOND ELEMENT IS ZERO.  THE
C     REMAINING ELEMENTS IN THE BLOCK ARE THE PEOPLE COMPOSING THE
C     BLOCK.  IN PRODUCT MODE PEOPLE ARE REPLACED BY LOCUS-PERSON
C     COMBINATIONS.
C
      INTEGER FATHER(MAXPEO),MOTHER(MAXPEO),NGEN(NLOCI,MAXPEO)
     1,NHOM(NLOCI,MAXPEO),NJOINT(MAXPEO),SETS(MAXS),FIRST,PARENT
     2,SIZEI,SIZEK,SPREAD,UNIT3
      CHARACTER*8 PEDID
      LOGICAL PMODE
C
      LS=0
      IF (.NOT.PMODE) THEN
C
C     FOR EACH PERSON K, DEFINE THE SET CORRESPONDING TO HIS PRIOR-
C     PENETRANCE ARRAY.
C
      DO 10 K=1,NPEO
      IF (LS+3.GT.MAXS) GO TO 1000
      SETS(LS+1)=-1
      SETS(LS+2)=0
      LS=LS+3
      SETS(LS)=K
 10   MAXSIZ=MAX(MAXSIZ,NLOCI*NJOINT(K))
C
C     FOR EACH CHILD K, CREATE TWO PARENT-OFFSPRING SETS FOR HIS
C     TRANSMISSION ARRAYS.  NOTE THAT A CHILD NUMBER ALWAYS SUCCEEDS
C     A PARENT NUMBER.
C
      DO 20 K=1,NPEO
      I=FATHER(K)
      IF (I.NE.0) THEN
      IF (LS+8.GT.MAXS) GO TO 1000
      SETS(LS+1)=-2
      SETS(LS+2)=0
      SETS(LS+3)=I
      SETS(LS+4)=K
      J=MOTHER(K)
      SETS(LS+5)=-2
      SETS(LS+6)=0
      SETS(LS+7)=J
      LS=LS+8
      SETS(LS)=K
      END IF
 20   CONTINUE
      ELSE
C
C     IN PRODUCT MODE ALSO CONSIDER PENETRANCE-PRIOR ARRAYS FIRST.
C     BUT NOW DO SO LOCUS BY LOCUS.
C
      DO 30 K=1,NPEO
      IF (LS+3*NLOCI.GT.MAXS) GO TO 1000
      DO 40 LOCUS=1,NLOCI
      SETS(LS+1)=-1
      SETS(LS+2)=0
      LS=LS+3
 40   SETS(LS)=NLOCI*(K-1)+LOCUS
 30   CONTINUE
C
C     CREATE THE TRANSMISSION ARRAYS.
C
      DO 50 K=1,NPEO
      I=FATHER(K)
      IF (I.NE.0) THEN
      DO 60 PARENT=1,2
      IF (PARENT.EQ.2) I=MOTHER(K)
      FIRST=1
 70   LAST=NLOCI
      DO 80 LOCUS=FIRST+1,NLOCI
      IF (NHOM(LOCUS,I).EQ.0) THEN
      LAST=LOCUS
      GO TO 90
      END IF
 80   CONTINUE
 90   SPREAD=LAST-FIRST+1
      IF (LS+2*(SPREAD+1).GT.MAXS) GO TO 1000
      SETS(LS+1)=-2*SPREAD
      LS=LS+2
      SETS(LS)=0
      SIZEI=SPREAD
      SIZEK=SPREAD
      DO 100 LOCUS=FIRST,LAST
      SIZEI=SIZEI*NGEN(LOCUS,I)
      SIZEK=SIZEK*NGEN(LOCUS,K)
      LS=LS+1
      SETS(LS)=NLOCI*(I-1)+LOCUS
 100  SETS(LS+SPREAD)=NLOCI*(K-1)+LOCUS
      MAXSIZ=MAX(MAXSIZ,SIZEI,SIZEK)
      LS=LS+SPREAD
      IF (LAST.LT.NLOCI) THEN
      FIRST=LAST
      GO TO 70
      END IF
 60   CONTINUE
      END IF
 50   CONTINUE
      END IF
      NSETS=0
      DO 110 J=1,LS
 110  IF (SETS(J).LT.0) NSETS=NSETS+1
      RETURN
 1000 CALL PSTOP(IPED,UNIT3,'I',PEDID,'SETUP ')
      END

      SUBROUTINE PSTOP(IPED,LOUT,C,PEDID,SUB)
C
C     THIS SUBROUTINE STOPS THE PROGRAM BECAUSE OF INSUFFICIENT SPACE.
C
      CHARACTER C,NAME*7,PEDID*8,SUB*6
C
      NAME='  ARRAY'
      NAME(2:2)=C
      WRITE(LOUT,10) SUB,NAME,IPED,PEDID
 10   FORMAT(/,' *** ERROR *** HALTED IN SUBROUTINE ',A6
     1,' AS ',A7,' WAS TOO SMALL. AT STOP,'
     2,' PEDIGREE NUMBER',I4,' WITH ID ',A8,' WAS BEING'
     3,' PROCESSED.')
      CALL EXIT( 16 )
      END

      SUBROUTINE INSTRC(AMOUNT,APOINT,INSTR,PERM,SETS,START,UNION
     1,WEIGHT,IPED,LI,MAXA,MAXI,MAXLA,MAXLST,MAXS,NODES,NSETS,UNIT2
     2,UNIT3,PEDID)
C
C     THIS SUBROUTINE CREATES THE INSTRUCTION VECTOR FOR COMPUTING
C     THE LIKELIHOOD OF A PEDIGREE.
C
      INTEGER AMOUNT(2*NSETS),APOINT(2*NSETS),INSTR(MAXI),PERM(NODES)
     1,SETS(MAXS),START(NODES),UNION(NODES),WEIGHT(NODES),PIVOT,RANK
     2,SIZE,UNIT2,UNIT3
      CHARACTER*8 PEDID
C
      LA=1
      LI=1
      LP=0
      LS=MAXS
C
C     GIVE THE INSTRUCTION FOR CREATING THE PENETRANCE-PRIOR ARRAYS.
C
      IF (3.GT.MAXI) CALL PSTOP(IPED,UNIT3,'I',PEDID,'INSTRC')
      INSTR(LI)=-1
      MAXLST=MAX(MAXLST,1)
      DO 10 K=1,NODES
      LP=LP+1
      SETS(3*(K-1)+2)=-LP
      APOINT(LP)=LA
      AMOUNT(LP)=WEIGHT(K)
 10   LA=LA+WEIGHT(K)
C
C     GIVE THE INSTRUCTIONS FOR CREATING THE TRANSMISSION ARRAYS.
C
      INSTR(LI+1)=-2
      LI=LI+2
      INSTR(LI)=LA
      DO 20 K=3*NODES+2,MAXS
      IF (SETS(K).EQ.0) THEN
      RANK=ABS(SETS(K-1))
      MAXLST=MAX(MAXLST,RANK)
      SIZE=1
      DO 30 L=K+1,K+RANK
 30   SIZE=SIZE*WEIGHT(SETS(L))
      IF (LI+2.GT.MAXI) CALL PSTOP(IPED,UNIT3,'I',PEDID,'INSTRC')
      INSTR(LI+1)=SETS(K+1)
      LI=LI+2
      INSTR(LI)=SETS(K+RANK)
      LP=LP+1
      SETS(K)=-LP
      APOINT(LP)=LA
      AMOUNT(LP)=SIZE
      LA=LA+SIZE
      END IF
 20   CONTINUE
      MAXLA=MAX(MAXLA,LA)
*       write(*,*) 'maxla ',la,maxla,maxa
      IF (LA.GT.MAXA) then
*       write(*,*) ' Error1 ',la,maxa
       CALL PSTOP(IPED,UNIT3,'R',PEDID,'INSTRC')
      endif


C     NEXT PREPARE THE INSTRUCTIONS FOR THE ARRAY OPERATIONS USED
C     IN COMPUTING THE PEDIGREE LIKELIHOOD.
C
      DO 40 INODE=1,NODES
      I=PERM(INODE)
C
C     SEARCH THROUGH SETS AND IDENTIFY THOSE SETS CONTAINING NODE I.
C
      ISETS=0
      DO 50 J=1,LS
      IF (SETS(J).EQ.I) THEN
      ISETS=ISETS+1
      DO 60 K=J,1,-1
 60   IF (SETS(K).LE.0) GO TO 70
 70   START(ISETS)=K-1
      END IF
 50   CONTINUE
C
C     NOW THAT THE I PARTICIPATING SETS HAVE BEEN FOUND, DETERMINE
C     THE INSTRUCTIONS FOR A PURE MULTIPLY, A MULTIPLY AND ADD, OR
C     A PURE ADD.
C
 80   IF (ISETS.GE.2) THEN
C
C     FOR A PURE MULTIPLY, USE A GREEDY APPROACH TO FIND THE BEST
C     PAIR OF ARRAYS TO MULTIPLY.
C
      MINSIZ=0
      DO 90 J=1,ISETS
      JS=START(J)
      DO 100 K=J+1,ISETS
      KS=START(K)
      CALL JOIN(SETS(JS+2),SETS(KS+2),UNION,RANK,ABS(SETS(JS))
     1,ABS(SETS(KS)),NODES)
      SIZE=1
      DO 110 L=1,RANK
 110  SIZE=SIZE*WEIGHT(UNION(L))
      IF (MINSIZ.EQ.0) MINSIZ=SIZE+1
      IF (SIZE.LT.MINSIZ) THEN
      M=J
      N=K
      MS=JS
      NS=KS
      MINSIZ=SIZE
      END IF
 100  CONTINUE
 90   CONTINUE
C
C     FIND THE UNION SET FOR THE TWO SETS SELECTED AND THE SIZE
C     OF THE CORRESPONDING UNION SET ARRAY.
C
      CALL JOIN(SETS(MS+2),SETS(NS+2),UNION,RANK,ABS(SETS(MS))
     1,ABS(SETS(NS)),NODES)
      MAXLST=MAX(MAXLST,RANK)
      SIZE=1
      DO 120 L=1,RANK
      IF (UNION(L).EQ.I) IPLACE=L
 120  SIZE=SIZE*WEIGHT(UNION(L))
      IF (ISETS.EQ.2.AND.RANK.GT.1) SIZE=SIZE/WEIGHT(I)
C
C     PROVIDE THE INSTRUCTIONS FOR THE MULTIPLY OR MULTIPLY AND ADD.
C     FIRST CHECK THAT THERE IS ENOUGH SPACE IN THE BIG ARRAY AND
C     INSTRUCTION VECTOR .
C
      IF (LA+SIZE.GT.MAXA) CALL RINSTR(AMOUNT,APOINT,INSTR,IPED,LA,LI
     1,LP,MAXI,NSETS,UNIT3,PEDID)
*       write(*,*) 'la2 ',la,size,maxa
      IF (LA+SIZE.GT.MAXA) then
*       write(*,*) 'error2 ',la,size,maxa
       CALL PSTOP(IPED,UNIT3,'R',PEDID,'INSTRC')
      endif
      MRANK=ABS(SETS(MS))
      NRANK=ABS(SETS(NS))
      IF (LI+8+MRANK+NRANK+4*RANK.GT.MAXI) CALL PSTOP(IPED,UNIT3,'I'
     1,PEDID,'INSTRC')
      IF (ISETS.GT.2.OR.RANK.EQ.1) THEN
      PIVOT=0
      INSTR(LI+1)=-4
      ELSE
      PIVOT=I
      INSTR(LI+1)=-5
      END IF
      INSTR(LI+2)=I
      INSTR(LI+3)=APOINT(ABS(SETS(MS+1)))
      INSTR(LI+4)=APOINT(ABS(SETS(NS+1)))
      LI=LI+5
      INSTR(LI)=LA
      N1=LI+3*RANK+4
      N2=RANK+N1
      N3=RANK+N2
      CALL BLOCKS(INSTR(N1),INSTR,INSTR(N2),SETS(MS+2),INSTR(N3)
     1,SETS(NS+2),WEIGHT,LI,MAXI,NODES,PIVOT,MRANK,NRANK,RANK)
      LP=LP+1
      APOINT(LP)=LA
      AMOUNT(LP)=SIZE
      LA=LA+SIZE
      MAXLA=MAX(MAXLA,LA)
C
C     NEXT DELETE THE TWO SETS USED TO CREATE THE UNION SET.
C
      AMOUNT(ABS(SETS(MS+1)))=0
      AMOUNT(ABS(SETS(NS+1)))=0
      K=MS
      DO 160 L=MS+2+MRANK,NS-1
      SETS(K)=SETS(L)
 160  K=K+1
      DO 170 L=NS+2+NRANK,LS
      SETS(K)=SETS(L)
 170  K=K+1
      LS=LS-(MRANK+NRANK+4)
C
C     INSERT THE UNION SET IN SETS.
C
      LS=LS+1
      LSTART=LS
      SETS(LS)=-RANK
      IF (ISETS.EQ.2.AND.RANK.GT.1) SETS(LS)=-RANK+1
      LS=LS+1
      SETS(LS)=-LP
      DO 180 L=1,RANK
      IF (ISETS.GT.2.OR.RANK.EQ.1.OR.L.NE.IPLACE) THEN
      LS=LS+1
      SETS(LS)=UNION(L)
      END IF
 180  CONTINUE
C
C     RESET THE START POINTS FOR I PARTICIPATING SETS.
C
      IF (ISETS.GT.2.OR.RANK.EQ.1) THEN
      DO 190 K=2,ISETS
      IF (K.GT.M.AND.K.LT.N) THEN
      START(K-1)=START(K)-(MRANK+2)
      ELSE IF (K.GT.N) THEN
      START(K-2)=START(K)-(MRANK+NRANK+4)
      END IF
 190  CONTINUE
      ISETS=ISETS-1
      START(ISETS)=LSTART
      GO TO 80
      END IF
      ELSE
C
C     PROVIDE THE INSTRUCTIONS FOR A PURE ADD AND DELETE THE
C     CURRENT SET.
C
      IF (LI+4.GT.MAXI) CALL PSTOP(IPED,UNIT3,'I',PEDID,'INSTRC')
      INSTR(LI+1)=-6
      INSTR(LI+2)=APOINT(ABS(SETS(START(1)+1)))
      LI=LI+3
      INSTR(LI)=I
      K=START(1)
      AMOUNT(ABS(SETS(START(1)+1)))=0
      RANK=ABS(SETS(START(1)))
      DO 200 J=START(1)+2+RANK,LS
      SETS(K)=SETS(J)
 200  K=K+1
      LS=LS-(RANK+2)
      END IF
 40   CONTINUE
C
C     GIVE THE DETERMINATION SIGNAL FOR THE INSTRUCTION VECTOR AND
C     WRITE THE INSTRUCTIONS ON THE SCRATCH FILE.
C
      LI=LI+1
      INSTR(LI)=-7
      WRITE(UNIT2) LI
      CALL ISCRAT(INSTR,LI,UNIT2,.TRUE.)
      END

      SUBROUTINE BLOCKS(EXTENT,INSTR,PLIST,PSET,QLIST,QSET,WEIGHT,LI
     1,MAXI,NODES,PIVOT,PRANK,QRANK,RANK)
C
C     THIS SUBROUTINE CONSOLIDATES THE NODES FOR THE MUTIPLICAND AND
C     PRODUCT ARRAYS INTO BLOCKS.  IT THEN INSERTS THE INSTRUCTIONS
C     FOR A MULTIPLY AND ADD OR A PURE MULTIPLY.
C
      INTEGER PRANK,QRANK,RANK,EXTENT(RANK),INSTR(MAXI),PLIST(PRANK)
     1,PSET(PRANK),QLIST(QRANK),QSET(QRANK),WEIGHT(NODES),PIVOT,PLACE
     2,TYPE
C
C     IP AND IQ GIVE THE CURRENT POSITIONS IN THE EXISTING SETS PSET
C     AND QSET.  JP AND JQ THEN GIVE CURRENT POSITONS IN THE
C     CONSOLIDATED SETS PLIST AND QLIST TO BE SUBSTITUTED FOR PSET
C     AND QSET.  JR IS THE CURRENT NUMBER OF ENTRIES IN THE UNION OF
C     PLIST AND QLIST. PLACE IS THE POSITION OF THE INDEX OF SUMMATION
C     IN THE CONSOLIDATED UNION SET.  EXTENT PROVIDES THE EXTENTS FOR
C     THE VARIOUS DIMENSIONS IN THE CONSOLIDATED UNION ARRAY.
C
      IP=1
      IQ=1
      JP=0
      JQ=0
      JR=0
      PLACE=0
      TYPE=-2
C
C     CONSIDER THE NEXT NODE IN THE UNION OF PSET AND QSET.
C
 10   IF (IP.GT.PRANK) THEN
      INDP=NODES+1
      ELSE
      INDP=PSET(IP)
      END IF
      IF (IQ.GT.QRANK) THEN
      INDQ=NODES+1
      ELSE
      INDQ=QSET(IQ)
      END IF
      IF (INDP.LT.INDQ) THEN
      NUTYPE=1
      IND=INDP
      IP=IP+1
      ELSE IF (INDQ.LT.INDP) THEN
      NUTYPE=-1
      IND=INDQ
      IQ=IQ+1
      ELSE
      NUTYPE=0
      IND=INDP
      IP=IP+1
      IQ=IQ+1
      END IF
C
C     A BLOCK BOUNDARY IS HIT WHENEVER THE PIVOT NODE FOR A MULTIPLY
C     AND SUM IS ENCOUTERED.
C
      IF (IND.EQ.PIVOT) THEN
      TYPE=-2
      PLACE=JR+1
      END IF
C
C     INTERIOR TO A BLOCK UPDATE THE EXTENT OF THE BLOCK.
C
      IF (NUTYPE.EQ.TYPE) THEN
      EXTENT(JR)=EXTENT(JR)*WEIGHT(IND)
      ELSE
C
C     WHEN A BLOCK IS STARTED UPDATE PLIST OR QLIST OR BOTH.
C
      JR=JR+1
      EXTENT(JR)=WEIGHT(IND)
      IF (NUTYPE.EQ.1) THEN
      JP=JP+1
      PLIST(JP)=JR
      ELSE IF (NUTYPE.EQ.-1) THEN
      JQ=JQ+1
      QLIST(JQ)=JR
      ELSE
      JP=JP+1
      PLIST(JP)=JR
      JQ=JQ+1
      QLIST(JQ)=JR
      END IF
      TYPE=NUTYPE
      IF (IND.EQ.PIVOT) TYPE=-2
      END IF
      IF (IP.LE.PRANK.OR.IQ.LE.QRANK) GO TO 10
C
C     RECORD THE RELEVANT INFORMATION IN THE INSTRUCTION VECTOR.
C
      INSTR(LI+1)=JP
      INSTR(LI+2)=JQ
      LI=LI+3
      INSTR(LI)=JR
      IF (PLACE.NE.0) THEN
      LI=LI+1
      INSTR(LI)=PLACE
      END IF
      DO 20 J=1,JP
      LI=LI+1
 20   INSTR(LI)=PLIST(J)
      DO 30 J=1,JQ
      LI=LI+1
 30   INSTR(LI)=QLIST(J)
      DO 40 J=1,JR
      LI=LI+1
 40   INSTR(LI)=EXTENT(J)
      END

      SUBROUTINE RINSTR(AMOUNT,APOINT,INSTR,IPED,LA,LI,LP,MAXI,NSETS
     1,UNIT3,PEDID)
C
C     THIS SUBROUTINE CREATES THE REPACKING INSTRUCTIONS FOR THE
C     BIG ARRAY.  IT INSERTS IN INSTR THE SIZES OF ALTERNATING GOOD
C     BLOCKS AND JUNK BLOCKS, BEGINNING WITH A GOOD BLOCK.  A ZERO
C     VALUE FOR VARIABLE AMOUNT IS EMPLOYED TO SIGNAL JUNK.
C
      INTEGER AMOUNT(2*NSETS),APOINT(2*NSETS),INSTR(MAXI),UNIT3
      CHARACTER*8 PEDID
      LOGICAL BADBLK
C
      BADBLK=.FALSE.
      IPOINT=1
      LENBLK=0
      JUNK=0
      LI=LI+2
      LISAVE=LI
      DO 10 I=1,LP
      IF (IPOINT.LT.APOINT(I).AND..NOT.BADBLK) THEN
C
C     A GAP HAS BEEN FOUND, AND THE CURRENT BLOCK IS GOOD.  HENCE,
C     TERMINATE THE GOOD BLOCK, AND START A JUNK BLOCK.
C
      LI=LI+1
      IF (LI.GT.MAXI) GO TO 1000
      INSTR(LI)=LENBLK
      LENBLK=0
      BADBLK=.TRUE.
      END IF
C
      LENBLK=LENBLK+APOINT(I)-IPOINT
      JUNK=JUNK+APOINT(I)-IPOINT
      IF (AMOUNT(I).GT.0.AND.BADBLK) THEN
C
C     GOOD STUFF HAS BEEN FOUND, AND THE CURRENT BLOCK IS JUNK.
C     HENCE, TERMINATE THE JUNK BLOCK, AND START A GOOD BLOCK.
C
      LI=LI+1
      IF (LI.GT.MAXI) GO TO 1000
      INSTR(LI)=LENBLK
      LENBLK=0
      BADBLK=.FALSE.
      END IF
C
      LENBLK=LENBLK+AMOUNT(I)
      IPOINT=APOINT(I)+AMOUNT(I)
 10   APOINT(I)=APOINT(I)-JUNK
C
C     RECORD THE LENGTH OF THE FINAL BLOCK, GOOD OR JUNK.  ALSO RECORD
C     THE APACK SIGNAL AND THE NUMBER OF BLOCKS, AND ADJUST THE START
C     POSITION LA IN ARRAY.
C
      LI=LI+1
      IF (LI.GT.MAXI) GO TO 1000
      INSTR(LI)=LENBLK
      INSTR(LISAVE-1)=-3
      INSTR(LISAVE)=LI-LISAVE
      LA=APOINT(LP)+AMOUNT(LP)
      RETURN
 1000 CALL PSTOP(IPED,UNIT3,'I',PEDID,'RINSTR')
      END

      SUBROUTINE JOIN(SETA,SETB,SETC,LC,NA,NB,NC)
C
C     THIS SUBROUTINE FINDS THE UNION OF TWO NONEMPTY ORDERED SETS
C     OF INTEGERS A AND B AND STORES IT IN C. NOTICE HOW THE
C     ALGORITHM EMPLOYED SEESAWS BACK AND FORTH BETWEEN A AND B
C     WHILE KEEPING TRACK OF THEIR CURRENT LOWEST ORDER ELEMENTS.
C
      INTEGER SETA(NA),SETB(NB),SETC(NC)
C
      I=1
      J=1
      LC=0
 30   K=SETA(I)-SETB(J)
      LC=LC+1
      IF (K.EQ.0) THEN
      SETC(LC)=SETA(I)
      I=I+1
      J=J+1
      ELSE IF (K.LT.0) THEN
      SETC(LC)=SETA(I)
      I=I+1
      ELSE
      SETC(LC)=SETB(J)
      J=J+1
      END IF
C
C     IF SET A HAS BEEN EXHAUSTED, THEN FINISH OFF SET B, AND
C     VICE VERSA.
C
      IF (I.GT.NA) THEN
      DO 10 K=J,NB
      LC=LC+1
 10   SETC(LC)=SETB(K)
      RETURN
      ELSE IF (J.GT.NB) THEN
      DO 20 K=I,NA
      LC=LC+1
 20   SETC(LC)=SETA(K)
      RETURN
      ELSE
      GO TO 30
      END IF
      END

      SUBROUTINE SEARCH(ALLFRQ,ARRAY,CNSTR,CVALUE,DELTA,DF,DFOLD
     1,EXTRA,GRID,HESS,PAR,PARMAX,PARMIN,PAROLD,PARS,TABLE,VAR,WORK1
     2,WORK2,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,NSWEEP,PERSON
     3,PNAME,XLINK,MAXA,MAXALL,MAXGL,MAXI,MAXIW,MAXLST,MAXPAR,MAXPEO
     4,MAXTAB,MAXV,MAXVAR,MCNSTR,MUTATE,MXITER,MXSTEP,MXWORK,NCNSTR
     5,NCONV,NEXTRA,NLOCI,NPAR,NPED,NPOINT,NVAR,PROBLM,UNIT2,UNIT3
     6,BASE,TRAVEL,ASYCV,PMODE,STAND)
C
C                    COPYRIGHT 1984 BY KENNETH LANGE.
C     DO NOT DISTRIBUTE EXCEPT BY THE EXPRESS PERMISSION OF THE AUTHOR.
C
C     THIS SUBROUTINE COMPUTES THE CONSTRAINED MINIMUM OF A FUNCTION F
C     BY THE VARIABLE METRIC METHOD OF BIGGS, HAN, AND POWELL.  SEE:
C     M.J.D. POWELL(1978) "A FAST ALGORITHM FOR NONLINEARLY CONSTRAINED
C     OPTIMIZATION CALCULATIONS."  PROCEEDINGS OF THE 1977 DUNDEE
C     CONFERENCE ON NUMERICAL ANALYSIS. G.A. WATSON EDITOR. SPRINGER-VERLAG.
C     IN THE LIST BELOW ITEMS MARKED BY * OR ** MUST BE PROVIDED BY THE USER.
C     ITEMS MARKED BY ** SHOULD BE INITIALIZED IN THE SUBROUTINE INITAL.
C
C     CNSTR**          MATRIX OF LINEAR EQUALITY CONSTRAINTS
C     CVALUE**         CONSTANTS FOR PARAMETER/CONSTRAINT INNER PRODUCTS
C     DELTA            UPDATE DIRECTION FOR PARAMETERS
C     DF               CURRENT DIFFERENTIAL OF THE FUNCTION F
C     DFOLD            PREVIOUS DIFFERENTIAL OF THE FUNCTION F
C     GRID**           GRID OF POINTS TO EVALUATE F ON
C     HESS             CURRENT APPROXIMATE HESSIAN OF F
C     PAR**            CURRENT PARAMETERS
C     PARMAX,PARMIN**  PARAMETER MAXIMA AND MINIMA
C     PAROLD           PREVIOUS PARAMETERS
C     TABLE            TABLEAU FOR QUADRATIC PROGRAMMING PROBLEM
C     WORK1,WORK2      WORK VECTORS
C     NSWEEP           INDICATOR FOR WHICH PARAMETERS HAVE BEEN SWEPT
C                      IN TABLE
C     PNAME**          PARAMETER NAMES
C     CONV*            CONVERGENCE CRITERION FOR CHANGE IN F
C     DP*              NUMERICAL DIFFERENTIATION INTERVAL
C     SMALL*           SMALL POSITIVE NUMBER FOR CHECKING BOUNDS
C     TOL*             TOLERANCE FOR MATRIX SWEEPING
C     UNIT3*           OUTPUT UNIT NUMBER
C     MAXPAR*          MAXIMUM(NPAR,1)
C     MAXTAB*          NCNSTR+NPAR+1
C     MCNSTR*          MAXIMUM(NCNSTR,1)
C     MXITER*          MAXIMUM NUMBER OF ITERATIONS
C     MXSTEP*          MAXIMUM NUMBER OF STEPS PER ITERATION
C     NCONV*           NUMBER OF TIMES CONVERGENCE CRITERION MUST BE MET
C     NCNSTR*          NUMBER OF LINEAR EQUALITY CONSTRAINTS
C     NPAR*            NUMBER OF PARAMETERS
C     NPOINT*          NUMBER OF POINTS FOR 'GRID' OPTION
C     TRAVEL*          'SEARCH' OR 'GRID' OPTION
C     ASYCV*           TRUE WHEN ASYMPTOTIC COVARIANCE MATRIX DESIRED
C     EXACT*           TRUE WHEN EXACT DIFFERENTIAL AVAILABLE
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER PARSIZ
      DOUBLE PRECISION ALLFRQ(NLOCI,MAXALL),ARRAY(MAXA)
     1,CNSTR(MCNSTR,MAXPAR),CVALUE(MCNSTR),DELTA(MAXPAR),DF(MAXPAR)
     2,DFOLD(MAXPAR),EXTRA(NEXTRA),GRID(NPOINT,MAXPAR)
     3,HESS(MAXPAR,MAXPAR),PAR(MAXPAR),PARMAX(MAXPAR),PARMIN(MAXPAR)
     4,PAROLD(MAXPAR),PARS(MAXPAR,PARSIZ)
     5,TABLE(MAXTAB,MAXTAB),VAR(MAXV),WORK1(MXWORK),WORK2(MXWORK)
     6,LOGLIK
      INTEGER GLIST(MAXGL),GPOINT(NLOCI,MAXPEO),GROUP(MAXPEO)
     1,INSTR(MAXI),IWORK(MAXIW),NGEN(NLOCI,MAXPEO),NJOINT(MAXPEO)
     2,NSWEEP(MAXPAR),PERSON(MAXPEO),COND,PROBLM,SEED,UNIT2,UNIT3
      CHARACTER*8 PNAME(MAXPAR),BASE,TRAVEL
      LOGICAL XLINK(NLOCI),ASYCV,EXACT,FORWRD,LUMPED,PMODE,STAND
     1,UMOVE
      COMMON /SECRET/ PARSIZ,LUMPED
C
C     INITIALIZE SOME CONSTANTS USED IN SUBROUTINE SEARCH.
C
      SAVE SMALL,TOL,SEED,EXACT
      DATA SMALL,TOL,SEED,EXACT/1.0D-12,1.0D-8,25431,.FALSE./
C
C     RETRIEVE FROM ARRAY THE CONSTANTS ABSENT, CONV, DP, XXRATE,
C     XYRATE, COND, AND MUTATE.  THIS IS NECESSARY BECAUSE THE IBM PC
C     COMPILER CHOKES WHEN A SUBROUTINE HAS MORE THAN 64 ARGUMENTS.
C
      ABSENT=ARRAY(1)
      CONV=ARRAY(2)
      DP=ARRAY(3)
      XXRATE=ARRAY(4)
      XYRATE=ARRAY(5)
      COND=INT(ARRAY(6))
C
C     INITIALIZE THE PARAMETER VALUES, THEIR BOUNDS, THEIR CONSTRAINTS,
C     AND THEIR NAMES.
C
      UMOVE=.FALSE.
      IF (NPAR.GT.0) THEN
      DO 10 I=1,NPAR
      PAR(I)=1.0D-6
      PARMAX(I)=1.0D20
      PARMIN(I)=-1.0D20
      WRITE(PNAME(I),'(I6)') I
      PNAME(I)(2:4)='PAR'
      DO 20 J=1,NPAR
 20   HESS(I,J)=0.0D0
 10   HESS(I,I)=1.0D0
      DO 30 I=1,NCNSTR
      CVALUE(I)=0.0D0
      DO 30 J=1,NPAR
 30   CNSTR(I,J)=0.0D0
      CALL INITAL(ALLFRQ,CNSTR,CVALUE,EXTRA,GRID,PAR,PARMAX,PARMIN
     1,PNAME,XLINK,XXRATE,XYRATE,MAXALL,MUTATE,MCNSTR,NEXTRA,NLOCI
     2,MAXPAR,NPOINT,NVAR,PROBLM,UNIT3,TRAVEL)
      END IF
C
C     COMPUTE FUNCTION VALUES OVER A USER DEFINED GRID OF POINTS.
C     TO SAVE SPACE THE NEGATIVE LOGLIKELIHOOD FOR THE ITH GRID POINT
C     IS RETURNED IN GRID(ITER,1).  GRID ITSELF IS SAVED IN PARS.
C
      IF (TRAVEL.EQ.'GRID') THEN
      CALL FUN(ALLFRQ,ARRAY,DF,EXTRA,GRID,HESS,PAR,PARMAX,PARS,VAR
     1,WORK1,WORK2,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,PERSON
     2,XLINK,ABSENT,DP,F,XXRATE,XYRATE,COND,ITER,MAXA,MAXALL,MAXGL
     3,MAXI,MAXIW,MAXLST,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE,MXWORK,0
     4,NEXTRA,NLOCI,NPAR,NPED,NPEO,NPOINT,NPTOT,NVAR,UNIT2,UNIT3
     5,TRAVEL,FORWRD,PMODE,UMOVE)
      DO 40 ITER=1,NPOINT
      CALL SCOR(DF,WORK1,GRID(ITER,1),LOGLIK,MAXPAR,NPAR,TRAVEL)
 40   CALL OUTPUT(EXTRA,PARS(1,ITER),WORK1,PNAME,LOGLIK,NPOINT,ITER
     1,MAXPAR,NEXTRA,NPAR,0,UNIT3,BASE,TRAVEL,STAND,UMOVE)
      ELSE
C
C     OTHERWISE SEARCH THE FUNCTION SURFACE.  FIRST CALL PREOPT
C     TO CHECK THAT THE PARAMETERS SATISFY THEIR BOUNDS AND THEIR
C     LINEAR EQUALITY CONSTRAINTS.  PREOPT ALSO CHECKS THAT THE
C     CONSTRAINTS ARE NOT REDUNDANT.  IF ANY OF THESE CHECKS FAIL,
C     THEN STOP.
C
      CALL PREOPT(CNSTR,CVALUE,PAR,PARMAX,PARMIN,TABLE,WORK2
     1,PNAME,CNORM,TOL,IERROR,MAXPAR,MAXTAB,MCNSTR,NCNSTR,NPAR
     2,UNIT3,TRAVEL)
      IF (IERROR.GE.1) CALL EXIT( 17 )

C
C     INITIALIZE SOME VARIABLES.
C
      ITER=1
      LAST=MXITER
      NCRIT=0
      FORWRD=.TRUE.
C
C     COMPUTE THE INITIAL FUNCTION VALUE AND DIFFERENTIAL, AND OUTPUT
C     THE FIRST ITERATION.
C
      CALL FUN(ALLFRQ,ARRAY,DF,EXTRA,GRID,HESS,PAR,PARMAX,PARS,VAR
     1,WORK1,WORK2,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,PERSON
     2,XLINK,ABSENT,DP,F,XXRATE,XYRATE,COND,ITER,MAXA,MAXALL,MAXGL
     3,MAXI,MAXIW,MAXLST,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE,MXWORK,NPAR
     4,NEXTRA,NLOCI,NPAR,NPED,NPEO,NPOINT,NPTOT,NVAR,UNIT2,UNIT3,TRAVEL
     5,FORWRD,PMODE,UMOVE)

      CALL SCOR(DF,WORK1,F,LOGLIK,MAXPAR,NPAR,TRAVEL)
      CALL OUTPUT(EXTRA,PAR,WORK1,PNAME,LOGLIK,LAST,1,MAXPAR
     1,NEXTRA,NPAR,0,UNIT3,BASE,TRAVEL,STAND,UMOVE)
C
C     ENTER THE MAIN ITERATION LOOP.
C
      IF (MXITER.GT.1) THEN
      DO 60 ITER=2,MXITER
C
C     CREATE THE TABLEAU FOR THE QUADRATIC PROGRAMMING PROBLEM.
C
 90   CALL SETTAB(CNSTR,CVALUE,DF,HESS,PAR,TABLE,WORK2,CNORM
     1,MAXPAR,MAXTAB,MCNSTR,NCNSTR,NPAR,NTAB)
C
C     SOLVE THE QUADRATIC PROGRAMMING PROBLEM FOR THE NEXT
C     STEP DIRECTION DELTA.
C
      CALL QDPROG(DELTA,PAR,PARMAX,PARMIN,TABLE,WORK1,WORK2,NSWEEP
     1,SMALL,TOL,MAXPAR,MAXTAB,NCNSTR,NCYCLE,NPAR,NTAB)
C
C     IF NCYCLE IS NEGATIVE, THE QUADRATIC PROGRAMMING PROBLEM IS
C     SOLVED.  IF NCYCLE IS ZERO, IT IS IMPOSSIBLE TO ADEQUATELY
C     SWEEP THE TABLEAU.  IF NCYCLE IS POSITIVE, THERE IS A
C     POSSIBLE INFINITE LOOP IN THE QUADRATIC PROGRAMMING ALGORITHM.
C     IN EITHER 0F THE LAST TWO CASES, RESET THE HESSIAN AND TRY AGAIN.
C
      IF (NCYCLE.GE.0) THEN
      HMIN=1.0D20
      DO 70 J=1,NPAR
 70   IF (HESS(J,J).GT.0.0D0) HMIN=MIN(HMIN,HESS(J,J))
      DO 80 J=1,NPAR
 80   HESS(J,J)=MAX(HESS(J,J),HMIN)*(1.0D0+RANDOM(SEED))
      IF (.NOT.UMOVE) GO TO 90
      END IF
C
C     COMPUTE THE INNER PRODUCT D OF DELTA AND THE DIFFERENTIAL DF.
C     IF D IS POSITIVE, THEN DELTA IS NOT A DESCENT DIRECTION.
C     CONVERGENCE HAS OCCURRED, OR THE SEARCH IS IN DEEP TROUBLE.
C
      D=0.0D0
      DO 100 J=1,NPAR
 100  D=D+DF(J)*DELTA(J)
C
C     WHEN THE DIFFERENTIAL IS COMPUTED NUMERICALLY, CHANGE FROM
C     FORWARD DIFFERENCES TO CENTRAL DIFFERENCES AND VICE VERSA
C     BASED ON THE QUANTITY D.  REDO THE QUADRATIC PROGRAMMING
C     PROBLEM IF NECESSARY.
C
      IF (.NOT.EXACT) THEN
      IF (FORWRD.AND.D.GE.0.0D0) THEN
      FORWRD=.FALSE.
      CALL FUN(ALLFRQ,ARRAY,DF,EXTRA,GRID,HESS,PAR,PARMAX,PARS,VAR
     1,WORK1,WORK2,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,PERSON
     2,XLINK,ABSENT,DP,F,XXRATE,XYRATE,COND,ITER,MAXA,MAXALL,MAXGL
     3,MAXI,MAXIW,MAXLST,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE,MXWORK,NPAR
     4,NEXTRA,NLOCI,NPAR,NPED,NPEO,NPOINT,NPTOT,NVAR,UNIT2,UNIT3
     5,TRAVEL,FORWRD,PMODE,UMOVE)
      GO TO 90
      END IF
      FORWRD=D.LE.-CONV.AND.NCRIT.EQ.0
      END IF
C
C     ENTER THE STEP DECREMENTING LOOP.  T IS THE FRACTION OF DELTA
C     TAKEN.
C
      T=1.0D0
      IF (UMOVE) T=0.0D0
      NSTEP=0
      D=MIN(D,0.0D0)
C
C     RECORD THE OLD DATA IN PREPARATION FOR THE NEXT STEP.
C
      FOLD=F
      DO 110 J=1,NPAR
      PAROLD(J)=PAR(J)
 110  DFOLD(J)=DF(J)
C
C     COMPUTE A NEW POINT AND A NEW FUNCTION VALUE.
C
 130  DO 120 J=1,NPAR
 120  PAR(J)=PAROLD(J)+T*DELTA(J)
      CALL FUN(ALLFRQ,ARRAY,DF,EXTRA,GRID,HESS,PAR,PARMAX,PARS,VAR
     1,WORK1,WORK2,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,PERSON
     2,XLINK,ABSENT,DP,F,XXRATE,XYRATE,COND,ITER,MAXA,MAXALL,MAXGL
     3,MAXI,MAXIW,MAXLST,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE,MXWORK,NPAR
     4,NEXTRA,NLOCI,NPAR,NPED,NPEO,NPOINT,NPTOT,NVAR,UNIT2,UNIT3
     5,TRAVEL,FORWRD,PMODE,UMOVE)
C
C     IF THERE IS NOT A SUFFICIENT DECREASE IN F, THEN TRY TO
C     FIND A BETTER POINT ALONG THE DIRECTION DELTA.  COMPUTE
C     THE MINIMUM POINT FOR THE QUADRATIC IN T WHICH PASSES
C     THROUGH FOLD AND F AND HAS SLOPE D AT T=0.  IF THIS
C     MINIMUM IS TOO CLOSE TO 0, DECREMENT T BY ONLY 90 PER CENT.
C
      IF (.NOT.UMOVE.AND.F.GT.FOLD+0.1D0*T*D.AND.NSTEP.LT.MXSTEP) THEN
      T1=-0.5D0*D*T*T/(F-FOLD-T*D)
      T2=0.1D0*T
      T=MAX(T1,T2)
      NSTEP=NSTEP+1
      GO TO 130
      END IF
C
C     QUIT WHEN THERE IS A SUFFICIENT DECREASE IN F OR TOO
C     MANY STEPS.  CHECK THE CONVERGENCE CRITERION.  IF IT HAS
C     BEEN SATISFIED NCONV TIMES, THEN EXIT THE MAIN LOOP.
C     OTHERWISE, OUTPUT THE CURRENT ITERATION.
C
      IF (ABS(FOLD-F).GT.CONV) NCRIT=-1
      NCRIT=NCRIT+1
      IF (NCRIT.GE.NCONV) GO TO 140
      CALL SCOR(DF,WORK1,F,LOGLIK,MAXPAR,NPAR,TRAVEL)
      CALL OUTPUT(EXTRA,PAR,WORK1,PNAME,LOGLIK,LAST,ITER,MAXPAR
     1,NEXTRA,NPAR,NSTEP,UNIT3,BASE,TRAVEL,STAND,UMOVE)
C
C     RESET DELTA SO THAT IT IS THE ACTUAL STEP TAKEN.
C
      DO 150 J=1,NPAR
 150  DELTA(J)=PAR(J)-PAROLD(J)
C
C     PREPARE TO UPDATE THE HESSIAN.  STORE IN WORK1 THE
C     PRODUCT HESS*DELTA.  WORK1 APPROXIMATES THE DIFFERENCE
C     IN DIFFERENTIALS DF-DFOLD.  STORE IN C1 AND C2 THE
C     INNER PRODUCT OF THESE TWO VECTORS WITH DELTA.
C
      C1=0.0D0
      DO 160 J=1,NPAR
      S=0.0D0
      DO 170 K=1,NPAR
 170  S=S+HESS(J,K)*DELTA(K)
      WORK1(J)=S
 160  C1=C1+DELTA(J)*S
      C2=0.0D0
      DO 180 J=1,NPAR
 180  C2=C2+(DF(J)-DFOLD(J))*DELTA(J)
C
C     IF C2 IS TOO SMALL, BIAS DF-DFOLD BY TAKING A CONVEX
C     COMBINATION WITH WORK1.  STORE THE RESUTING VECTOR
C     IN WORK2.  ITS INNER PRODUCT WITH DELTA WILL BE C4.
C
      IF (C1.GT.0.0D0) THEN
      IF (C2.GT.0.2D0*C1) THEN
      C3=1.0D0
      ELSE
      C3=0.8D0*C1/(C1-C2)
      END IF
      DO 190 J=1,NPAR
 190  WORK2(J)=C3*(DF(J)-DFOLD(J))+(1.0D0-C3)*WORK1(J)
      C4=C3*C2+(1.0D0-C3)*C1
C
C     NOW RESET THE HESSIAN USING THE RANK TWO BFGS UPDATE.
C
      DO 200 J=1,NPAR
      DO 200 K=1,NPAR
 200  HESS(J,K)=HESS(J,K)-WORK1(J)*WORK1(K)/C1+WORK2(J)*WORK2(K)/C4
      END IF
 60   CONTINUE
      RETURN
      END IF
C
C     CONVERGENCE HAS OCCURRED.  OUTPUT THE LAST ITERATION
C
 140  IF (ITER.NE.MXITER) THEN
      CALL SCOR(DF,WORK1,F,LOGLIK,MAXPAR,NPAR,TRAVEL)
      CALL OUTPUT(EXTRA,PAR,WORK1,PNAME,LOGLIK,ITER,ITER,MAXPAR
     1,NEXTRA,NPAR,NSTEP,UNIT3,BASE,TRAVEL,STAND,UMOVE)
      END IF
C
C     IF THE ASYMPTOTIC COVARIANCE MATRIX IS DESIRED, THEN RECOMPUTE
C     THE HESSIAN AND CALL ASYCOV.  USE CENTRAL DIFFERENCES FOR THE
C     FIRST PARTIALS AND FORWARD DIFFERENCES FOR THE SECOND PARTIALS.
C     ADJUST THE DIFFERENTIATION INTERVAL FOR THE SECOND PARTIALS.
C
      IF (ASYCV) THEN
      IF (.NOT.EXACT) THEN
      DP23=DP**0.66667D0
      IF (FORWRD) THEN
      FORWRD=.FALSE.
      CALL FUN(ALLFRQ,ARRAY,DF,EXTRA,GRID,HESS,PAR,PARMAX,PARS,VAR
     1,WORK1,WORK2,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,PERSON
     2,XLINK,ABSENT,DP,F,XXRATE,XYRATE,COND,ITER,MAXA,MAXALL,MAXGL
     3,MAXI,MAXIW,MAXLST,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE,MXWORK,NPAR
     4,NEXTRA,NLOCI,NPAR,NPED,NPEO,NPOINT,NPTOT,NVAR,UNIT2,UNIT3
     5,TRAVEL,FORWRD,PMODE,UMOVE)
      END IF
      ELSE
      DP23=DP
      END IF
C
C     COMPUTE THE SECOND PARTIALS AND CALL ASYCOV.
C
      DO 210 J=1,NPAR
      IF (PAR(J).LE.PARMIN(J)+SMALL.OR.PAR(J).GE.PARMAX(J)-SMALL) THEN
      NSWEEP(J)=0
      ELSE
      NSWEEP(J)=1
      DPJ=DP23*MAX(ABS(PAR(J)),1.0D0)
      PAR(J)=PAR(J)+DPJ
      CALL FUN(ALLFRQ,ARRAY,DFOLD,EXTRA,GRID,HESS,PAR,PARMAX,PARS,VAR
     1,WORK1,WORK2,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,PERSON
     2,XLINK,ABSENT,DP,F,XXRATE,XYRATE,COND,ITER,MAXA,MAXALL,MAXGL,MAXI
     3,MAXIW,MAXLST,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE,MXWORK,J,NEXTRA
     4,NLOCI,NPAR,NPED,NPEO,NPOINT,NPTOT,NVAR,UNIT2,UNIT3,TRAVEL,FORWRD
     5,PMODE,UMOVE)
      PAR(J)=PAR(J)-DPJ
      END IF
      DO 220 I=1,J
      IF (NSWEEP(I).EQ.0.OR.NSWEEP(J).EQ.0) THEN
      HESS(I,J)=0.0D0
      ELSE
      HESS(I,J)=(DFOLD(I)-DF(I))/DPJ
      END IF
 220  HESS(J,I)=HESS(I,J)
 210  CONTINUE
      CALL ASYCOV(CNSTR,CVALUE,DF,HESS,PAR,TABLE,WORK1,WORK2
     1,NSWEEP,PNAME,CNORM,SMALL,TOL,MAXPAR,MAXTAB,MCNSTR,NCNSTR
     2,NPAR,UNIT3)
      END IF
      END IF
      END

      FUNCTION RANDOM(SEED1)
C
C     THIS FUNCTION GENERATES INDEPENDENT UNIFORM DEVIATES ON
C     THE INTERVAL (0.0,1.0).  SEE THE REFERENCE:  WICHMAN B.A.
C     AND HILL I.D.(1982). ALGORITHM 183: AN EFFICIENT AND PORTABLE
C     PSEUDO-RANDOM NUMBER GENERATOR. APPLIED STATISTICS 31;188-190.
C     SEED1, SEED2, AND SEED3 SHOULD BE SET TO INTEGER VALUES
C     BETWEEN 1 AND 30000 BEFORE THE FIRST ENTRY.  INTEGER
C     ARITHMETIC UP TO 30323 IS NEEDED ON THE YOUR COMPUTER.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER SEED1,SEED2,SEED3
      SAVE SEED2,SEED3
      DATA SEED2,SEED3/2321,18777/
C
      SEED1=171*MOD(SEED1,177)-2*(SEED1/177)
      SEED2=172*MOD(SEED2,176)-35*(SEED2/176)
      SEED3=170*MOD(SEED3,178)-63*(SEED3/178)
      IF (SEED1.LT.0) SEED1=SEED1+30269
      IF (SEED2.LT.0) SEED2=SEED2+30307
      IF (SEED3.LT.0) SEED3=SEED3+30323
      R=DBLE(SEED1)/30269.D0+DBLE(SEED2)/30307.D0+DBLE(SEED3)/30323.D0
      RANDOM=MOD(R,1.0D0)
      END

      SUBROUTINE SCOR(DF,SCORE,F,LOGLIK,MAXPAR,NPAR,TRAVEL)
C
C     THIS SUBROUTINE IS NECESSARY BECAUSE THE OPTIMIZATION CODE
C     MINIMIZES MINUS THE LOGLIKELIHOOD.  FOR OUTPUT PURPOSES, THE
C     FUNCTION VALUE AND DIFFERENTIAL MUST BE CHANGED IN SIGN.
C
      DOUBLE PRECISION DF(MAXPAR),SCORE(MAXPAR),F,LOGLIK
      CHARACTER*8 TRAVEL
C
      LOGLIK=-F
C
C     IF THE GRID OPTION IS SELECTED, THEN SET THE SCORE VECTOR TO
C     ZERO.
C
      IF (TRAVEL.EQ.'GRID') THEN
      DO 10 I=1,NPAR
 10   SCORE(I)=0.0D0
C
      ELSE
      DO 20 I=1,NPAR
 20   SCORE(I)=-DF(I)
      END IF
      END

      SUBROUTINE PREOPT(CNSTR,CVALUE,PAR,PARMAX,PARMIN,TABLE,WORK2
     1,PNAME,CNORM,TOL,IERROR,MAXPAR,MAXTAB,MCNSTR,NCNSTR,NPAR
     2,UNIT3,TRAVEL)
C
C     THIS SUBROUTINE CHECKS THAT THE PARAMETERS ARE INITIALLY
C     WITHIN THEIR BOUNDS, THAT THE LINEAR EQUALITY CONSTRAINTS ARE
C     SATISFIED, AND THAT THE CONSTRAINTS ARE LINEARLY INDEPENDENT.
C     IT ALSO COMPUTES A MATRIX NORM FOR CNSTR(TRANSPOSE)*CNSTR.
C     THIS WILL BE USED AS A SCALE FACTOR IN THE SUBROUTINE SETTAB.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION CNSTR(MCNSTR,MAXPAR),CVALUE(MCNSTR),PAR(MAXPAR)
     1,PARMAX(MAXPAR),PARMIN(MAXPAR),TABLE(MAXTAB,MAXTAB),WORK2(MAXTAB)
      INTEGER UNIT3
      CHARACTER*8 PNAME(MAXPAR),TRAVEL
C
      IERROR=0
C
C     CHECK THE PARAMETER BOUNDS.
C
      DO 10 I=1,NPAR
      IF (PAR(I).LT.PARMIN(I)) THEN
      IERROR=IERROR+1
      WRITE(UNIT3,20) I
 20   FORMAT(' *** ERROR *** PARAMETER',I3,' IS LESS THAN ITS MINIMUM.')
      ELSE IF (PAR(I).GT.PARMAX(I)) THEN
      IERROR=IERROR+1
      WRITE(UNIT3,30) I
 30   FORMAT(' *** ERROR *** PARAMETER',I3,' EXCEEDS ITS MAXIMUM.')
      END IF
      IF (PARMIN(I).GE.PARMAX(I)-1.0D-4) THEN
      IERROR=IERROR+1
      WRITE(UNIT3,35) I
 35   FORMAT(' *** ERROR *** THE BOUNDS ON PARAMETER',I3
     :,' ARE TOO CLOSE OR INCONSISTENT.')
      END IF
 10   CONTINUE
C
C     CHECK THAT NO PARAMETER IS CONSTRAINED TO A BOUND AND THAT
C     THE EQUALITY CONSTRAINTS ARE SATISFIED
C
      DO 40 I=1,NCNSTR
      S=0.0D0
      N=0
      DO 50 J=1,NPAR
      IF (CNSTR(I,J).NE.0.0D0) THEN
      N=N+1
      K=J
      END IF
 50   S=S+CNSTR(I,J)*PAR(J)
      IF (N.EQ.1) THEN
      CRIT=MIN(ABS(PAR(K)-PARMIN(K)),ABS(PAR(K)-PARMAX(K)))
      IF (CRIT.LT.1.0D-4) THEN
      IERROR=IERROR+1
      WRITE(UNIT3,55) K
 55   FORMAT(' *** ERROR *** PARAMETER',I3
     :,' MAY BE CONSTRAINED TO ONE OF ITS BOUNDS.'
     :,' IF SO REMOVE THE OFFENDING BOUND.')
      END IF
      END IF
      IF (ABS(S-CVALUE(I)).GT.1.0D-4) THEN
      IERROR=IERROR+1
      WRITE(UNIT3,60) I
 60   FORMAT(' *** ERROR *** LINEAR EQUALITY CONSTRAINT',I3
     1,' IS NOT SATISFIED.')
      END IF
 40   CONTINUE
C
C     CHECK THAT THE EQUALITY CONSTRAINTS ARE LINEARLY INDEPENDENT
C     BY SWEEPING ON CNSTR*CNSTR(TRANSPOSE).
C
      DO 70 J=1,NCNSTR
      DO 70 I=1,J
      S=0.0D0
      DO 80 K=1,NPAR
 80   S=S+CNSTR(I,K)*CNSTR(J,K)
 70   TABLE(I,J)=S
      NTAB=NCNSTR
      DO 90 I=1,NCNSTR
      IF (TABLE(I,I).LT.TOL) THEN
      IERROR=IERROR+1
      WRITE(UNIT3,100) I
 100  FORMAT(' *** ERROR *** LINEAR EQUALITY CONSTRAINT',I3
     1,' IS UNDEFINED OR A COMBINATION OF PREVIOUS ONES.')
      ELSE
      CALL SWEEP(TABLE,WORK2,I,MAXTAB,NTAB,.FALSE.)
      END IF
 90   CONTINUE
C
C     COMPUTE A MATRIX NORM FOR CNSTR(TRANSPOSE)*CNSTR.
C
      CNORM=0.0D0
      DO 110 I=1,NPAR
      DO 110 J=1,NPAR
      S=0.0D0
      DO 120 K=1,NCNSTR
 120  S=S+CNSTR(K,I)*CNSTR(K,J)
 110  CNORM=CNORM+S*S
      CNORM=SQRT(CNORM)
C
C     WRITE OUT THE PARAMETER BOUNDS AND THE CONSTRAINTS.
C
      IF (TRAVEL.EQ.'SEARCH'.AND.NPAR.GT.0) THEN
      WRITE(UNIT3,130)
 130  FORMAT(/,' PARAMETER MINIMA AND MAXIMA:')
      WRITE(UNIT3,140) (PNAME(I),I=1,NPAR)
 140  FORMAT(100(/6(4X,A8),:))
      WRITE(UNIT3,150) (PARMIN(I),I=1,NPAR)
      WRITE(UNIT3,150) (PARMAX(I),I=1,NPAR)
 150  FORMAT(/100(6(1X,D11.4),:,/))
      IF (NCNSTR.GT.0) THEN
      WRITE(UNIT3,160)
 160  FORMAT(/,' PARAMETER CONSTRAINTS:')
      WRITE(UNIT3,170) (PNAME(I),I=1,NPAR)
 170  FORMAT(/'    CVALUE  ',5(4X,A8),:,100(/6(4X,A8),:))
      DO 180 I=1,NCNSTR
 180  WRITE(UNIT3,150) CVALUE(I),(CNSTR(I,J),J=1,NPAR)
      END IF
      END IF
      END

      SUBROUTINE SETTAB(CNSTR,CVALUE,DF,HESS,PAR,TABLE,WORK2,CNORM
     1,MAXPAR,MAXTAB,MCNSTR,NCNSTR,NPAR,NTAB)
C
C     THIS SUBROUTINE CREATES AN UPPER TRIANGULAR TABLEAU IN
C     PREPARATION FOR THE QUADRATIC PROGRAMMING PROBLEM.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION CNSTR(MCNSTR,MAXPAR),CVALUE(MCNSTR),DF(MAXPAR)
     1,HESS(MAXPAR,MAXPAR),PAR(MAXPAR),TABLE(MAXTAB,MAXTAB)
     2,WORK2(MAXTAB)
C
C     FIRST COMPUTE THE NORM OF THE HESSIAN FOR PURPOSES OF SCALING
C     THE CONSTRAINT CONTRIBUTION TO THE UPPER LEFT BLOCK OF THE
C     TABLEAU.
C
      IF (NCNSTR.EQ.0) THEN
      C=1.0D0
      ELSE
      HNORM=0.0D0
      DO 10 I=1,NPAR
      DO 10 J=1,NPAR
 10   HNORM=HNORM+HESS(I,J)**2
      HNORM=SQRT(HNORM)
      C=HNORM/CNORM
C
C     NEXT COMPUTE THE LINEAR EQUALITY CONSTANTS FOR
C     THE INCREMENTS OF THE CURRENT PARAMETER VALUES.
C
      DO 20 I=1,NCNSTR
      S=CVALUE(I)
      DO 30 J=1,NPAR
 30   S=S-CNSTR(I,J)*PAR(J)
 20   WORK2(I)=S
      END IF
C
C     NOW SET UP THE TABLEAU.  IN THE UPPER LEFT BLOCK LOAD THE
C     APPROXIMATE HESSIAN.  IF THERE ARE CONSTRAINTS, AUGMENT
C     THE HESSIAN BY A CONSTANT TIMES CNSTR(TRANSPOSE)*CNSTR.
C     TO THE RIGHT OF THE HESSIAN LOAD CNSTR(TRANSPOSE).  TO THE
C     RIGHT OF THIS LOAD THE NEGATIVE OF THE DIFFERENTIAL. BELOW
C     THE DIFFERENTIAL LOAD THE LINEAR EQUALITY CONSTANTS. THE
C     REST OF THE TABLEAU SHOULD BE ZERO.
C
      NTAB=NPAR+NCNSTR+1
      N1=NPAR+1
      DO 40 K=1,NPAR
      DO 40 J=1,K
      S=0.0D0
      DO 50 I=1,NCNSTR
 50   S=S+CNSTR(I,J)*CNSTR(I,K)
 40   TABLE(J,K)=HESS(J,K)+C*S
      DO 60 I=1,NCNSTR
      K=NPAR+I
      DO 70 J=1,NPAR
 70   TABLE(J,K)=CNSTR(I,J)
      DO 80 J=N1,K
 80   TABLE(J,K)=0.0D0
 60   CONTINUE
      DO 90 J=1,NPAR
 90   TABLE(J,NTAB)=-DF(J)
      DO 100 J=1,NCNSTR
 100  TABLE(J+NPAR,NTAB)=WORK2(J)
      TABLE(NTAB,NTAB)=0.0D0
      END

      SUBROUTINE QDPROG(DELTA,PAR,PARMAX,PARMIN,TABLE,WORK1,WORK2
     1,NSWEEP,SMALL,TOL,MAXPAR,MAXTAB,NCNSTR,NCYCLE,NPAR,NTAB)
C
C     THIS SUBROUTINE SOLVES THE QUADRATIC PROGRAMMING PROBLEM
C         MIN  DF*DELTA+.5*DELTA(TRANSPOSE)*HESS*DELTA
C           SUBJECT TO CNSTR*DELTA=0
C           PARMIN.LE.PAR+DELTA.LE.PARMAX.
C     SEE: R.I.JENNRICH AND P.F.SAMPSON(1978)  "SOME PROBLEMS
C     FACED IN MAKING A VARIANCE COMPONENT ALGORITHM INTO A
C     GENERAL MIXED MODEL PROGRAM"  PROCEEDINGS OF THE ELEVENTH
C     ANNUAL SYMPOSIUM ON THE INTERFACE. A.R.GALLANT AND T.M.GERIG
C     EDITORS. INSTITUTE OF STATISTICS,NORTH CAROLINA STATE
C     UNIVERSITY.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION DELTA(MAXPAR),PAR(MAXPAR),PARMAX(MAXPAR)
     1,PARMIN(MAXPAR),TABLE(MAXTAB,MAXTAB),WORK1(MAXPAR)
     2,WORK2(MAXTAB)
      INTEGER NSWEEP(MAXPAR)
      LOGICAL INV
C
C     SEE SUBROUTINES SETTAB FOR THE CONSTRUCTION OF THE TABLEAU
C     TABLE AND SEARCH FOR THE DEFINTION OF MOST VARIABLES.
C     NSWEEP =1 OR 0 ACCORDING AS A PARAMETER IS SWEPT OR NOT SWEPT.
C     FOR CHECKING TOLERANCE, SET WORK1 TO THE DIAGONAL ELEMENTS OF
C     TABLE.  BEGIN BY SWEEPING ON THOSE DIAGONAL ELEMENTS OF TABLE
C     CORRESPONDING TO THE PARAMETERS.  ALSO SWEEP ON THE DIAGONAL
C     ELEMENTS CORRESPONDING TO THE CONSTRAINTS.  IF ANY PARAMETER
C     FAILS THE TOLERANCE TEST, THEN RETURN AND RESET THE APPROXIMATE
C     HESSIAN.
C
      TOLS=-TOL*1.0D-3
      NCYCLE=0
      INV=.FALSE.
      DO 10 I=1,NPAR
      IF (TABLE(I,I).LE.0.0D0) RETURN
      WORK1(I)=TABLE(I,I)
 10   DELTA(I)=0.0D0
      DO 20 I=1,NPAR
      IF (TABLE(I,I)/WORK1(I).LT.TOL) RETURN
      CALL SWEEP(TABLE,WORK2,I,MAXTAB,NTAB,INV)
 20   NSWEEP(I)=1
      DO 30 I=1,NCNSTR
      K=NPAR+I
      IF (TABLE(K,K).GE.0.0D0) RETURN
 30   CALL SWEEP(TABLE,WORK2,K,MAXTAB,NTAB,INV)
C
C     TAKE A STEP IN THE DIRECTION TABLE(I,NTAB) FOR THE PARAMETERS
C     I THAT ARE CURRENTLY SWEPT.  IF A BOUNDARY IS ENCOUNTERED,
C     DETERMINE THE MAXIMAL FRACTIONAL STEP POSSIBLE.
C
 70   IF (NCYCLE.GE.1000) RETURN
      A=1.0D0
      DO 40 I=1,NPAR
      IF (NSWEEP(I).EQ.1) THEN
      UI=TABLE(I,NTAB)
      IF (UI.GT.0.0D0) THEN
      AI=PARMAX(I)-PAR(I)-DELTA(I)
      ELSE
      AI=PARMIN(I)-PAR(I)-DELTA(I)
      END IF
      IF (ABS(AI).LT.ABS(UI)) A=MIN(A,AI/UI)
      END IF
 40   CONTINUE
C
C     TAKE THE FRACTIONAL STEP FOR THE CURRENTLY SWEPT PARAMETERS,
C     AND RESET THE TRANSFORMED PARTIAL DERIVATIVES FOR THESE
C     PARAMETERS.
C
      DO 50 I=1,NPAR
      IF (NSWEEP(I).EQ.1) THEN
      UI=TABLE(I,NTAB)
      DELTA(I)=DELTA(I)+A*UI
      TABLE(I,NTAB)=(1.0D0-A)*UI
      END IF
 50   CONTINUE
C
C     FIND THOSE SWEPT PARAMETERS WHICH ARE CRITICAL, AND INVERSE
C     SWEEP THEM IF POSSIBLE.  GO BACK AND TRY TO TAKE ANOTHER
C     STEP OR FRACTIONAL STEP.
C
      DO 60 I=1,NPAR
      IF (NSWEEP(I).EQ.1.AND.TABLE(I,I)/WORK1(I).LT.TOLS.AND
     1.(PARMIN(I).GE.PAR(I)+DELTA(I)-SMALL.OR
     2.PARMAX(I).LE.PAR(I)+DELTA(I)+SMALL)) THEN
      INV=.TRUE.
      NCYCLE=NCYCLE+1
      CALL SWEEP(TABLE,WORK2,I,MAXTAB,NTAB,INV)
      NSWEEP(I)=0
      GO TO 70
      END IF
 60   CONTINUE
C
C     FIND AN UNSWEPT PARAMETER THAT VIOLATES THE KUHN-TUCKER
C     CONDIION AND SWEEP ON IT.  GO BACK AND TRY TO TAKE A
C     STEP OR FRACTIONAL STEP.  IF NO SUCH PARAMETER EXISTS,
C     THE PROBLEM IS SOLVED.
C
      DO 80 I=1,NPAR
      UI=TABLE(I,NTAB)
      IF (NSWEEP(I).EQ.0.AND
     1.((UI.GT.0.0D0.AND.PARMIN(I).GE.PAR(I)+DELTA(I)-SMALL).OR
     2.(UI.LT.0.0D0.AND.PARMAX(I).LE.PAR(I)+DELTA(I)+SMALL))) THEN
      INV=.FALSE.
      NCYCLE=NCYCLE+1
      CALL SWEEP(TABLE,WORK2,I,MAXTAB,NTAB,INV)
      NSWEEP(I)=1
      GO TO 70
      END IF
 80   CONTINUE
      NCYCLE=-1
      END

      SUBROUTINE SWEEP(TABLE,WORK,K,MAXTAB,NTAB,INV)
C
C     THIS SUBROUTINE SWEEPS OR INVERSE SWEEPS ON THE KTH
C     DIAGONAL ELEMENT OF THE TABLEAU TABLE.  SET INV TO FALSE
C     FOR SWEEP AND TO TRUE FOR INVERSE SWEEP.  OPERATIONS ARE
C     CARRIED OUT ON ONLY THE UPPER TRIANGULAR PART OF TABLE.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION TABLE(MAXTAB,MAXTAB),WORK(MAXTAB)
      LOGICAL INV
C
      DO 10 I=1,K
      WORK(I)=TABLE(I,K)
 10   TABLE(I,K)=0.0D0
      K1=K+1
      DO 20 I=K1,NTAB
      WORK(I)=TABLE(K,I)
 20   TABLE(K,I)=0.0D0
      S=WORK(K)
      IF (INV) THEN
      WORK(K)=1.0D0
      ELSE
      WORK(K)=-1.0D0
      END IF
      DO 30 J=1,NTAB
      DO 30 I=1,J
 30   TABLE(I,J)=TABLE(I,J)-WORK(I)*WORK(J)/S
      END

      SUBROUTINE ASYCOV(CNSTR,CVALUE,DF,HESS,PAR,TABLE,WORK1
     1,WORK2,NSWEEP,PNAME,CNORM,SMALL,TOL,MAXPAR,MAXTAB,MCNSTR
     2,NCNSTR,NPAR,UNIT3)
C
C     THIS SUBROUTINE COMPUTES THE ASYMPTOTIC COVARIANCE MATRIX
C     FOR THE PARAMETER ESTIMATES.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION CNSTR(MCNSTR,MAXPAR),CVALUE(MCNSTR),DF(MAXPAR)
     1,HESS(MAXPAR,MAXPAR),PAR(MAXPAR),TABLE(MAXTAB,MAXTAB)
     2,WORK1(MAXPAR),WORK2(MAXTAB)
      INTEGER NSWEEP(MAXPAR),UNIT3
      CHARACTER*8 PNAME(MAXPAR)
      LOGICAL INV
C
      INV=.FALSE.
      NTIMES=1
C
C     SET UP THE TABLEAU.  IF THE UPPER LEFT BLOCK IS NOT POSITIVE
C     DEFINITE, THEN INCREASE THE CONTRIBUTION OF THE CONSTRAINTS.
C     THIS WILL EVENTUALLY WORK DUE TO THEOREMS 6.1(CHAPS.1 AND 2)
C     IN: M.R.HESTENES(1981). 'OPTIMIZATION THEORY: THE FINITE
C     DIMENSIONAL CASE'  KRIEGER PUBLISHING. HUNTINGTON,NEW,YORK.
C
 110  CALL SETTAB(CNSTR,CVALUE,DF,HESS,PAR,TABLE,WORK2,CNORM
     1,MAXPAR,MAXTAB,MCNSTR,NCNSTR,NPAR,NTAB)
C
C     STORE THE DIAGONAL ELEMENTS OF TABLE IN WORK1 FOR CHECKING
C     TOLERANCE.
C
      DO 10 I=1,NPAR
      IF (NSWEEP(I).EQ.1.AND.TABLE(I,I).LE.0.0D0) GO TO 20
 10   WORK1(I)=TABLE(I,I)
C
C     SWEEP ONLY ON THOSE PARAMETERS WHICH ARE NOT ON A BOUNDARY
C     AND PASS THE TOLERANCE TEST.
C
      DO 30 I=1,NPAR
      IF (NSWEEP(I).NE.1) GO TO 30
      IF (TABLE(I,I)/WORK1(I).LT.TOL) GO TO 20
      CALL SWEEP(TABLE,WORK2,I,MAXTAB,NTAB,INV)
 30   CONTINUE
C
C     NEXT SWEEP ON THE CONSTRAINTS.  THE NEGATIVE OF THE
C     ASYMPTOTIC COVARIANCE MATRIX SHOULD APPEAR IN THE
C     UPPER LEFT BLOCK OF THE TABLEAU.
C
      DO 40 I=1,NCNSTR
      K=I+NPAR
      IF (TABLE(K,K).GE.0.0D0) GO TO 20
 40   CALL SWEEP(TABLE,WORK2,K,MAXTAB,NTAB,INV)
C
C     OUTPUT THE RESULTS.
C
      DO 50 J=1,NPAR
      IF (ABS(TABLE(J,J)).LT.SMALL) NSWEEP(J)=0
      IF (NSWEEP(J).EQ.1) THEN
      IF (TABLE(J,J).GT.0.0D0) GO TO 20
      WORK2(J)=SQRT(-TABLE(J,J))
      ELSE
      WORK2(J)=0.0D0
      END IF
      DO 50 I=1,J
      IF (NSWEEP(I).EQ.1.AND.NSWEEP(J).EQ.1) THEN
      TABLE(I,J)=-TABLE(I,J)/(WORK2(I)*WORK2(J))
      ELSE
      TABLE(I,J)=0.0D0
      END IF
 50   CONTINUE
      WRITE(UNIT3,60)
 60   FORMAT(/,' ASYMPTOTIC STANDARD ERRORS OF THE PARAMETERS:')
      WRITE(UNIT3,70) (PNAME(I),I=1,NPAR)
 70   FORMAT(100(/6(4X,A8),:))
      WRITE(UNIT3,80) (WORK2(I),I=1,NPAR)
 80   FORMAT(100(/6(1X,D11.4),:))
      WRITE(UNIT3,90)
 90   FORMAT(/,' ASYMPTOTIC CORRELATION MATRIX OF THE PARAMETERS:')
      WRITE(UNIT3,70) (PNAME(I),I=1,NPAR)
      DO 100 J=1,NPAR
 100  WRITE(UNIT3,80) (TABLE(I,J),I=1,J)
      RETURN
C
C     INCREASE THE CONTRIBUTION OF THE CONSTRAINTS BY DECREASING
C     CNORM.  RESET THE TABLEAU AND TRY AGAIN.
C
 20   IF (NTIMES.LT.6) THEN
      NTIMES=NTIMES+1
      CNORM=1.0D-1*CNORM
      GO TO 110
      END IF
      WRITE(UNIT3,120)
 120  FORMAT(/,' THE ASYMPTOTIC COVARIANCE MATRIX CANNOT BE COMPUTED.')
      END

      SUBROUTINE FUN(ALLFRQ,ARRAY,DF,EXTRA,GRID,HESS,PAR,PARMAX,PARS
     1,VAR,WORK1,WORK2,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT
     2,PERSON,XLINK,ABSENT,DP,F,XXRATE,XYRATE,COND,ITER,MAXA,MAXALL
     3,MAXGL,MAXI,MAXIW,MAXLST,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE
     4,MXWORK,NDERIV,NEXTRA,NLOCI,NPAR,NPED,NPEO,NPOINT,NPTOT,NVAR
     5,UNIT2,UNIT3,TRAVEL,FORWRD,PMODE,UMOVE)
C
C     THIS SUBROUTINE CONTROLS THE COMPUTATION OF F AND ITS FIRST
C     NDERIV PARTIAL DERIVATIVES.  F IS MINUS THE SUM OF THE
C     LOGLIKELIHOODS OVER ALL PEDIGREES.  THE DERIVATIVES ARE COMPUTED
C     NUMERICALLY; FORWARD OR CENTRAL DIFFERENCES ARE USED DEPENDING
C     ON THE LOGICAL VARIABLE FORWRD.  THE NUMERICAL DIFFERENTIATION
C     INTERVAL IS ADJUSTED TO TAKE INTO ACCOUNT THE MAGNITUDE OF A
C     PARAMETER AND WHETHER IT LIES ON ITS UPPER BOUND.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER PARSIZ
      DOUBLE PRECISION ALLFRQ(NLOCI,MAXALL),ARRAY(MAXA),DF(MAXPAR)
     1,EXTRA(NEXTRA),GRID(NPOINT,MAXPAR),HESS(MAXPAR,MAXPAR)
     2,PAR(MAXPAR),PARMAX(MAXPAR),PARS(MAXPAR,PARSIZ)
     3,VAR(MAXV),WORK1(MXWORK),WORK2(MXWORK),LOGLIK
      INTEGER GLIST(MAXGL),GPOINT(NLOCI,MAXPEO),GROUP(MAXPEO)
     1,INSTR(MAXI),IWORK(MAXIW),NGEN(NLOCI,MAXPEO),NJOINT(MAXPEO)
     2,PERSON(MAXPEO),COND,PED,UNIT2,UNIT3
      CHARACTER*8 IDFAM,TRAVEL
      LOGICAL XLINK(NLOCI),FORWRD,LUMPED,PMODE,UMOVE
      COMMON /SECRET/ PARSIZ,LUMPED
      SAVE LG,LI,MAXLA,IDFAM
C
      IF (TRAVEL.EQ.'SEARCH') THEN
C
C     INITALIZE F AND IT'S DERIVATIVES.
C
      F=0.0D0
      DO 10 I=1,NDERIV
 10   DF(I)=0.0D0
C
C     INITIALIZE THE HESSIAN.
C
      IF (UMOVE.AND.NPED.GT.1) THEN
      DO 20 J=1,NDERIV
      DO 20 I=1,NDERIV
 20   HESS(I,J)=0.0D0
      END IF
C
C     FIND THE PERTURBED PARAMETER VECTORS FOR PARTIAL DERVIATIVES.
C
      NLIKE=1
      DO 30 I=1,NPAR
 30   PARS(I,1)=PAR(I)
      DO 40 J=1,NDERIV
      NLIKE=NLIKE+1
      D=DP*MAX(ABS(PAR(J)),1.0D0)
      IF (FORWRD.AND.PAR(J)+D.GE.PARMAX(J)) D=-D
      DO 50 I=1,NPAR
 50   PARS(I,NLIKE)=PAR(I)
      PARS(J,NLIKE)=PAR(J)+D
      IF (.NOT.FORWRD) THEN
      NLIKE=NLIKE+1
      DO 60 I=1,NPAR
 60   PARS(I,NLIKE)=PAR(I)
      PARS(J,NLIKE)=PAR(J)-D
      END IF
 40   CONTINUE
      ELSE
C
C     OTHERWISE IN THE GRID OPTION STORE THE GRID IN PARS AND PREPARE
C     TO ACCUMULATE THE ITH NEGATIVE LOGLIKELIHOOD IN GRID(I,1).
C
      NLIKE=NPOINT
      DO 70 LIKE=1,NPOINT
      DO 80 I=1,NPAR
 80   PARS(I,LIKE)=GRID(LIKE,I)
 70   GRID(LIKE,1)=0.0D0
      END IF
C
C     REWIND THE SCRATCH UNIT.
C
      IF (NPED.GT.1.OR.ITER.EQ.1.OR.TRAVEL.EQ.'GRID') REWIND(UNIT2)
C
C     COMPUTE THE LOGLIKELIHOOD AND IT'S DERIVATIVES FOR EACH PEDIGREE.
C
      DO 90 PED=1,NPED
C
C     IF THIS IS THE FIRST ITERATION OR THERE ARE MULTIPLE PEDIGREES,
C     THEN READ THE NECESSARY DATA IN FROM THE SCRATCH FILE.
C
      IF (NPED.GT.1.OR.ITER.EQ.1.OR.TRAVEL.EQ.'GRID') THEN
      IF (LUMPED) THEN
      DO 95 LOCUS=1,NLOCI
      READ(UNIT2) NA,RESIDU
 95   ALLFRQ(LOCUS,NA)=RESIDU
      END IF
      READ(UNIT2) IDFAM,NPEO,NPTOT,LG
      CALL ISCRAT(PERSON,NPTOT,UNIT2,.FALSE.)
      CALL ISCRAT(GROUP,NPTOT,UNIT2,.FALSE.)
      CALL ISCRAT(NGEN,NPEO*NLOCI,UNIT2,.FALSE.)
      IF (.NOT.PMODE) CALL ISCRAT(NJOINT,NPEO,UNIT2,.FALSE.)
      CALL ISCRAT(GPOINT,NPEO*NLOCI,UNIT2,.FALSE.)
      CALL ISCRAT(GLIST,LG,UNIT2,.FALSE.)
      MVAR=NVAR*NPTOT
      IF (MVAR.GT.0) CALL RSCRAT(VAR,MVAR,UNIT2,.FALSE.)
      READ(UNIT2) LI
      CALL ISCRAT(INSTR,LI,UNIT2,.FALSE.)
      READ(UNIT2) MAXLA
C*************************
C      IF (ITER.EQ.1) THEN
C      PRINT*,'NPEO,NPTOT,LG',NPEO,NPTOT,LG
C      PRINT*,'PERSON',(PERSON(II),II=1,NPTOT)
C      PRINT*,'GROUP',(GROUP(II),II=1,NPTOT)
C      PRINT*,'NGEN'
C      DO 11 II=1,NPEO
C 11   PRINT*,(NGEN(LL,II),LL=1,NLOCI)
C      IF (.NOT.PMODE) PRINT*,'NJOINT',(NJOINT(II),II=1,NPEO)
C      PRINT*,'GPOINT'
C      DO 12 II=1,NPEO
C 12   PRINT*,(GPOINT(LL,II),LL=1,NLOCI)
C      PRINT*,'GLIST',(GLIST(II),II=1,LG)
C      PRINT*,'VAR',(VAR(II),II=1,MVAR)
C      PRINT*,'LI',LI
C      PRINT*,'INSTR',(INSTR(II),II=1,LI)
C      END IF
C*************************
      END IF
C
C     COMPUTE THIS PEDIGREE'S INCREMENTS TO F AND DF.
C
      DO 100 LIKE=1,NLIKE
 100  CALL OPERAT(ALLFRQ,ARRAY,EXTRA,WORK2(LIKE),PARS(1,LIKE),VAR
     1,WORK1,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,PERSON,XLINK
     2,ABSENT,XXRATE,XYRATE,MAXA,MAXALL,MAXGL,MAXI,MAXIW,MAXLA,MAXLST
     3,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE,MXWORK,NEXTRA,NLOCI,NPAR
     4,NPEO,NPTOT,NVAR,PED,UNIT3,IDFAM,PMODE,LIKE)
      DO 110 LIKE=1,NLIKE
      IF (TRAVEL.EQ.'SEARCH') THEN
      NITER=ITER
      ELSE
      NITER=LIKE
      END IF
C &&&&&&&&&&&&&&&&&&&& - AJL - 15/10/2013 - BEGIN
C 110  CALL NEWLIK(EXTRA,PARS(1,LIKE),WORK2(LIKE),COND,NITER,NEXTRA
C     1,MAXPAR,NPED,PED)
 110  CALL NEWLIK(EXTRA,PARS(1,LIKE),WORK2(LIKE),COND,NITER,NEXTRA
     1,MAXPAR,NPED,PED,IDFAM)
C &&&&&&&&&&&&&&&&&&&& - AJL - 15/10/2013 - END
C
      IF (TRAVEL.EQ.'SEARCH') THEN
      LOGLIK=WORK2(1)
      F=F-LOGLIK
C
C     USE FORWARD DIFFERENCES FOR THE ITH PARTIAL DERIVATIVE.
C
      IF (FORWRD) THEN
      DO 120 LIKE=2,NLIKE
      I=LIKE-1
      WORK2(I)=(WORK2(LIKE)-LOGLIK)/(PARS(I,LIKE)-PAR(I))
 120  DF(I)=DF(I)-WORK2(I)
C
C     USE CENTRAL DIFFERENCES FOR THE ITH PARTIAL DERIVATIVE.
C
      ELSE
      DO 130 LIKE=2,NLIKE,2
      I=LIKE/2
      D2=PARS(I,LIKE)-PARS(I,LIKE+1)
      WORK2(I)=(WORK2(LIKE)-WORK2(LIKE+1))/D2
 130  DF(I)=DF(I)-WORK2(I)
      END IF
      IF (UMOVE.AND.NPED.GT.1) THEN
      DO 140 J=1,NDERIV
      DO 140 I=1,NDERIV
 140  HESS(I,J)=HESS(I,J)+WORK2(I)*WORK2(J)
      END IF
      ELSE
C
C     FOR THE GRID OPTION ACCUMULATE THE NEGATIVE LOGLIKELIHOODS.
C
      DO 150 LIKE=1,NLIKE
 150  GRID(LIKE,1)=GRID(LIKE,1)-WORK2(LIKE)
      END IF
 90   CONTINUE
      END

      SUBROUTINE OPERAT(ALLFRQ,ARRAY,EXTRA,LOGLIK,PARS,VAR,WORK1
     1,GLIST,GPOINT,GROUP,INSTR,IWORK,NGEN,NJOINT,PERSON,XLINK
     2,ABSENT,XXRATE,XYRATE,MAXA,MAXALL,MAXGL,MAXI,MAXIW,MAXLA
     3,MAXLST,MAXPAR,MAXPEO,MAXV,MAXVAR,MUTATE,MXWORK,NEXTRA
     4,NLOCI,NPAR,NPEO,NPTOT,NVAR,PED,UNIT3,IDFAM,PMODE,LIKE)
C
C     THIS SUBROUTINE INTERPRETS THE INSTRUCTION VECTOR, CALLING FOR
C     THE PROPER OPERATION AT EACH STEP.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ALLFRQ(NLOCI,MAXALL),ARRAY(MAXA),EXTRA(NEXTRA)
     1,LOGLIK,PARS(MAXPAR),VAR(MAXV),WORK1(MXWORK)
      INTEGER LIKE
      INTEGER GLIST(MAXGL),GPOINT(NLOCI,MAXPEO),GROUP(MAXPEO)
     1,INSTR(MAXI),IWORK(MAXIW),NGEN(NLOCI,MAXPEO),NJOINT(MAXPEO)
     2,PERSON(MAXPEO),POINT(3),RANK(3),START(2),PED,UNIT3
      CHARACTER*8 IDFAM
      LOGICAL XLINK(NLOCI),PMODE
C
C     INITIALIZE VARIABLES.
C
      N1=MAXIW/2+1
      N2=MAXLST+1
      N3=MAXLST+N2
      IERROR=0
      LI=0
      LOGLIK=0.0D0
C
C     GET THE NEXT OPERATOR.
C
 90   LI=LI+1
      IOPER=-INSTR(LI)
      GO TO (20,30,40,50,50,70,80), IOPER
C
C     IOPER=1 SO CREATE THE PENETRANCE-PRIOR ARRAYS.
C
 20   CALL PANDP(ALLFRQ,ARRAY,EXTRA,PARS,VAR,WORK1,GLIST,GPOINT
     1,GROUP,IWORK,NGEN,PERSON,XLINK,ABSENT,XXRATE,XYRATE,MAXALL
     2,MAXPAR,MAXVAR,MUTATE,NEXTRA,NLOCI,NPEO,NPTOT
     3,NVAR,PED,PMODE,LIKE)
      GO TO 90
C
C     IOPER=2 SO CREATE A TRANSMISSION ARRAY.
C
 30   LI=LI+1
      IPOINT=INSTR(LI)
      CALL TRAN(ARRAY(IPOINT),EXTRA,PARS,VAR,GLIST,GPOINT,GROUP,INSTR
     1,IWORK,IWORK(N1),NGEN,PERSON,XLINK,ABSENT,XXRATE,XYRATE,LI,MAXI
     2,MAXPAR,MAXVAR,MUTATE,NEXTRA,NLOCI,NVAR,PED,PMODE)
      GO TO 90
C
C     IOPER=3 SO REPACK THE BIG ARRAY.
C
 40   CALL APACK(ARRAY,INSTR,LI)
      GO TO 90
C
C     IOPER=4 OR 5 SO PREPARE A PURE MULTIPLY OR A MULTIPLY AND
C     ADD.
C
 50   INODE=INSTR(LI+1)
      POINT(1)=INSTR(LI+2)
      POINT(2)=INSTR(LI+3)
      POINT(3)=INSTR(LI+4)
      RANK(1)=INSTR(LI+5)
      RANK(2)=INSTR(LI+6)
      LI=LI+7
      RANK(3)=INSTR(LI)
      IF (IOPER.EQ.5) THEN
      LI=LI+1
      K=INSTR(LI)
      END IF
      DO 60 J=1,2
      START(J)=LI+1
 60   LI=LI+RANK(J)
      ISTART=LI+1
      LI=LI+RANK(3)
      CALL MULSUM(ARRAY,LOGLIK,INSTR(ISTART),IWORK,IWORK(N2)
     1,IWORK(N3),INSTR(START(1)),POINT,INSTR(START(2)),RANK,IERROR
     2,IOPER,K,MAXA)
      GO TO 100
C
C     IOPER=6 SO PREPARE A PURE ADD.
C
 70   LI=LI+1
      IPOINT=INSTR(LI)
      LI=LI+1
      INODE=INSTR(LI)
      IF (PMODE) THEN
      CALL ASUM(ARRAY(IPOINT),LOGLIK,NGEN,INODE,IERROR)
      ELSE
      CALL ASUM(ARRAY(IPOINT),LOGLIK,NJOINT,INODE,IERROR)
      END IF
C
C     CHECK WHETHER A ZERO ARRAY OCCURS.  IF SO QUIT.
C
 100  IF (IERROR.EQ.0) GO TO 90
      IF (PMODE) INODE=(INODE-1)/NLOCI+1
      WRITE(UNIT3,110) PED,IDFAM,PERSON(INODE)
 110  FORMAT(/,' *** ERROR *** PEDIGREE NUMBER',I4,' WITH ID ',A8
     1,' HAS AN INCONSISTENCY',/,' NEAR PERSON NUMBER',I4,'.')
      IF (NPAR.GT.0) WRITE(UNIT3,120) (PARS(I),I=1,NPAR)
 120  FORMAT(/,' PARAMETERS JUST BEFORE STOP:',(T30,3(1X,D11.4)/))
      STOP
C
C     IOPER=7 SO COMPUTE THE FINAL LOG LIKELIHOOD.
C
 80   RETURN
      END

      SUBROUTINE MULSUM_ORIG(ARRAY,LOGLIK,EXTENT,INCRP,INCRQ,INDEX
     1,PLIST,POINT,QLIST,RANK,IERROR,IOPER,K)
C
C     THIS SUBROUTINE TAKES TWO ARRAYS P AND Q AND EITHER
C     FORMS THEIR PRODUCT R OR THEIR PRODUCT R SUMMED ON
C     ITS KTH INDEX.  ALL THREE ARRAYS ARE LISTED IN REVERSE
C     DICTIONARY ORDER IN ARRAY.  PLIST AND QLIST GIVE THE
C     CONSOLIDATED NODES IN P AND Q.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ARRAY(*),LOGLIK
      INTEGER EXTENT(*),INCRP(*),INCRQ(*),INDEX(*),PLIST(*),POINT(*)
     1,QLIST(*),RANK(*),PSKIP,PPSKIP,QSKIP,QQSKIP
      LOGICAL ADD
C
C     INITIALIZE SOME VARIABLES.  SOME OF THESE DEPEND ON
C     WHETHER A MULTIPLY OR A MULTIPLY AND SUM IS INDICATED.
C
      LOCP=POINT(1)
      LOCQ=POINT(2)
      LOCR=POINT(3)
      DO 10 I=1,RANK(3)
 10   INDEX(I)=1
      ADD=IOPER.EQ.5
      IF (ADD) THEN
      NK=EXTENT(K)
      NKMIN1=NK-1
      KMIN1=K-1
      ELSE
      K=0
      END IF
C
C     CALCULATE THE INCREMENTATION PATTERN FOR THE MULTIPLICAND
C     ARRAY P.
C
      NMULT=1
      INDEXP=1
C
C     CONSIDER EACH INDEX FOR THE PRODUCT ARRAY R.
C
      DO 20 INDEXR=1,RANK(3)
      IF (INDEXP.GT.RANK(1)) THEN
C
C     ALL THE MULTIPLICAND INDICES HAVE BEEN EXHAUSTED.
C
      NMULT=1-NMULT
      DO 30 L=INDEXR,RANK(3)
 30   INCRP(L)=NMULT
      GO TO 40
      END IF
C
      IF (INDEXR.EQ.PLIST(INDEXP)) THEN
C
C     THE CURRENT PRODUCT INDEX COINCIDES WITH A MULTIPLICAND
C     INDEX.
C
      IF (INDEXR.EQ.K) IC=NMULT
      NMULT=NMULT*EXTENT(INDEXR)
      INCRP(INDEXR)=1
      INDEXP=INDEXP+1
      ELSE
C
C     THE CURRENT PRODUCT INDEX IS NOT A MULTIPLICAND INDEX.
C
      INCRP(INDEXR)=1-NMULT
      END IF
 20   CONTINUE
 40   IF (ADD) THEN
C
C     SET THE SKIP CONSTANT FOR SUMMING.
C
      PSKIP=IC
      PPSKIP=PSKIP*NKMIN1
C
C     ADJUST THE INCREMENT FOR THOSE INDICES BEFORE THE KTH
C     TO CORRECT FOR THE PARALLEL SUMMING PROCESS.
C
      IC=NKMIN1*IC
      DO 50 INDEXR=1,KMIN1
 50   INCRP(INDEXR)=INCRP(INDEXR)-IC
      END IF
C
C     CALCULATE THE INCREMENTATION PATTERN FOR THE MULTIPLICAND
C     ARRAY Q.
C
      NMULT=1
      INDEXQ=1
      DO 60 INDEXR=1,RANK(3)
      IF (INDEXQ.GT.RANK(2)) THEN
      NMULT=1-NMULT
      DO 70 L=INDEXR,RANK(3)
 70   INCRQ(L)=NMULT
      GO TO 80
      END IF
      IF (INDEXR.EQ.QLIST(INDEXQ)) THEN
      IF (INDEXR.EQ.K) IC=NMULT
      NMULT=NMULT*EXTENT(INDEXR)
      INCRQ(INDEXR)=1
      INDEXQ=INDEXQ+1
      ELSE
      INCRQ(INDEXR)=1-NMULT
      END IF
 60   CONTINUE
 80   IF (ADD) THEN
      QSKIP=IC
      QQSKIP=QSKIP*NKMIN1
      IC=NKMIN1*IC
      DO 90 INDEXR=1,KMIN1
 90   INCRQ(INDEXR)=INCRQ(INDEXR)-IC
      END IF
C
C     CALCULATE THE PRODUCT R AND SUM ON ITS KTH INDEX IF NECESSARY.
C
 100  IF (.NOT.ADD) THEN
      ARRAY(LOCR)=ARRAY(LOCP)*ARRAY(LOCQ)
      ELSE
      INDEX(K)=NK
      A=0.0D0
      IP=LOCP
      IQ=LOCQ
      DO 130 I=1,NK
      A=A+ARRAY(IP)*ARRAY(IQ)
      IP=IP+PSKIP
 130  IQ=IQ+QSKIP
      ARRAY(LOCR)=A
      LOCP=LOCP+PPSKIP
      LOCQ=LOCQ+QQSKIP
      END IF
C
C     FIND THE FIRST INDEX OF R WHICH CAN BE INCREMENTED.  RESET THE
C     PRECEEDING INDICES TO ONE.  UPDATE THE LOCATIONS IN P, Q, AND R.
C
      DO 140 I=1,RANK(3)
      IF (INDEX(I).NE.EXTENT(I)) THEN
      INDEX(I)=INDEX(I)+1
      LOCP=LOCP+INCRP(I)
      LOCQ=LOCQ+INCRQ(I)
      LOCR=LOCR+1
      GO TO 100
      ELSE
      INDEX(I)=1
      END IF
 140  CONTINUE
C
C     KEEP TRACK OF THE LARGEST AND SMALLEST R ENTRIES.
C
      AHI=0.0D0
      ALO=1.0D20
      DO 160 I=POINT(3),LOCR
      A=ARRAY(I)
      IF (A.GT.0.0D0) THEN
      AHI=MAX(AHI,A)
      ALO=MIN(ALO,A)
      END IF
 160  CONTINUE
C
C     RETURN WITH AN ERROR MESSAGE IF R CONSISTS OF ALL ZEROS.
C
      IF (AHI.LE.0.0D0) THEN
      IERROR=1
      RETURN
      END IF
C
C     RESCALE IF NECESSARY.
C
      IF (AHI.GT.1.0D10.OR.(ALO.LE.1.0D-10.AND.AHI.LT.1.0D0)) THEN
      LOGLIK=LOGLIK+LOG(AHI)
      DO 170 I=POINT(3),LOCR
      A=ARRAY(I)
 170  IF (A.GT.0.0D0) ARRAY(I)=A/AHI
      END IF
      END


      SUBROUTINE APACK(ARRAY,INSTR,LI)
C
C     THIS SUBROUTINE CARRIES OUT THE REPACKING OF THE BIG
C     ARRAY.  INSTR GIVES THE SIZE OF THE ALTERNATING GOOD
C     BLOCKS AND JUNK BLOCKS.  A GOOD BLOCK ALWAYS COMES FIRST.
C
      DOUBLE PRECISION ARRAY(*)
      INTEGER INSTR(*)
C
      I=0
      JSTART=1
      LI=LI+1
      DO 10 K=1,INSTR(LI)
      LI=LI+1
      IF (MOD(K,2).EQ.1) THEN
      JEND=JSTART+INSTR(LI)-1


      DO 30 J=JSTART,JEND
      I=I+1
 30   ARRAY(I)=ARRAY(J)
      ELSE
      JSTART=JEND+INSTR(LI)+1
      END IF
 10   CONTINUE
      END


      SUBROUTINE ASUM(ARRAY,LOGLIK,NGEN,I,IERROR)
C
C     THIS SUBROUTINE PERFORMS A PURE ADD.  BY CONSTRUCTION,
C     THIS OCCURS ONLY WHEN A SINGLE PERSON OR LOCUS-PERSON
C     COMBINATION IS INVOLED.  OTHER ADDS INVOKE A MULTIPLY
C     OPERATION SIMULTANEOUSLY.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ARRAY(*),LOGLIK
      INTEGER NGEN(*)

      A=0.0D0
      DO 20 L=1,NGEN(I)
 20   A=A+ARRAY(L)
      IF (A.LE.0.0D0) THEN
      IERROR=1
      RETURN
      ELSE
      LOGLIK=LOGLIK+LOG(A)
      END IF
      END

      SUBROUTINE PANDP(ALLFRQ,ARRAY,EXTRA,PARS,VAR,WORK1,GLIST
     1,GPOINT,GROUP,LIST,NGEN,PERSON,XLINK,ABSENT,XXRATE,XYRATE
     2,MAXALL,MAXPAR,MAXVAR,MUTATE,NEXTRA,NLOCI,NPEO
     3,NPTOT,NVAR,PED,PMODE,LIKE)
C
C     THIS SUBROUTINE CREATES THE PENETRANCE-PRIOR ARRAYS FOR
C     EACH PERSON OR EACH LOCUS-PERSON COMBINATION.  THESE PRODUCTS
C     OF PENETRANCE AND PRIOR ARRAYS ALSO INCLUDE THE PENETRANCE
C     CONTRIBUTION OF ANY MZ-TWIN OF THE CURRENT PERSON.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ALLFRQ(NLOCI,*),ARRAY(*),EXTRA(*)
     1,PARS(MAXPAR),VAR(*),WORK1(*)
      INTEGER LIKE
      INTEGER GLIST(*),GPOINT(NLOCI,*),GROUP(*),LIST(*),NGEN(NLOCI,*)
     1,PERSON(*),FIRST,PED,PERI
      LOGICAL XLINK(*),MALE,PMODE
C
      IF (PMODE) THEN
      NODES=NLOCI*NPEO
      ELSE
      NODES=NPEO
      END IF
      LA=1
      DO 10 INODE=1,NODES
C
C     IF THIS IS PRODUCT MODE, DETERMINE THE LOCUS-PERSON COMBINATION.
C
      IF (PMODE) THEN
      I=(INODE-1)/NLOCI+1
      FIRST=INODE-(I-1)*NLOCI
      LAST=FIRST
      ELSE
      I=INODE
      FIRST=1
      LAST=NLOCI
      END IF
C
C     DETERMINE THE SEX, MZ-TWIN SET, AND THE ORIGINAL POSITION IN
C     THE PEDIGREE OF THE CURRENT PERSON I.  IVAR IS THE START LOCATION
C     IN VAR FOR I'S NUMERIC VARIABLES.  ALSO CREATE THE MULTIPLE LOCUS
C     GENOTYPES FOR I.
C
      IF (FIRST.EQ.1) THEN
      IGROUP=GROUP(I)
      MALE=MOD(ABS(IGROUP),2).EQ.1
      ITWIN=ABS(IGROUP)/4
      PERI=PERSON(I)
      IVAR=(I-1)*NVAR+1
      END IF
C
C     PREPARE THE GENOTYPE LIST FOR I.
C
      IF (FIRST.NE.LAST) THEN
      CALL HTYPE(GLIST,GPOINT,LIST,NGEN,FIRST,I,LAST,NGTYPE,NLOCI)
      ELSE
      IBEGIN=GPOINT(FIRST,I)
      NGTYPE=NGEN(FIRST,I)
      END IF
C
C     COMPUTE THE PENETRANCE ARRAY.
C
      IF (FIRST.NE.LAST) THEN
      CALL APEN(EXTRA,PARS,ARRAY(LA),VAR(IVAR),LIST,XLINK
     1,ABSENT,XXRATE,XYRATE,FIRST,LAST,MUTATE,NEXTRA,NGTYPE,NLOCI
     2,MAXPAR,MAXVAR,PED,PERI,MALE,LIKE)
      ELSE
      CALL APEN(EXTRA,PARS,ARRAY(LA),VAR(IVAR),GLIST(IBEGIN)
     1,XLINK,ABSENT,XXRATE,XYRATE,FIRST,LAST,MUTATE,NEXTRA,NGTYPE
     2,NLOCI,MAXPAR,MAXVAR,PED,PERI,MALE,LIKE)
      END IF
C
C     COMPUTE THE PRIOR ARRAY IF I IS A FOUNDER.
C
      IF (IGROUP.LT.0) THEN
      IF (FIRST.NE.LAST) THEN
      CALL APRIOR(ALLFRQ,EXTRA,PARS,WORK1,VAR(IVAR),LIST
     1,XLINK,ABSENT,XXRATE,XYRATE,FIRST,LAST,MAXALL,MUTATE,NEXTRA
     2,NGTYPE,NLOCI,MAXPAR,MAXVAR,PED,PERI,MALE)
      ELSE
      CALL APRIOR(ALLFRQ,EXTRA,PARS,WORK1,VAR(IVAR)
     1,GLIST(IBEGIN),XLINK,ABSENT,XXRATE,XYRATE,FIRST,LAST,MAXALL
     2,MUTATE,NEXTRA,NGTYPE,NLOCI,MAXPAR,MAXVAR,PED,PERI,MALE)
      END IF
C
C     TAKE THE PRODUCT OF THE PENETRANCE AND PRIOR ARRAYS.
C
      IA=LA
      DO 30 IGEN=1,NGTYPE
      ARRAY(IA)=ARRAY(IA)*WORK1(IGEN)
 30   IA=IA+1
      END IF
C
C     COMPUTE THE PENETRANCE ARRAY FOR ANY IDENTICAL TWIN AND TAKE
C     ITS PRODUCT WITH THE CURRENT ARRAY.
C
      IF (ITWIN.NE.0) THEN
      DO 40 J=NPEO+1,NPTOT
      JTWIN=ABS(GROUP(J))/4
      IF (JTWIN.EQ.ITWIN) THEN
      JVAR=(J-1)*NVAR+1
      IF (FIRST.NE.LAST) THEN
      CALL APEN(EXTRA,PARS,WORK1,VAR(JVAR),LIST,XLINK,ABSENT
     1,XXRATE,XYRATE,FIRST,LAST,MUTATE,NEXTRA,NGTYPE,NLOCI,MAXPAR
     2,MAXVAR,PED,PERSON(J),MALE,LIKE)
      ELSE
      CALL APEN(EXTRA,PARS,WORK1,VAR(JVAR),GLIST(IBEGIN)
     1,XLINK,ABSENT,XXRATE,XYRATE,FIRST,LAST,MUTATE,NEXTRA,NGTYPE
     2,NLOCI,MAXPAR,MAXVAR,PED,PERSON(J),MALE,LIKE)
      END IF
      IA=LA
      DO 50 IGEN=1,NGTYPE
      ARRAY(IA)=ARRAY(IA)*WORK1(IGEN)
 50   IA=IA+1
      END IF
 40   CONTINUE
      END IF
 10   LA=LA+NGTYPE
      END

      SUBROUTINE TRAN(ARRAY,EXTRA,PARS,VAR,GLIST,GPOINT,GROUP,INSTR
     1,ILIST,JLIST,NGEN,PERSON,XLINK,ABSENT,XXRATE,XYRATE,LI,MAXI
     2,MAXPAR,MAXVAR,MUTATE,NEXTRA,NLOCI,NVAR,PED,PMODE)
C
C     THIS SUBROUTINE ORCHESTRATES THE CALCULATION OF THE
C     TRANSMISSION ARRAYS FOR ALL PARENT-OFFSPRING PAIRS.  TRAN
C     CALLS THE USER SUPPLIED SUBROUTINE TRANS.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION ARRAY(*),EXTRA(*),PARS(MAXPAR),VAR(*)
      INTEGER GLIST(*),GPOINT(NLOCI,*),GROUP(*),ILIST(*),INSTR(MAXI)
     1,JLIST(*),NGEN(NLOCI,*),PERSON(*),PED,PERI,PERJ,FIRST,SPREAD
      LOGICAL XLINK(*),MALEI,MALEJ,PMODE
C
      IA=1
 10   IF (INSTR(LI+1).LT.0) RETURN
      INODE=INSTR(LI+1)
      LI=LI+2
      JNODE=INSTR(LI)
C
C     IF THIS IS PRODUCT MODE, DETERMINE THE TWO PEOPLE AND THE
C     FIRST AND LAST LOCI CONSIDERED.
C
      IF (PMODE) THEN
      I=(INODE-1)/NLOCI+1
      J=(JNODE-1)/NLOCI+1
      FIRST=INODE-(I-1)*NLOCI
      LAST=JNODE-(J-1)*NLOCI
      ELSE
      I=INODE
      J=JNODE
      FIRST=1
      LAST=NLOCI
      END IF
C
C     FIND THE SEX, ORIGINAL POSITION IN THE PEDIGREE, START LOCATION
C     IN VAR, AND MULTIPLE LOCUS GENOTYPES FOR I AND J.
C
      MALEI=MOD(ABS(GROUP(I)),2).EQ.1
      PERI=PERSON(I)
      IVAR=(I-1)*NVAR+1
      CALL HTYPE(GLIST,GPOINT,ILIST,NGEN,FIRST,I,LAST,NGENI,NLOCI)
      MALEJ=MOD(ABS(GROUP(J)),2).EQ.1
      PERJ=PERSON(J)
      JVAR=(J-1)*NVAR+1
      CALL HTYPE(GLIST,GPOINT,JLIST,NGEN,FIRST,J,LAST,NGENJ,NLOCI)
C
C     FIND THE TRANSMISSION PROBABILITIES FROM THE PARENT'S GENOTYPES
C     TO THE CHILD'S GAMETES.
C
      SPREAD=LAST-FIRST+1
      IF (MALEI) THEN
      JSTART=SPREAD+1
      ELSE
      JSTART=1
      END IF
      JUMP=SPREAD+SPREAD
      DO 20 JP=JSTART,JUMP*NGENJ,JUMP
      CALL ATRANS(EXTRA,PARS,ARRAY(IA),VAR(IVAR)
     1,VAR(JVAR),JLIST(JP),ILIST,XLINK,ABSENT,XXRATE,XYRATE,FIRST,LAST
     2,MUTATE,NEXTRA,NGENI,NLOCI,MAXPAR,MAXVAR,PED,PERI,PERJ,MALEI
     3,MALEJ)
 20   IA=IA+NGENI
      GO TO 10
      END

      SUBROUTINE HTYPE(GLIST,GPOINT,LIST,NGEN,FIRST,I,LAST,NGTYPE
     1,NLOCI)
C
C     THIS SUBROUTINE CREATES THE MULTIPLE LOCUS GENOTYPES FOR PERSON I
C     FROM HIS SINGLE LOCUS GENOTYPES.  ONLY LOCI BETWEEN POSITIONS
C     FIRST AND LAST ARE CONSIDERED.
C
      INTEGER GLIST(*),GPOINT(NLOCI,*),LIST(*),NGEN(NLOCI,*)
     1,FIRST,SPREAD
C
C     COMPUTE THE NUMBER OF MULTIPLE LOCUS GENOTYPES FOR I.
C
      NGTYPE=1
      DO 10 LOCUS=FIRST,LAST
 10   NGTYPE=NGTYPE*NGEN(LOCUS,I)
C
C     CREATE THE MULTIPLE LOCUS GENOTYPES BY TAKING THE APPROPRIATE
C     CARTESIAN PRODUCT.  NOTE HOW NESTED DO LOOPS ARE AVOIDED BY
C     COMPUTING THE REVERSE DICTIONARY LOCATION OF EACH ELEMENT OF THE
C     PRODUCT.
C
      K=0
      SPREAD=LAST-FIRST+1
      DO 20 J=0,NGTYPE-1
      JJ=J
      DO 30 LOCUS=FIRST,LAST
      N=NGEN(LOCUS,I)
      JJJ=JJ/N
      L=GPOINT(LOCUS,I)+2*(JJ-JJJ*N)
      K=K+1
      LIST(K)=GLIST(L)
      LIST(K+SPREAD)=GLIST(L+1)
 30   JJ=JJJ
 20   K=K+SPREAD
      END


      SUBROUTINE MULSUM( ARRAY, LOGLIK, EXTENT, INCRP, INCRQ, INDEX,
     +                   PLIST, POINT, QLIST, RANK, IERROR, IOPER, K,
     +                   MAXA )

C THIS SUBROUTINE TAKES TWO ARRAYS P AND Q AND EITHER
C FORMS THEIR PRODUCT R OR THEIR PRODUCT R SUMMED ON
C ITS KTH INDEX.  ALL THREE ARRAYS ARE LISTED IN REVERSE
C DICTIONARY ORDER IN ARRAY.  PLIST AND QLIST GIVE THE
C CONSOLIDATED NODES IN P AND Q.

      IMPLICIT NONE
      INTEGER MAXA, IERROR, IOPER, K
      INTEGER EXTENT( * ), INCRP( * ), INCRQ( * )
      INTEGER INDEX( * ), PLIST( * )
      INTEGER POINT( 3 ), QLIST( * ), RANK( 3 )
      DOUBLE PRECISION ARRAY( MAXA ), LOGLIK
      LOGICAL USE_BLAS
      PARAMETER( USE_BLAS = .TRUE. )
C      PARAMETER( USE_BLAS = .FALSE. )

      IF ( USE_BLAS ) THEN

       IF ( IOPER .EQ. 5 ) THEN
        CALL MUL_SUM( ARRAY, LOGLIK, EXTENT, INCRP, INCRQ, INDEX,
     +                PLIST, POINT, QLIST, RANK, IERROR, IOPER, K,
     +                MAXA )
       ELSE
        CALL MUL( ARRAY, LOGLIK, EXTENT, INCRP, INCRQ, INDEX,
     +            PLIST, POINT, QLIST, RANK, IERROR, IOPER, K,
     +            MAXA )
       ENDIF

      ELSE
       CALL MULSUM_ORIG( ARRAY, LOGLIK, EXTENT, INCRP, INCRQ, INDEX,
     +                   PLIST, POINT, QLIST, RANK, IERROR, IOPER, K )
      ENDIF

      RETURN
      END


      SUBROUTINE MUL_SUM( ARRAY, LOGLIK, EXTENT, INCRP, INCRQ, INDEX,
     +                    PLIST, POINT, QLIST, RANK, IERROR, IOPER, K,
     +                    MAXA )

C THIS SUBROUTINE TAKES TWO ARRAYS P AND Q AND
C FORMS THEIR PRODUCT R SUMMED ON ITS KTH INDEX.
C ALL THREE ARRAYS ARE LISTED IN REVERSE DICTIONARY
C ORDER IN ARRAY. PLIST AND QLIST GIVE THE
C CONSOLIDATED NODES IN P AND Q.

      IMPLICIT NONE


      INTEGER IERROR, IOPER, K, MAXA
      INTEGER PLIST( * ), POINT( 3 ), QLIST( * ), RANK( 3 )
      INTEGER EXTENT( * ), INCRP( * ), INCRQ( * ),  INDEX( * )
      DOUBLE PRECISION ARRAY( MAXA ), LOGLIK

      INTEGER POINT_A, POINT_B, POINT_C
      INTEGER M, N, ldA, ldB, NK, INCX, INCY

      CHARACTER*1 transA, transB
      DOUBLE PRECISION AHI, ALO
      LOGICAL USE_DG, USE_ORIG, ECHO_CASES
C      PARAMETER( ECHO_CASES = .TRUE. )
      PARAMETER( ECHO_CASES = .FALSE. )


C 
C The common cases are as follows :
C
C RANK = (/ 2, 2, 3 /)
C PLIST = { 1, 2 }, QLIST = { 1, 3 }, K = 1 : A
C PLIST = { 1, 3 }, QLIST = { 1, 2 }, K = 1 : B
C PLIST = { 1, 2 }, QLIST = { 2, 3 }, K = 2 : C
C PLIST = { 2, 3 }, QLIST = { 1, 2 }, K = 2 : D
C PLIST = { 1, 3 }, QLIST = { 2, 3 }, K = 3 : E
C PLIST = { 2, 3 }, QLIST = { 1, 3 }, K = 3 : F
C
C A  :  R( i, j ) = SUM_k P( k, i ) Q( k, j ), i < k < j
C
C B  :  R( i, j ) = SUM_k P( k, j ) Q( k, i ), i < j < k
C
C C  :  R( i, j ) = SUM_k P( i, k ) Q( k, j ), i < j < k
C
C D  :  R( i, j ) = SUM_k P( k, j ) Q( i, k ), k < i < j
C
C E  :  R( i, j ) = SUM_k P( i, k ) Q( j, k ), k < i < j
C
C F  :  R( i, j ) = SUM_k P( j, k ) Q( i, k ), i < k < j
C
C
C
C RANK = (/ 2, 2, 2 /)
C PLIST = { 1, 2 }, QLIST = { 1, 2 }, K = 1 : H
C PLIST = { 1, 2 }, QLIST = { 1, 2 }, K = 2 : I
C
C G  :  R( i ) = SUM_k P( k, i ) Q( k, i ), k < i
C
C H  :  R( i ) = SUM_k P( i, k ) Q( i, k ), i < k
C
C
C
C RANK = (/ 2, 1, 2 /) # I and J checked, and agree.
C PLIST = { 1, 2 }, QLIST = { 1 }, K = 1 : I
C PLIST = { 1, 2 }, QLIST = { 2 }, K = 2 : J
C
C I  :  R( i ) = SUM_k P( k, i ) Q( k ), k < i
C
C J  :  R( i ) = SUM_k P( i, k ) Q( k ), i < k
C
C
C
C RANK = (/ 1, 2, 2 /) # K and L checked, and agree.
C PLIST = { 1 }, QLIST = { 1, 2 }, K = 1 : K
C PLIST = { 2 }, QLIST = { 1, 2 }, K = 2 : L
C
C K  :  R( i ) = SUM_k P( k ) Q( k, i ), k < i
C
C L  :  R( i ) = SUM_k P( k ) Q( i, k ), i < k
C
C
C
C RANK = (/ ?, ?, ? /)
C
C M   :  EVERYTHING ELSE
C
C 

      USE_ORIG = .TRUE.

      IF ( ( RANK( 1 ) .EQ. 2 ) .AND.
     +     ( RANK( 2 ) .EQ. 2 ) .AND.
     +     ( RANK( 3 ) .EQ. 3 ) ) THEN

       USE_DG = .FALSE.

       IF ( PLIST( 1 ) .EQ. QLIST( 1 ) )  THEN
        IF ( PLIST( 2 ) .LT. QLIST( 2 ) ) THEN
         IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE A'

C CASE A : R( i, j ) = SUM_k P( k, i ) Q( k, j ) = SUM_k P^T( i, k ) Q( k, j )
C          ( i, j, k ) = ( 2, 3, 1 ),  A = P, B = Q

         POINT_A = POINT( 1 )
         POINT_B = POINT( 2 )
         POINT_C = POINT( 3 )

         transA = 'T'
         transB = 'N'

         M  = EXTENT( PLIST( 2 ) )
         N  = EXTENT( QLIST( 2 ) )
         NK = EXTENT( K )

         ldA = NK
         ldB = NK

         USE_DG = .TRUE.

        ELSEIF ( ( PLIST( 2 ) .GT. QLIST( 2 ) ) ) THEN
         IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE B'

C CASE B : R( i, j ) = SUM_k P( k, j ) Q( k, i ) = SUM_k Q^T( i, k ) P( k, j )
C          ( i, j, k ) = ( 2, 3, 1 ),  A = Q, B = P

         POINT_A = POINT( 2 )
         POINT_B = POINT( 1 )
         POINT_C = POINT( 3 )

         transA = 'T'
         transB = 'N'

         M  = EXTENT( QLIST( 2 ) )
         N  = EXTENT( PLIST( 2 ) )
         NK = EXTENT( K )

         ldA = NK
         ldB = NK

         USE_DG = .TRUE.

        ENDIF
       ELSEIF ( PLIST( 2 ) .EQ. QLIST( 1 ) ) THEN

        IF ( PLIST( 1 ) .LT. QLIST( 2 ) ) THEN
         IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE C'

C CASE C : R( i, j ) = SUM_k P( i, k ) Q( k, j )
C          ( i, j, k ) = ( 1, 3, 2 ) ,  A = P, B = Q

         POINT_A = POINT( 1 )
         POINT_B = POINT( 2 )
         POINT_C = POINT( 3 )

         transA = 'N'
         transB = 'N'

         M  = EXTENT( PLIST( 1 ) )
         N  = EXTENT( QLIST( 2 ) )
         NK = EXTENT( K )

         ldA = M
         ldB = NK

         USE_DG = .TRUE.
        ENDIF
       ELSEIF ( PLIST( 1 ) .EQ. QLIST( 2 ) ) THEN

        IF ( QLIST( 1 ) .LT. PLIST( 2 ) ) THEN
         IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE D'

C CASE D : R( i, j ) = SUM_k P( k, j ) Q( i, k ) = SUM_k Q( i, k ) P( k, j )
C          ( i, j, k ) = ( 1, 3, 2 ),  A = Q, B = P

         POINT_A = POINT( 2 )
         POINT_B = POINT( 1 )
         POINT_C = POINT( 3 )

         transA = 'N'
         transB = 'N'

         M  = EXTENT( QLIST( 1 ) )
         N  = EXTENT( PLIST( 2 ) )
         NK = EXTENT( K )

         ldA = M
         ldB = NK

         USE_DG = .TRUE.

        ENDIF
       ELSEIF ( PLIST( 2 ) .EQ. QLIST( 2 ) ) THEN

        IF ( PLIST( 1 ) .LT. QLIST( 1 ) ) THEN
         IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE E'

C CASE E : R( i, j ) = SUM_k P( i, k ) Q( j, k ) = SUM_k P( i, k ) Q^T( k, j )
C          ( i, j, k ) = ( 1, 2, 3 ),  A = P, B = Q

         POINT_A = POINT( 1 )
         POINT_B = POINT( 2 )
         POINT_C = POINT( 3 )

         transA = 'N'
         transB = 'T'

         M  = EXTENT( PLIST( 1 ) )
         N  = EXTENT( QLIST( 1 ) )
         NK = EXTENT( K )

         ldA = M
         ldB = N

         USE_DG = .TRUE.

        ELSEIF ( PLIST( 1 ) .GT. QLIST( 1 ) ) THEN
         IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE F'

C CASE F : R( i, j ) = SUM_k P( j, k ) Q( i, k ) = SUM_k Q( i, k ) P^T( k, j )
C          ( i, j, k ) = ( 1, 2, 3 ),  A = Q, B = P

         POINT_A = POINT( 2 )
         POINT_B = POINT( 1 )
         POINT_C = POINT( 3 )

         transA = 'N'
         transB = 'T'

         M  = EXTENT( QLIST( 1 ) )
         N  = EXTENT( PLIST( 1 ) )
         NK = EXTENT( K )

         ldA = M
         ldB = N

         USE_DG = .TRUE.

        ENDIF
       ENDIF

       IF ( USE_DG ) THEN

        USE_ORIG = .FALSE.

        CALL DGEMM( transA, transB, M, N, NK, 1.D0, ARRAY( POINT_A ),
     +              ldA, ARRAY( POINT_B ), ldB, 0.D0,
     +              ARRAY( POINT_C ), M )

        CALL RESCALE_1( M*N, IERROR, LOGLIK, ARRAY( POINT_C ) )

       ENDIF

      ELSEIF ( ( RANK( 1 ) .EQ. 2 ) .AND.
     +         ( RANK( 2 ) .EQ. 2 ) .AND.
     +         ( RANK( 3 ) .EQ. 2 ) ) THEN

       IF ( K .EQ. QLIST( 1 ) ) THEN
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE G'
C CASE G : R( i ) = SUM_k P( k, i ) Q( k, i )
        USE_ORIG = .FALSE.

        N = EXTENT( PLIST( 1 ) )
        M = EXTENT( PLIST( 2 ) )

        CALL MUL_SUM_G( N, M, AHI, ALO, ARRAY( POINT( 1 ) ),
     +                  ARRAY( POINT( 2 ) ), ARRAY( POINT( 3 ) ) )

        CALL RESCALE_2( M, IERROR, LOGLIK, AHI, ALO,
     +                  ARRAY( POINT( 3 ) ) )

       ELSEIF ( K .EQ. QLIST( 2 ) ) THEN
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE H'
C CASE H : R( i ) = SUM_k P( i, k ) Q( i, k )
        USE_ORIG = .FALSE.

        N = EXTENT( PLIST( 1 ) )
        M = EXTENT( PLIST( 2 ) )

        CALL MUL_SUM_H( N, M, AHI, ALO, ARRAY( POINT( 1 ) ),
     +                  ARRAY( POINT( 2 ) ), ARRAY( POINT( 3 ) ) )

        CALL RESCALE_2( N, IERROR, LOGLIK, AHI, ALO,
     +                  ARRAY( POINT( 3 ) ) )

       ENDIF

      ELSEIF ( ( RANK( 1 ) .EQ. 2 ) .AND.
     +         ( RANK( 2 ) .EQ. 1 ) .AND.
     +         ( RANK( 3 ) .EQ. 2 ) ) THEN

       IF ( K .EQ. PLIST( 1 ) ) THEN
        USE_ORIG = .FALSE.
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE I'
C CASE I : R( i ) = SUM_k P( k, i ) Q( k ) =  SUM_k P^T( i, k ) Q( k )

        transA = 'T'
        INCX = 1
        INCY = 1
        M = EXTENT( PLIST( 1 ) )
        N = EXTENT( PLIST( 2 ) )

        CALL DGEMV( transA, M, N, 1.D0, ARRAY( POINT( 1 ) ), M,
     +              ARRAY( POINT( 2 ) ), INCX, 0.D0,
     +              ARRAY( POINT( 3 ) ), INCY )

        CALL RESCALE_1( N, IERROR, LOGLIK, ARRAY( POINT( 3 ) ) )

       ELSEIF (K .EQ. PLIST( 2 ) ) THEN
        USE_ORIG = .FALSE.

        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE J'
C CASE J : R( i ) = SUM_k P( i, k ) Q( k )
        transA = 'N'
        INCX = 1
        INCY = 1
        M = EXTENT( PLIST( 1 ) )
        N = EXTENT( PLIST( 2 ) )

        CALL DGEMV( transA, M, N, 1.D0, ARRAY( POINT( 1 ) ), M,
     +              ARRAY( POINT( 2 ) ), INCX, 0.D0,
     +              ARRAY( POINT( 3 ) ), INCY )

        CALL RESCALE_1( M, IERROR, LOGLIK, ARRAY( POINT( 3 ) ) )

       ENDIF

      ELSEIF ( ( RANK( 1 ) .EQ. 1 ) .AND.
     +         ( RANK( 2 ) .EQ. 2 ) .AND.
     +         ( RANK( 3 ) .EQ. 2 ) ) THEN

       IF ( K .EQ. QLIST( 1 ) ) THEN
        USE_ORIG = .FALSE.
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE K'
C CASE K : R( i ) = SUM_k P( k ) Q( k, i ) = SUM_k Q^T( i, k ) P( k )
        transA = 'T'
        INCX = 1
        INCY = 1
        M = EXTENT( QLIST( 1 ) )
        N = EXTENT( QLIST( 2 ) )

        CALL DGEMV( transA, M, N, 1.D0, ARRAY( POINT( 2 ) ), M,
     +              ARRAY( POINT( 1 ) ), INCX, 0.D0,
     +              ARRAY( POINT( 3 ) ), INCY )

        CALL RESCALE_1( N, IERROR, LOGLIK, ARRAY( POINT( 3 ) ) )

       ELSEIF ( K .EQ. QLIST( 2 ) ) THEN
        USE_ORIG = .FALSE.
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE L'
C CASE L : R( i ) = SUM_k P( k ) Q( i, k ) = SUM_k Q( i, k ) P( k )
        transA = 'N'
        INCX = 1
        INCY = 1
        M = EXTENT( QLIST( 1 ) )
        N = EXTENT( QLIST( 2 ) )

        CALL DGEMV( transA, M, N, 1.D0, ARRAY( POINT( 2 ) ), M,
     +              ARRAY( POINT( 1 ) ), INCX, 0.D0,
     +              ARRAY( POINT( 3 ) ), INCY )

        CALL RESCALE_1( M, IERROR, LOGLIK, ARRAY( POINT( 3 ) ) )

       ENDIF
      ENDIF

      IF ( USE_ORIG ) THEN
       IF ( ECHO_CASES ) WRITE( *, * ) 'MUL_SUM: CASE M - MULSUM_ORIG'

       CALL MULSUM_ORIG( ARRAY, LOGLIK, EXTENT, INCRP, INCRQ, INDEX,
     +                   PLIST, POINT, QLIST, RANK, IERROR, IOPER, K )

      ENDIF

      RETURN
      END


      SUBROUTINE MUL_SUM_G( N, M, AHI, ALO, P, Q, R )
C CASE G : R( i ) = SUM_k P( k, i ) Q( k, i ),  k = 1, n

      IMPLICIT NONE
      INTEGER N, M
      DOUBLE PRECISION AHI, ALO
      DOUBLE PRECISION P( N, M ), Q( N, M ), R( M )

      INTEGER I, K
      DOUBLE PRECISION TMP

      AHI = 0.0D0
      ALO = 1.0D20

      DO I = 1, M
       TMP = 0.0D0
       DO K = 1, N
        TMP = TMP + P( K, I )*Q( K, I )
       ENDDO
       R( i ) = TMP
       IF ( TMP .GT. 0.0D0 ) THEN
        AHI = MAX( AHI, TMP )
        ALO = MIN( ALO, TMP )
       ENDIF
      ENDDO

      RETURN
      END


      SUBROUTINE MUL_SUM_H( N, M, AHI, ALO, P, Q, R )
C CASE H : R( i ) = SUM_k P( i, k ) Q( i, k ),   k = 1, m

      IMPLICIT NONE
      INTEGER N, M
      DOUBLE PRECISION AHI, ALO
      DOUBLE PRECISION P( N, M ), Q( N, M ), R( N )

      INTEGER I, K
      DOUBLE PRECISION TMP

      DO I = 1, N
       R( I ) = 0.D0
      ENDDO

      DO K = 1, M
       DO I = 1, N
        R( I ) = R( I ) + P( I, K )*Q( I, K )
       ENDDO
      ENDDO

      AHI = 0.0D0
      ALO = 1.0D20

      DO I = 1, N
       TMP = R( I )
       IF ( TMP .GT. 0.0D0 ) THEN
        AHI = MAX( AHI, TMP )
        ALO = MIN( ALO, TMP )
       ENDIF
      ENDDO

      RETURN
      END


      SUBROUTINE MUL( ARRAY, LOGLIK, EXTENT, INCRP, INCRQ, INDEX,
     +                PLIST, POINT, QLIST, RANK, IERROR, IOPER, K,
     +                MAXA )
C
C THIS SUBROUTINE TAKES TWO ARRAYS P AND Q AND FORMS
C THEIR PRODUCT R. ALL THREE ARRAYS ARE LISTED IN REVERSE
C DICTIONARY ORDER IN ARRAY.  PLIST AND QLIST GIVE THE
C CONSOLIDATED NODES IN P AND Q.
C
      IMPLICIT NONE

      INTEGER IOPER, MAXA, K, IERROR
      INTEGER RANK( 3 ), point( 3 )
      INTEGER QLIST( * ), PLIST( * ), index( * )
      INTEGER incrq( * ), incrp( * ), EXTENT( * )

      DOUBLE PRECISION AHI, ALO
      DOUBLE PRECISION LOGLIK, ARRAY( MAXA )

      INTEGER I, NLENM, N, M
      LOGICAL USE_ORIG, ECHO_CASES
C      PARAMETER( ECHO_CASES = .TRUE. )
      PARAMETER( ECHO_CASES = .FALSE. )

      USE_ORIG = .TRUE.

      IERROR = 0

      NLENM = 1
      DO I = 1, RANK( 3 )
       NLENM = NLENM*EXTENT( I )
      ENDDO


C 
C
C CASE A :  R( i ) = P( i ) Q( i )
C
C CASE B :  R( i, j ) = P( i ) Q( i, j )
C
C CASE C :  R( i, j ) = P( j ) Q( i, j )
C
C CASE D :  R( i, j ) = P( i, j ) Q( i )
C
C CASE E :  R( i, j ) = P( i, j ) Q( j )
C
C CASE F :  R( i, j ) = P( i, j ) Q( i, j )
C
C 


      IF ( ( RANK( 1 ) .EQ. 1 ) .AND.
     +           ( RANK( 2 ) .EQ. 1 ) .AND.
     +           ( RANK( 3 ) .EQ. 1 ) ) THEN

C CASE A :  R( i ) = P( i ) Q( i )
       USE_ORIG = .FALSE.
       IF ( ECHO_CASES ) WRITE( *, * ) 'MUL: CASE A'

       N = EXTENT( 1 )

       CALL MUL_A( N, ARRAY( POINT( 1 ) ), ARRAY( POINT( 2 ) ),
     +             ARRAY( POINT( 3 ) ), AHI, ALO )

       CALL RESCALE_2( NLENM, IERROR, LOGLIK, AHI, ALO,
     +                 ARRAY( POINT( 3 ) ) )

      ELSEIF ( ( RANK( 1 ) .EQ. 1 ) .AND.
     +         ( RANK( 2 ) .EQ. 2 ) .AND.
     +         ( RANK( 3 ) .EQ. 2 ) ) THEN

       IF ( PLIST( 1 ) .EQ. 1 ) THEN
C CASE B :  R( i, j ) = P( i ) Q( i, j )
        USE_ORIG = .FALSE.
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL: CASE B'

        N = EXTENT( 1 )
        M = EXTENT( 2 )

        CALL MUL_B( N, M, ARRAY( POINT( 1 ) ), ARRAY( POINT( 2 ) ),
     +              ARRAY( POINT( 3 ) ), AHI, ALO )

        CALL RESCALE_2( NLENM, IERROR, LOGLIK, AHI, ALO,
     +                  ARRAY( POINT( 3 ) ) )

       ELSEIF ( PLIST( 1 ) .EQ. 2 ) THEN
C CASE C :  R( i, j ) = P( j ) Q( i, j )
        USE_ORIG = .FALSE.
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL: CASE C'

        N = EXTENT( 1 )
        M = EXTENT( 2 )

        CALL MUL_C( N, M, ARRAY( POINT( 1 ) ), ARRAY( POINT( 2 ) ),
     +               ARRAY( POINT( 3 ) ), AHI, ALO )

        CALL RESCALE_2( NLENM, IERROR, LOGLIK, AHI, ALO,
     +                  ARRAY( POINT( 3 ) ) )

       ENDIF
      ELSEIF ( ( RANK( 1 ) .EQ. 2 ) .AND.
     +         ( RANK( 2 ) .EQ. 1 ).AND.
     +         ( RANK( 3 ) .EQ. 2 ) ) THEN

       IF ( QLIST( 1 ) .EQ. 1 ) THEN
C CASE D :  R( i, j ) = P( i, j ) Q( i )
        USE_ORIG = .FALSE.
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL: CASE D'

        N = EXTENT( 1 )
        M = EXTENT( 2 )

        CALL MUL_B( N, M, ARRAY( POINT( 2 ) ), ARRAY( POINT( 1 ) ),
     +              ARRAY( POINT( 3 ) ), AHI, ALO )

        CALL RESCALE_2( NLENM, IERROR, LOGLIK, AHI, ALO,
     +                  ARRAY( POINT( 3 ) ) )

       ELSEIF ( QLIST( 1 ) .EQ. 2 ) THEN
C CASE E :  R( i, j ) = P( i, j ) Q( j )
        USE_ORIG = .FALSE.
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL: CASE E'

        N = EXTENT( 1 )
        M = EXTENT( 2 )

        CALL MUL_C( N, M, ARRAY( POINT( 2 ) ), ARRAY( POINT( 1 ) ),
     +              ARRAY( POINT( 3 ) ), AHI, ALO )

        CALL RESCALE_2( NLENM, IERROR, LOGLIK, AHI, ALO,
     +                  ARRAY( POINT( 3 ) ) )
       ENDIF
      ELSEIF ( ( RANK( 1 ) .EQ. 2 ) .AND.
     +         ( RANK( 2 ) .EQ. 2 ) .AND.
     +         ( RANK( 3 ) .EQ. 2 ) ) THEN

       IF ( PLIST( 1 ) .EQ. QLIST( 1 ) ) THEN
C CASE F :  R( i, j ) = P( i, j ) Q( i, j )
        USE_ORIG = .FALSE.
        IF ( ECHO_CASES ) WRITE( *, * ) 'MUL: CASE F'

        N = EXTENT( 1 )
        M = EXTENT( 2 )

        CALL MUL_D( N, M, ARRAY( POINT( 1 ) ), ARRAY( POINT( 2 ) ),
     +              ARRAY( POINT( 3 ) ), AHI, ALO )

        CALL RESCALE_2( NLENM, IERROR, LOGLIK, AHI, ALO,
     +                  ARRAY( POINT( 3 ) ) )

       ENDIF
      ENDIF


CWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
      IF ( USE_ORIG ) THEN
       IF ( ECHO_CASES ) THEN
        WRITE( *, * ) 'MUL: CASE G - MULSUM_ORIG'
       ENDIF
       CALL MULSUM_ORIG( ARRAY, LOGLIK, EXTENT, INCRP, INCRQ, INDEX,
     +                   PLIST, POINT, QLIST, RANK, IERROR, IOPER, K )
      ENDIF
CWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

      RETURN
      END


      SUBROUTINE MUL_A( N, A, B, C, AHI, ALO )
C CASE A : C( i ) = A( i )*B( i )

      IMPLICIT NONE
      INTEGER N
      DOUBLE PRECISION AHI, ALO
      DOUBLE PRECISION A( N ), B( N ), C( N )

      INTEGER I
      DOUBLE PRECISION tmp

      AHI = 0.0d0
      ALO = 1.0d20

      DO I = 1, N
       tmp = A( I )*B( I )
       C( I ) = tmp
       IF ( tmp .GT. 0.0d0 ) THEN
        AHI = MAX( AHI, tmp )
        ALO = MIN( ALO, tmp )
       ENDIF
      ENDDO

      RETURN
      END


      SUBROUTINE MUL_B( N_1, N_2, A, B, C, AHI, ALO )
C CASE B: C( i, j ) = A( i )*B( i, j )

      IMPLICIT NONE
      INTEGER N_1, N_2
      DOUBLE PRECISION AHI, ALO
      DOUBLE PRECISION A( N_1 ), B( N_1, N_2 ), C( N_1, N_2 )

      INTEGER I, J
      DOUBLE PRECISION tmp

      AHI = 0.0d0
      ALO = 1.0d20

      DO J = 1, N_2
       DO I = 1, N_1
        tmp = A( I )*B( I, J )
        C( I, J ) = tmp
        IF ( tmp .GT. 0.0d0 ) THEN
         AHI = MAX( AHI, tmp )
         ALO = MIN( ALO, tmp )
        ENDIF
       ENDDO
      ENDDO

      RETURN
      END


      SUBROUTINE MUL_C( N_1, N_2, A, B, C, AHI, ALO )
C CASE C: C( i, j ) = A( j )*B( i, j )

      IMPLICIT NONE
      INTEGER N_1, N_2
      DOUBLE PRECISION AHI, ALO
      DOUBLE PRECISION A( N_2 ), B( N_1, N_2 ), C( N_1, N_2 )

      INTEGER I, J
      DOUBLE PRECISION tmp, tp

      AHI = 0.0d0
      ALO = 1.0d20

      DO J = 1, N_2
      tp = A( J )
       DO I = 1, N_1
        tmp = tp*B( I, J )
        C( I, J ) = tmp
        IF ( tmp .GT. 0.0d0 ) THEN
         AHI = MAX( AHI, tmp )
         ALO = MIN( ALO, tmp )
        ENDIF
       ENDDO
      ENDDO

      RETURN
      END


      SUBROUTINE MUL_D( N_1, N_2, A, B, C, AHI, ALO )
C CASE D: A( i, j ) = B( i, j )*C( i, j )

      IMPLICIT NONE
      INTEGER N_1, N_2
      DOUBLE PRECISION AHI, ALO
      DOUBLE PRECISION A( N_1, N_2 ), B( N_1, N_2 ), C( N_1, N_2 )

      INTEGER I, J
      DOUBLE PRECISION TMP

      AHI = 0.0d0
      ALO = 1.0d20

      DO J = 1, N_2
       DO I = 1, N_1
        TMP = A( I, J )*B( I, J )
        C( I, J ) = TMP
        IF ( TMP .GT. 0.0d0 ) THEN
         AHI = MAX( AHI, TMP )
         ALO = MIN( ALO, TMP )
        ENDIF
       ENDDO
      ENDDO

      RETURN
      END


      SUBROUTINE RESCALE_1( ALEN, IERROR, LOGLIK, ARRAY )
      IMPLICIT NONE
      INTEGER ALEN, IERROR
      DOUBLE PRECISION LOGLIK
      DOUBLE PRECISION ARRAY( ALEN )

      DOUBLE PRECISION A, AHI, ALO
      INTEGER I

      AHI = 0.0D0
      ALO = 1.0D20

      DO I = 1, ALEN
       A = ARRAY( I )
       IF ( A .GT. 0.0d0 ) THEN
        AHI = MAX( AHI, A )
        ALO = MIN( ALO, A )
       ENDIF
      ENDDO

C RETURN WITH AN ERROR MESSAGE IF R CONSISTS OF ALL ZEROS.
      IF ( AHI .LE. 0.0D0 ) THEN
       IERROR = 1
       RETURN
      ENDIF

C RESCALE IF NECESSARY.
      IF ( ( AHI .GT. 1.0D10 ) .OR.
     +     ( ( ALO .LE. 1.0D-10 ) .AND.
     +       ( AHI .LT. 1.0D0 ) ) ) THEN
       LOGLIK = LOGLIK + LOG( AHI )
       DO I = 1, ALEN
        A = ARRAY( I )
        IF ( A .GT. 0.0D0 ) ARRAY( I ) = A / AHI
       ENDDO
      ENDIF

      END


      SUBROUTINE RESCALE_2( ALEN, IERROR, LOGLIK, AHI, ALO,
     +                      ARRAY )

      IMPLICIT NONE
      INTEGER ALEN, IERROR
      DOUBLE PRECISION LOGLIK, AHI, ALO
      DOUBLE PRECISION ARRAY( ALEN )

      INTEGER I
      DOUBLE PRECISION A

C RETURN WITH AN ERROR MESSAGE IF R CONSISTS OF ALL ZEROS.
      IF ( AHI .LE. 0.0D0 ) THEN
       IERROR = 1
       RETURN
      ENDIF

C RESCALE IF NECESSARY.
      IF ( ( AHI .GT. 1.0D10 ) .OR.
     +     ( ( ALO .LE. 1.0D-10 ) .AND.
     +       ( AHI .LT. 1.0D0 ) ) ) THEN
       LOGLIK = LOGLIK + LOG( AHI )
       DO I = 1, ALEN
        A = ARRAY( I )
        IF ( A .GT. 0.0D0 ) ARRAY( I ) = A / AHI
       ENDDO
      ENDIF

      END
C###############################################################################


      SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALPHA,BETA
      INTEGER INCX,INCY,LDA,M,N
      CHARACTER*1 TRANS
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LDA,*),X(*),Y(*)
C     ..
C
C  Purpose
C  =======
C
C  DGEMV  performs one of the matrix-vector operations
C
C     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
C
C  where alpha and beta are scalars, x and y are vectors and A is an
C  m by n matrix.
C
C  Arguments
C  ==========
C
C  TRANS  - CHARACTER*1.
C           On entry, TRANS specifies the operation to be performed as
C           follows:
C
C              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
C
C              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
C
C              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
C
C           Unchanged on exit.
C
C  M      - INTEGER.
C           On entry, M specifies the number of rows of the matrix A.
C           M must be at least zero.
C           Unchanged on exit.
C
C  N      - INTEGER.
C           On entry, N specifies the number of columns of the matrix A.
C           N must be at least zero.
C           Unchanged on exit.
C
C  ALPHA  - DOUBLE PRECISION.
C           On entry, ALPHA specifies the scalar alpha.
C           Unchanged on exit.
C
C  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
C           Before entry, the leading m by n part of the array A must
C           contain the matrix of coefficients.
C           Unchanged on exit.
C
C  LDA    - INTEGER.
C           On entry, LDA specifies the first dimension of A as declared
C           in the calling (sub) program. LDA must be at least
C           max( 1, m ).
C           Unchanged on exit.
C
C  X      - DOUBLE PRECISION array of DIMENSION at least
C           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
C           and at least
C           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
C           Before entry, the incremented array X must contain the
C           vector x.
C           Unchanged on exit.
C
C  INCX   - INTEGER.
C           On entry, INCX specifies the increment for the elements of
C           X. INCX must not be zero.
C           Unchanged on exit.
C
C  BETA   - DOUBLE PRECISION.
C           On entry, BETA specifies the scalar beta. When BETA is
C           supplied as zero then Y need not be set on input.
C           Unchanged on exit.
C
C  Y      - DOUBLE PRECISION array of DIMENSION at least
C           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
C           and at least
C           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
C           Before entry with BETA non-zero, the incremented array Y
C           must contain the vector y. On exit, Y is overwritten by the
C           updated vector y.
C
C  INCY   - INTEGER.
C           On entry, INCY specifies the increment for the elements of
C           Y. INCY must not be zero.
C           Unchanged on exit.
C
C
C  Level 2 Blas routine.
C
C  -- Written on 22-October-1986.
C     Jack Dongarra, Argonne National Lab.
C     Jeremy Du Croz, Nag Central Office.
C     Sven Hammarling, Nag Central Office.
C     Richard Hanson, Sandia National Labs.
C
C
C     .. Parameters ..
      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,INFO,IX,IY,J,JX,JY,KX,KY,LENX,LENY
C     ..
C     .. External Functions ..
      LOGICAL LSAME
      EXTERNAL LSAME
C     ..
C     .. External Subroutines ..
      EXTERNAL XERBLA
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C
C     Test the input parameters.
C
      INFO = 0
      IF (.NOT.LSAME(TRANS,'N') .AND. .NOT.LSAME(TRANS,'T') .AND.
     +    .NOT.LSAME(TRANS,'C')) THEN
          INFO = 1
      ELSE IF (M.LT.0) THEN
          INFO = 2
      ELSE IF (N.LT.0) THEN
          INFO = 3
      ELSE IF (LDA.LT.MAX(1,M)) THEN
          INFO = 6
      ELSE IF (INCX.EQ.0) THEN
          INFO = 8
      ELSE IF (INCY.EQ.0) THEN
          INFO = 11
      END IF
      IF (INFO.NE.0) THEN
          CALL XERBLA('DGEMV ',INFO)
          RETURN
      END IF
C
C     Quick return if possible.
C
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.
     +    ((ALPHA.EQ.ZERO).AND. (BETA.EQ.ONE))) RETURN
C
C     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
C     up the start points in  X  and  Y.
C
      IF (LSAME(TRANS,'N')) THEN
          LENX = N
          LENY = M
      ELSE
          LENX = M
          LENY = N
      END IF
      IF (INCX.GT.0) THEN
          KX = 1
      ELSE
          KX = 1 - (LENX-1)*INCX
      END IF
      IF (INCY.GT.0) THEN
          KY = 1
      ELSE
          KY = 1 - (LENY-1)*INCY
      END IF
C
C     Start the operations. In this version the elements of A are
C     accessed sequentially with one pass through A.
C
C     First form  y := beta*y.
C
      IF (BETA.NE.ONE) THEN
          IF (INCY.EQ.1) THEN
              IF (BETA.EQ.ZERO) THEN
                  DO 10 I = 1,LENY
                      Y(I) = ZERO
   10             CONTINUE
              ELSE
                  DO 20 I = 1,LENY
                      Y(I) = BETA*Y(I)
   20             CONTINUE
              END IF
          ELSE
              IY = KY
              IF (BETA.EQ.ZERO) THEN
                  DO 30 I = 1,LENY
                      Y(IY) = ZERO
                      IY = IY + INCY
   30             CONTINUE
              ELSE
                  DO 40 I = 1,LENY
                      Y(IY) = BETA*Y(IY)
                      IY = IY + INCY
   40             CONTINUE
              END IF
          END IF
      END IF
      IF (ALPHA.EQ.ZERO) RETURN
      IF (LSAME(TRANS,'N')) THEN
C
C        Form  y := alpha*A*x + y.
C
          JX = KX
          IF (INCY.EQ.1) THEN
              DO 60 J = 1,N
                  IF (X(JX).NE.ZERO) THEN
                      TEMP = ALPHA*X(JX)
                      DO 50 I = 1,M
                          Y(I) = Y(I) + TEMP*A(I,J)
   50                 CONTINUE
                  END IF
                  JX = JX + INCX
   60         CONTINUE
          ELSE
              DO 80 J = 1,N
                  IF (X(JX).NE.ZERO) THEN
                      TEMP = ALPHA*X(JX)
                      IY = KY
                      DO 70 I = 1,M
                          Y(IY) = Y(IY) + TEMP*A(I,J)
                          IY = IY + INCY
   70                 CONTINUE
                  END IF
                  JX = JX + INCX
   80         CONTINUE
          END IF
      ELSE
C
C        Form  y := alpha*A'*x + y.
C
          JY = KY
          IF (INCX.EQ.1) THEN
              DO 100 J = 1,N
                  TEMP = ZERO
                  DO 90 I = 1,M
                      TEMP = TEMP + A(I,J)*X(I)
   90             CONTINUE
                  Y(JY) = Y(JY) + ALPHA*TEMP
                  JY = JY + INCY
  100         CONTINUE
          ELSE
              DO 120 J = 1,N
                  TEMP = ZERO
                  IX = KX
                  DO 110 I = 1,M
                      TEMP = TEMP + A(I,J)*X(IX)
                      IX = IX + INCX
  110             CONTINUE
                  Y(JY) = Y(JY) + ALPHA*TEMP
                  JY = JY + INCY
  120         CONTINUE
          END IF
      END IF
C
      RETURN
C
C     End of DGEMV .
C
      END


C###############################################################################


      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALPHA,BETA
      INTEGER K,LDA,LDB,LDC,M,N
      CHARACTER*1 TRANSA,TRANSB
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)
C     ..
C
C  Purpose
C  =======
C
C  DGEMM  performs one of the matrix-matrix operations
C
C     C := alpha*op( A )*op( B ) + beta*C,
C
C  where  op( X ) is one of
C
C     op( X ) = X   or   op( X ) = X',
C
C  alpha and beta are scalars, and A, B and C are matrices, with op( A )
C  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
C
C  Arguments
C  ==========
C
C  TRANSA - CHARACTER*1.
C           On entry, TRANSA specifies the form of op( A ) to be used in
C           the matrix multiplication as follows:
C
C              TRANSA = 'N' or 'n',  op( A ) = A.
C
C              TRANSA = 'T' or 't',  op( A ) = A'.
C
C              TRANSA = 'C' or 'c',  op( A ) = A'.
C
C           Unchanged on exit.
C
C  TRANSB - CHARACTER*1.
C           On entry, TRANSB specifies the form of op( B ) to be used in
C           the matrix multiplication as follows:
C
C              TRANSB = 'N' or 'n',  op( B ) = B.
C
C              TRANSB = 'T' or 't',  op( B ) = B'.
C
C              TRANSB = 'C' or 'c',  op( B ) = B'.
C
C           Unchanged on exit.
C
C  M      - INTEGER.
C           On entry,  M  specifies  the number  of rows  of the  matrix
C           op( A )  and of the  matrix  C.  M  must  be at least  zero.
C           Unchanged on exit.
C
C  N      - INTEGER.
C           On entry,  N  specifies the number  of columns of the matrix
C           op( B ) and the number of columns of the matrix C. N must be
C           at least zero.
C           Unchanged on exit.
C
C  K      - INTEGER.
C           On entry,  K  specifies  the number of columns of the matrix
C           op( A ) and the number of rows of the matrix op( B ). K must
C           be at least  zero.
C           Unchanged on exit.
C
C  ALPHA  - DOUBLE PRECISION.
C           On entry, ALPHA specifies the scalar alpha.
C           Unchanged on exit.
C
C  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
C           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
C           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
C           part of the array  A  must contain the matrix  A,  otherwise
C           the leading  k by m  part of the array  A  must contain  the
C           matrix A.
C           Unchanged on exit.
C
C  LDA    - INTEGER.
C           On entry, LDA specifies the first dimension of A as declared
C           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
C           LDA must be at least  max( 1, m ), otherwise  LDA must be at
C           least  max( 1, k ).
C           Unchanged on exit.
C
C  B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
C           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
C           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
C           part of the array  B  must contain the matrix  B,  otherwise
C           the leading  n by k  part of the array  B  must contain  the
C           matrix B.
C           Unchanged on exit.
C
C  LDB    - INTEGER.
C           On entry, LDB specifies the first dimension of B as declared
C           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
C           LDB must be at least  max( 1, k ), otherwise  LDB must be at
C           least  max( 1, n ).
C           Unchanged on exit.
C
C  BETA   - DOUBLE PRECISION.
C           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
C           supplied as zero then C need not be set on input.
C           Unchanged on exit.
C
C  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
C           Before entry, the leading  m by n  part of the array  C must
C           contain the matrix  C,  except when  beta  is zero, in which
C           case C need not be set on entry.
C           On exit, the array  C  is overwritten by the  m by n  matrix
C           ( alpha*op( A )*op( B ) + beta*C ).
C
C  LDC    - INTEGER.
C           On entry, LDC specifies the first dimension of C as declared
C           in  the  calling  (sub)  program.   LDC  must  be  at  least
C           max( 1, m ).
C           Unchanged on exit.
C
C
C  Level 3 Blas routine.
C
C  -- Written on 8-February-1989.
C     Jack Dongarra, Argonne National Laboratory.
C     Iain Duff, AERE Harwell.
C     Jeremy Du Croz, Numerical Algorithms Group Ltd.
C     Sven Hammarling, Numerical Algorithms Group Ltd.
C
C
C     .. External Functions ..
      LOGICAL LSAME
      EXTERNAL LSAME
C     ..
C     .. External Subroutines ..
      EXTERNAL XERBLA
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB
      LOGICAL NOTA,NOTB
C     ..
C     .. Parameters ..
      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
C     ..
C
C     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
C     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
C     and  columns of  A  and the  number of  rows  of  B  respectively.
C
      NOTA = LSAME(TRANSA,'N')
      NOTB = LSAME(TRANSB,'N')
      IF (NOTA) THEN
          NROWA = M
          NCOLA = K
      ELSE
          NROWA = K
          NCOLA = M
      END IF
      IF (NOTB) THEN
          NROWB = K
      ELSE
          NROWB = N
      END IF
C
C     Test the input parameters.
C
      INFO = 0
      IF ((.NOT.NOTA) .AND. (.NOT.LSAME(TRANSA,'C')) .AND.
     +    (.NOT.LSAME(TRANSA,'T'))) THEN
          INFO = 1
      ELSE IF ((.NOT.NOTB) .AND. (.NOT.LSAME(TRANSB,'C')) .AND.
     +         (.NOT.LSAME(TRANSB,'T'))) THEN
          INFO = 2
      ELSE IF (M.LT.0) THEN
          INFO = 3
      ELSE IF (N.LT.0) THEN
          INFO = 4
      ELSE IF (K.LT.0) THEN
          INFO = 5
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN
          INFO = 8
      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN
          INFO = 10
      ELSE IF (LDC.LT.MAX(1,M)) THEN
          INFO = 13
      END IF
      IF (INFO.NE.0) THEN
          CALL XERBLA('DGEMM ',INFO)
          RETURN
      END IF
C
C     Quick return if possible.
C
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.
     +    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN
C
C     And if  alpha.eq.zero.
C
      IF (ALPHA.EQ.ZERO) THEN
          IF (BETA.EQ.ZERO) THEN
              DO 20 J = 1,N
                  DO 10 I = 1,M
                      C(I,J) = ZERO
   10             CONTINUE
   20         CONTINUE
          ELSE
              DO 40 J = 1,N
                  DO 30 I = 1,M
                      C(I,J) = BETA*C(I,J)
   30             CONTINUE
   40         CONTINUE
          END IF
          RETURN
      END IF
C
C     Start the operations.
C
      IF (NOTB) THEN
          IF (NOTA) THEN
C
C           Form  C := alpha*A*B + beta*C.
C
              DO 90 J = 1,N
                  IF (BETA.EQ.ZERO) THEN
                      DO 50 I = 1,M
                          C(I,J) = ZERO
   50                 CONTINUE
                  ELSE IF (BETA.NE.ONE) THEN
                      DO 60 I = 1,M
                          C(I,J) = BETA*C(I,J)
   60                 CONTINUE
                  END IF
                  DO 80 L = 1,K
                      IF (B(L,J).NE.ZERO) THEN
                          TEMP = ALPHA*B(L,J)
                          DO 70 I = 1,M
                              C(I,J) = C(I,J) + TEMP*A(I,L)
   70                     CONTINUE
                      END IF
   80             CONTINUE
   90         CONTINUE
          ELSE
C
C           Form  C := alpha*A'*B + beta*C
C
              DO 120 J = 1,N
                  DO 110 I = 1,M
                      TEMP = ZERO
                      DO 100 L = 1,K
                          TEMP = TEMP + A(L,I)*B(L,J)
  100                 CONTINUE
                      IF (BETA.EQ.ZERO) THEN
                          C(I,J) = ALPHA*TEMP
                      ELSE
                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)
                      END IF
  110             CONTINUE
  120         CONTINUE
          END IF
      ELSE
          IF (NOTA) THEN
C
C           Form  C := alpha*A*B' + beta*C
C
              DO 170 J = 1,N
                  IF (BETA.EQ.ZERO) THEN
                      DO 130 I = 1,M
                          C(I,J) = ZERO
  130                 CONTINUE
                  ELSE IF (BETA.NE.ONE) THEN
                      DO 140 I = 1,M
                          C(I,J) = BETA*C(I,J)
  140                 CONTINUE
                  END IF
                  DO 160 L = 1,K
                      IF (B(J,L).NE.ZERO) THEN
                          TEMP = ALPHA*B(J,L)
                          DO 150 I = 1,M
                              C(I,J) = C(I,J) + TEMP*A(I,L)
  150                     CONTINUE
                      END IF
  160             CONTINUE
  170         CONTINUE
          ELSE
C
C           Form  C := alpha*A'*B' + beta*C
C
              DO 200 J = 1,N
                  DO 190 I = 1,M
                      TEMP = ZERO
                      DO 180 L = 1,K
                          TEMP = TEMP + A(L,I)*B(J,L)
  180                 CONTINUE
                      IF (BETA.EQ.ZERO) THEN
                          C(I,J) = ALPHA*TEMP
                      ELSE
                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)
                      END IF
  190             CONTINUE
  200         CONTINUE
          END IF
      END IF
C
      RETURN
C
C     End of DGEMM .
C

      END

C###############################################################################


      SUBROUTINE XERBLA(SRNAME,INFO)
C
C  -- LAPACK auxiliary routine (preliminary version) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
      INTEGER INFO
      CHARACTER*6 SRNAME
C     ..
C
C  Purpose
C  =======
C
C  XERBLA  is an error handler for the LAPACK routines.
C  It is called by an LAPACK routine if an input parameter has an
C  invalid value.  A message is printed and execution stops.
C
C  Installers may consider modifying the STOP statement in order to
C  call system-specific exception-handling facilities.
C
C  Arguments
C  =========
C
C  SRNAME  (input) CHARACTER*6
C          The name of the routine which called XERBLA.
C
C  INFO    (input) INTEGER
C          The position of the invalid parameter in the parameter list
C          of the calling routine.
C
C
      WRITE (*,FMT=9999) SRNAME,INFO
C
      STOP
C
 9999 FORMAT (' ** On entry to ',A6,' parameter number ',I2,' had ',
     +       'an illegal value')
C
C     End of XERBLA
C
      END


C###############################################################################


      LOGICAL FUNCTION LSAME(CA,CB)
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
      CHARACTER*1 CA,CB
C     ..
C
C  Purpose
C  =======
C
C  LSAME returns .TRUE. if CA is the same letter as CB regardless of
C  case.
C
C  Arguments
C  =========
C
C  CA      (input) CHARACTER*1
C
C  CB      (input) CHARACTER*1
C          CA and CB specify the single characters to be compared.
C
C =====================================================================
C
C     .. Intrinsic Functions ..
      INTRINSIC ICHAR
C     ..
C     .. Local Scalars ..
      INTEGER INTA,INTB,ZCODE
C     ..
C
C     Test if the characters are equal
C
      LSAME = CA .EQ. CB
      IF (LSAME) RETURN
C
C     Now test for equivalence if both characters are alphabetic.
C
      ZCODE = ICHAR('Z')
C
C     Use 'Z' rather than 'A' so that ASCII can be detected on Prime
C     machines, on which ICHAR returns a value with bit 8 set.
C     ICHAR('A') on Prime machines returns 193 which is the same as
C     ICHAR('A') on an EBCDIC machine.
C
      INTA = ICHAR(CA)
      INTB = ICHAR(CB)
C
      IF (ZCODE.EQ.90 .OR. ZCODE.EQ.122) THEN
C
C        ASCII is assumed - ZCODE is the ASCII code of either lower or
C        upper case 'Z'.
C
          IF (INTA.GE.97 .AND. INTA.LE.122) INTA = INTA - 32
          IF (INTB.GE.97 .AND. INTB.LE.122) INTB = INTB - 32
C
      ELSE IF (ZCODE.EQ.233 .OR. ZCODE.EQ.169) THEN
C
C        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
C        upper case 'Z'.
C
          IF (INTA.GE.129 .AND. INTA.LE.137 .OR.
     +        INTA.GE.145 .AND. INTA.LE.153 .OR.
     +        INTA.GE.162 .AND. INTA.LE.169) INTA = INTA + 64
          IF (INTB.GE.129 .AND. INTB.LE.137 .OR.
     +        INTB.GE.145 .AND. INTB.LE.153 .OR.
     +        INTB.GE.162 .AND. INTB.LE.169) INTB = INTB + 64
C
      ELSE IF (ZCODE.EQ.218 .OR. ZCODE.EQ.250) THEN
C
C        ASCII is assumed, on Prime machines - ZCODE is the ASCII code
C        plus 128 of either lower or upper case 'Z'.
C
          IF (INTA.GE.225 .AND. INTA.LE.250) INTA = INTA - 32
          IF (INTB.GE.225 .AND. INTB.LE.250) INTB = INTB - 32
      END IF
      LSAME = INTA .EQ. INTB
C
C     RETURN
C
C     End of LSAME
C
      END

C###############################################################################
